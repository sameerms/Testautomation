/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function() {
var __m = ["exports","require","vs/base/common/winjs.base","vs/base/common/event","vs/workbench/api/node/extHost.protocol","vs/workbench/api/node/extHostTypes","vs/base/common/uri","vs/platform/instantiation/common/instantiation","vs/base/common/strings","vs/base/common/platform","vs/base/common/async","vs/base/common/objects","vs/base/common/errors","vs/base/common/paths","vs/base/common/types","vs/base/common/arrays","vs/workbench/api/node/extHostTypeConverters","vs/base/common/lifecycle","vs/nls","vs/nls!vs/workbench/node/extensionHostProcess","path","vs/base/common/map","sql/workbench/api/node/sqlExtHost.protocol","vs/editor/common/editorCommon","vs/editor/common/modes/languageConfiguration","vs/base/common/severity","vs/platform/configuration/common/configuration","vs/base/common/htmlContent","vs/base/common/glob","vs/base/common/cancellation","vs/base/common/assert","vs/platform/workspace/common/workspace","fs","vs/base/common/functional","vs/editor/common/model/wordHelper","vs/base/parts/ipc/common/ipc","vs/editor/common/services/modelService","vs/workbench/services/textfile/common/textfiles","vs/editor/common/modes","vs/editor/common/modes/modesRegistry","vs/editor/common/modes/supports","vs/editor/common/modes/languageSelector","vs/editor/common/core/range","child_process","net","vs/editor/common/services/modeService","os","vs/base/node/pfs","vs/platform/editor/common/editor","vs/platform/environment/common/environment","vs/platform/progress/common/progress","vs/editor/common/modes/supports/richEditBrackets","vs/platform/search/common/search","vs/base/node/event","vs/base/common/mime","vs/workbench/api/node/extHostDocumentData","vs/workbench/common/editor","vs/base/common/callbackList","vs/base/common/uuid","vs/workbench/api/node/extHostTextEditor","vs/workbench/services/thread/common/threadService","vs/base/common/marshalling","vs/nls!vs/workbench/api/node/extHostTask","vs/workbench/services/untitled/common/untitledEditorService","vs/editor/common/modes/tokenizationRegistry","vs/base/common/labels","vs/base/node/flow","vs/editor/common/modes/supports/electricCharacter","vs/editor/common/modes/languageConfigurationRegistry","vs/editor/common/viewModel/prefixSumComputer","vs/editor/common/model/mirrorModel","vs/nls!vs/base/common/processes","assert","vs/base/node/extfs","vs/base/common/processes","vs/nls!vs/base/common/severity","vs/base/common/scorer","vs/nls!vs/base/node/processes","vs/base/node/processes","vs/workbench/services/thread/node/extHostThreadService","vs/base/parts/ipc/node/ipc.cp","vs/nls!vs/editor/common/config/editorOptions","vs/editor/common/config/editorOptions","vs/nls!vs/editor/common/modes/modesRegistry","vs/nls!vs/workbench/api/node/extHostDiagnostics","vs/nls!vs/workbench/api/node/extHostExtensionActivator","vs/base/common/idGenerator","vs/nls!vs/workbench/api/node/extHostTreeViews","vs/nls!vs/workbench/node/extensionHostMain","vs/workbench/services/search/node/searchService","vs/base/common/color","vs/base/node/stdFork","vs/base/common/parsers","vs/platform/contextkey/common/contextkey","vs/base/common/marked/marked","vs/workbench/node/extensionHostMain","vs/platform/files/common/files","vs/platform/keybinding/common/keybinding","vs/platform/lifecycle/common/lifecycle","vs/platform/node/package","vs/platform/node/product","vs/base/parts/ipc/node/ipc.net","vs/platform/registry/common/platform","vs/editor/common/core/position","vs/base/common/events","vs/platform/statusbar/common/statusbar","vs/platform/telemetry/common/telemetryUtils","vs/editor/common/core/uint","vs/workbench/api/node/extHostExtensionActivator","vs/workbench/api/node/extHostHeapService","vs/base/common/network","vs/workbench/services/thread/node/abstractThreadService","vs/editor/common/model/textSource","vs/workbench/api/node/extHostFileSystemEventService","vs/workbench/api/node/extHostTreeViews","sql/workbench/api/node/sqlExtHostTypes","vs/workbench/common/editor/textEditorModel","vs/workbench/parts/tasks/common/tasks","vs/workbench/services/backup/common/backup","vs/workbench/services/configuration/common/configurationEditing","vs/workbench/api/node/extHostConfiguration","vs/workbench/services/extensions/node/barrier","vs/workbench/services/extensions/node/extensionDescriptionRegistry","vs/workbench/services/extensions/node/lazyPromise","vs/workbench/services/extensions/node/rpcProtocol","vs/workbench/services/search/node/searchIpc","vs/base/common/scrollable","vs/base/node/decoder","vs/workbench/api/node/extHostApiCommands","vs/workbench/api/node/extHostDocumentSaveParticipant","vs/workbench/api/node/extHostProgress","vs/editor/common/modes/languageFeatureRegistry","vs/workbench/common/editor/untitledEditorModel","vs/workbench/common/editor/untitledEditorInput","vs/editor/common/modes/supports/characterPair","vs/editor/common/modes/supports/indentRules","sql/workbench/api/node/extHostAccountManagement","sql/workbench/api/node/extHostCredentialManagement","sql/workbench/api/node/extHostDataProtocol","sql/workbench/api/node/extHostResourceProvider","sql/workbench/api/node/extHostSerializationProvider","vs/editor/common/modes/supports/onEnter","vs/workbench/api/node/extHostCommands","vs/workbench/api/node/extHostCredentials","vs/workbench/api/node/extHostDiagnostics","vs/workbench/api/node/extHostDialogs","vs/workbench/api/node/extHostDocumentContentProviders","vs/workbench/api/node/extHostDocuments","vs/workbench/api/node/extHostDocumentsAndEditors","vs/workbench/api/node/extHostLanguageFeatures","vs/workbench/api/node/extHostLanguages","vs/workbench/api/node/extHostMessageService","vs/workbench/api/node/extHostOutputService","vs/workbench/api/node/extHostQuickOpen","vs/workbench/api/node/extHostSCM","vs/workbench/api/node/extHostStatusBar","vs/workbench/api/node/extHostStorage","vs/workbench/api/node/extHostTask","vs/workbench/api/node/extHostTerminalService","vs/workbench/api/node/extHostTextEditors","vs/workbench/api/node/extHostWindow","vs/workbench/api/node/extHostWorkspace","vs/workbench/api/node/extHost.api.impl","sql/workbench/api/node/sqlExtHost.api.impl","vs/workbench/api/node/extHostExtensionService","crypto","stream","string_decoder","vs/base/common/winjs.base.raw","vs/base/common/marked/raw.marked","native-watchdog","vs/workbench/node/extensionHostProcess"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
define(__m[115/*sql/workbench/api/node/sqlExtHostTypes*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // SQL added extension host types
    var ServiceOptionType;
    (function (ServiceOptionType) {
        ServiceOptionType[ServiceOptionType["string"] = 0] = "string";
        ServiceOptionType[ServiceOptionType["multistring"] = 1] = "multistring";
        ServiceOptionType[ServiceOptionType["password"] = 2] = "password";
        ServiceOptionType[ServiceOptionType["number"] = 3] = "number";
        ServiceOptionType[ServiceOptionType["category"] = 4] = "category";
        ServiceOptionType[ServiceOptionType["boolean"] = 5] = "boolean";
        ServiceOptionType[ServiceOptionType["object"] = 6] = "object";
    })(ServiceOptionType = exports.ServiceOptionType || (exports.ServiceOptionType = {}));
    var ConnectionOptionSpecialType;
    (function (ConnectionOptionSpecialType) {
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["serverName"] = 0] = "serverName";
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["databaseName"] = 1] = "databaseName";
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["authType"] = 2] = "authType";
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["userName"] = 3] = "userName";
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["password"] = 4] = "password";
        ConnectionOptionSpecialType[ConnectionOptionSpecialType["appName"] = 5] = "appName";
    })(ConnectionOptionSpecialType = exports.ConnectionOptionSpecialType || (exports.ConnectionOptionSpecialType = {}));
    var MetadataType;
    (function (MetadataType) {
        MetadataType[MetadataType["Table"] = 0] = "Table";
        MetadataType[MetadataType["View"] = 1] = "View";
        MetadataType[MetadataType["SProc"] = 2] = "SProc";
        MetadataType[MetadataType["Function"] = 3] = "Function";
    })(MetadataType = exports.MetadataType || (exports.MetadataType = {}));
    var EditRowState;
    (function (EditRowState) {
        EditRowState[EditRowState["clean"] = 0] = "clean";
        EditRowState[EditRowState["dirtyInsert"] = 1] = "dirtyInsert";
        EditRowState[EditRowState["dirtyDelete"] = 2] = "dirtyDelete";
        EditRowState[EditRowState["dirtyUpdate"] = 3] = "dirtyUpdate";
    })(EditRowState = exports.EditRowState || (exports.EditRowState = {}));
    var TaskStatus;
    (function (TaskStatus) {
        TaskStatus[TaskStatus["notStarted"] = 0] = "notStarted";
        TaskStatus[TaskStatus["inProgress"] = 1] = "inProgress";
        TaskStatus[TaskStatus["succeeded"] = 2] = "succeeded";
        TaskStatus[TaskStatus["succeededWithWarning"] = 3] = "succeededWithWarning";
        TaskStatus[TaskStatus["failed"] = 4] = "failed";
        TaskStatus[TaskStatus["canceled"] = 5] = "canceled";
    })(TaskStatus = exports.TaskStatus || (exports.TaskStatus = {}));
    var TaskExecutionMode;
    (function (TaskExecutionMode) {
        TaskExecutionMode[TaskExecutionMode["execute"] = 0] = "execute";
        TaskExecutionMode[TaskExecutionMode["script"] = 1] = "script";
        TaskExecutionMode[TaskExecutionMode["executeAndScript"] = 2] = "executeAndScript";
    })(TaskExecutionMode = exports.TaskExecutionMode || (exports.TaskExecutionMode = {}));
    var ScriptOperation;
    (function (ScriptOperation) {
        ScriptOperation[ScriptOperation["Select"] = 0] = "Select";
        ScriptOperation[ScriptOperation["Create"] = 1] = "Create";
        ScriptOperation[ScriptOperation["Insert"] = 2] = "Insert";
        ScriptOperation[ScriptOperation["Update"] = 3] = "Update";
        ScriptOperation[ScriptOperation["Delete"] = 4] = "Delete";
    })(ScriptOperation = exports.ScriptOperation || (exports.ScriptOperation = {}));
});

define(__m[15/*vs/base/common/arrays*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default is zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirst(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirst = findFirst;
    /**
     * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
     * so only use this when actually needing stable sort.
     */
    function mergeSort(data, compare) {
        _divideAndMerge(data, compare);
        return data;
    }
    exports.mergeSort = mergeSort;
    function _divideAndMerge(data, compare) {
        if (data.length <= 1) {
            // sorted
            return;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        _divideAndMerge(left, compare);
        _divideAndMerge(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
    }
    function groupBy(data, compare) {
        var result = [];
        var currentGroup;
        for (var _i = 0, _a = data.slice(0).sort(compare); _i < _a.length; _i++) {
            var element = _a[_i];
            if (!currentGroup || compare(currentGroup[0], element) !== 0) {
                currentGroup = [element];
                result.push(currentGroup);
            }
            else {
                currentGroup.push(element);
            }
        }
        return result;
    }
    exports.groupBy = groupBy;
    /**
     * Takes two *sorted* arrays and computes their delta (removed, added elements).
     * Finishes in `Math.min(before.length, after.length)` steps.
     * @param before
     * @param after
     * @param compare
     */
    function delta(before, after, compare) {
        var removed = [];
        var added = [];
        var beforeIdx = 0;
        var afterIdx = 0;
        while (true) {
            if (beforeIdx === before.length) {
                added.push.apply(added, after.slice(afterIdx));
                break;
            }
            if (afterIdx === after.length) {
                removed.push.apply(removed, before.slice(beforeIdx));
                break;
            }
            var beforeElement = before[beforeIdx];
            var afterElement = after[afterIdx];
            var n = compare(beforeElement, afterElement);
            if (n === 0) {
                // equal
                beforeIdx += 1;
                afterIdx += 1;
            }
            else if (n < 0) {
                // beforeElement is smaller -> before element removed
                removed.push(beforeElement);
                beforeIdx += 1;
            }
            else if (n > 0) {
                // beforeElement is greater -> after element added
                added.push(afterElement);
                afterIdx += 1;
            }
        }
        return { removed: removed, added: added };
    }
    exports.delta = delta;
    /**
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @return The first n elemnts from array when sorted with compare.
     */
    function top(array, compare, n) {
        if (n === 0) {
            return [];
        }
        var result = array.slice(0, n).sort(compare);
        var _loop_1 = function (i, m) {
            var element = array[i];
            if (compare(element, result[n - 1]) < 0) {
                result.pop();
                var j = findFirst(result, function (e) { return compare(element, e) < 0; });
                result.splice(j, 0, element);
            }
        };
        for (var i = n, m = array.length; i < m; i++) {
            _loop_1(i, m);
        }
        return result;
    }
    exports.top = top;
    /**
     * @returns a new array with all undefined or null values removed. The original array is not modified at all.
     */
    function coalesce(array) {
        if (!array) {
            return array;
        }
        return array.filter(function (e) { return !!e; });
    }
    exports.coalesce = coalesce;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return arr.reduce(function (r, v) { return r.concat(v); }, []);
    }
    exports.flatten = flatten;
    function range(to, from) {
        if (from === void 0) { from = 0; }
        var result = [];
        for (var i = from; i < to; i++) {
            result.push(i);
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer, merger) {
        if (merger === void 0) { merger = function (t) { return t; }; }
        return array.reduce(function (r, t) {
            var key = indexer(t);
            r[key] = merger(t, r[key]);
            return r;
        }, Object.create(null));
    }
    exports.index = index;
    /**
     * Inserts an element into an array. Returns a function which, when
     * called, will remove that element from the array.
     */
    function insert(array, element) {
        array.push(element);
        return function () {
            var index = array.indexOf(element);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
    }
    exports.insert = insert;
    /**
     * Insert `insertArr` inside `target` at `insertIndex`.
     * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
     */
    function arrayInsert(target, insertIndex, insertArr) {
        var before = target.slice(0, insertIndex);
        var after = target.slice(insertIndex);
        return before.concat(insertArr, after);
    }
    exports.arrayInsert = arrayInsert;
});

define(__m[30/*vs/base/common/assert*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[90/*vs/base/common/color*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function roundFloat(number, decimalPoints) {
        var decimal = Math.pow(10, decimalPoints);
        return Math.round(number * decimal) / decimal;
    }
    var RGBA = (function () {
        function RGBA(r, g, b, a) {
            if (a === void 0) { a = 1; }
            this.r = Math.min(255, Math.max(0, r)) | 0;
            this.g = Math.min(255, Math.max(0, g)) | 0;
            this.b = Math.min(255, Math.max(0, b)) | 0;
            this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
        }
        RGBA.equals = function (a, b) {
            return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        };
        return RGBA;
    }());
    exports.RGBA = RGBA;
    var HSLA = (function () {
        function HSLA(h, s, l, a) {
            this.h = Math.max(Math.min(360, h), 0) | 0;
            this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
            this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
            this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
        }
        HSLA.equals = function (a, b) {
            return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;
        };
        /**
         * Converts an RGB color value to HSL. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
         * Assumes r, g, and b are contained in the set [0, 255] and
         * returns h in the set [0, 360], s, and l in the set [0, 1].
         */
        HSLA.fromRGBA = function (rgba) {
            var r = rgba.r / 255;
            var g = rgba.g / 255;
            var b = rgba.b / 255;
            var a = rgba.a;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var h = 0;
            var s = 0;
            var l = (min + max) / 2;
            var chroma = max - min;
            if (chroma > 0) {
                s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);
                switch (max) {
                    case r:
                        h = (g - b) / chroma + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / chroma + 2;
                        break;
                    case b:
                        h = (r - g) / chroma + 4;
                        break;
                }
                h *= 60;
                h = Math.round(h);
            }
            return new HSLA(h, s, l, a);
        };
        HSLA._hue2rgb = function (p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        /**
         * Converts an HSL color value to RGB. Conversion formula
         * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
         * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
         * returns r, g, and b in the set [0, 255].
         */
        HSLA.toRGBA = function (hsla) {
            var h = hsla.h / 360;
            var s = hsla.s, l = hsla.l, a = hsla.a;
            var r, g, b;
            if (s === 0) {
                r = g = b = l; // achromatic
            }
            else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = HSLA._hue2rgb(p, q, h + 1 / 3);
                g = HSLA._hue2rgb(p, q, h);
                b = HSLA._hue2rgb(p, q, h - 1 / 3);
            }
            return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);
        };
        return HSLA;
    }());
    exports.HSLA = HSLA;
    var HSVA = (function () {
        function HSVA(h, s, v, a) {
            this.h = Math.max(Math.min(360, h), 0) | 0;
            this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
            this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
            this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);
        }
        HSVA.equals = function (a, b) {
            return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;
        };
        // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
        HSVA.fromRGBA = function (rgba) {
            var r = rgba.r / 255;
            var g = rgba.g / 255;
            var b = rgba.b / 255;
            var cmax = Math.max(r, g, b);
            var cmin = Math.min(r, g, b);
            var delta = cmax - cmin;
            var s = cmax === 0 ? 0 : (delta / cmax);
            var m;
            if (delta === 0) {
                m = 0;
            }
            else if (cmax === r) {
                m = ((((g - b) / delta) % 6) + 6) % 6;
            }
            else if (cmax === g) {
                m = ((b - r) / delta) + 2;
            }
            else {
                m = ((r - g) / delta) + 4;
            }
            return new HSVA(m * 60, s, cmax, rgba.a);
        };
        // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
        HSVA.toRGBA = function (hsva) {
            var h = hsva.h, s = hsva.s, v = hsva.v, a = hsva.a;
            var c = v * s;
            var x = c * (1 - Math.abs((h / 60) % 2 - 1));
            var m = v - c;
            var _a = [0, 0, 0], r = _a[0], g = _a[1], b = _a[2];
            if (h < 60) {
                r = c;
                g = x;
            }
            else if (h < 120) {
                r = x;
                g = c;
            }
            else if (h < 180) {
                g = c;
                b = x;
            }
            else if (h < 240) {
                g = x;
                b = c;
            }
            else if (h < 300) {
                r = x;
                b = c;
            }
            else if (h < 360) {
                r = c;
                b = x;
            }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            return new RGBA(r, g, b, a);
        };
        return HSVA;
    }());
    exports.HSVA = HSVA;
    var Color = (function () {
        function Color(arg) {
            if (!arg) {
                throw new Error('Color needs a value');
            }
            else if (arg instanceof RGBA) {
                this.rgba = arg;
            }
            else if (arg instanceof HSLA) {
                this._hsla = arg;
                this.rgba = HSLA.toRGBA(arg);
            }
            else if (arg instanceof HSVA) {
                this._hsva = arg;
                this.rgba = HSVA.toRGBA(arg);
            }
            else {
                throw new Error('Invalid color ctor argument');
            }
        }
        Color.fromHex = function (hex) {
            return Color.Format.CSS.parseHex(hex) || Color.red;
        };
        Object.defineProperty(Color.prototype, "hsla", {
            get: function () {
                if (this._hsla) {
                    return this._hsla;
                }
                else {
                    return HSLA.fromRGBA(this.rgba);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "hsva", {
            get: function () {
                if (this._hsva) {
                    return this._hsva;
                }
                return HSVA.fromRGBA(this.rgba);
            },
            enumerable: true,
            configurable: true
        });
        Color.prototype.equals = function (other) {
            return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
        };
        /**
         * http://www.w3.org/TR/WCAG20/#relativeluminancedef
         * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
         */
        Color.prototype.getRelativeLuminance = function () {
            var R = Color._relativeLuminanceForComponent(this.rgba.r);
            var G = Color._relativeLuminanceForComponent(this.rgba.g);
            var B = Color._relativeLuminanceForComponent(this.rgba.b);
            var luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
            return roundFloat(luminance, 4);
        };
        Color._relativeLuminanceForComponent = function (color) {
            var c = color / 255;
            return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);
        };
        /**
         * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
         * Returns the contrast ration number in the set [1, 21].
         */
        Color.prototype.getContrastRatio = function (another) {
            var lum1 = this.getRelativeLuminance();
            var lum2 = another.getRelativeLuminance();
            return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
        };
        /**
         *	http://24ways.org/2010/calculating-color-contrast
         *  Return 'true' if darker color otherwise 'false'
         */
        Color.prototype.isDarker = function () {
            var yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
            return yiq < 128;
        };
        /**
         *	http://24ways.org/2010/calculating-color-contrast
         *  Return 'true' if lighter color otherwise 'false'
         */
        Color.prototype.isLighter = function () {
            var yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;
            return yiq >= 128;
        };
        Color.prototype.isLighterThan = function (another) {
            var lum1 = this.getRelativeLuminance();
            var lum2 = another.getRelativeLuminance();
            return lum1 > lum2;
        };
        Color.prototype.isDarkerThan = function (another) {
            var lum1 = this.getRelativeLuminance();
            var lum2 = another.getRelativeLuminance();
            return lum1 < lum2;
        };
        Color.prototype.lighten = function (factor) {
            return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
        };
        Color.prototype.darken = function (factor) {
            return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
        };
        Color.prototype.transparent = function (factor) {
            var _a = this.rgba, r = _a.r, g = _a.g, b = _a.b, a = _a.a;
            return new Color(new RGBA(r, g, b, a * factor));
        };
        Color.prototype.isTransparent = function () {
            return this.rgba.a === 0;
        };
        Color.prototype.isOpaque = function () {
            return this.rgba.a === 1;
        };
        Color.prototype.opposite = function () {
            return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
        };
        Color.prototype.blend = function (c) {
            var rgba = c.rgba;
            // Convert to 0..1 opacity
            var thisA = this.rgba.a;
            var colorA = rgba.a;
            var a = thisA + colorA * (1 - thisA);
            if (a < 1.0e-6) {
                return Color.transparent;
            }
            var r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;
            var g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;
            var b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;
            return new Color(new RGBA(r, g, b, a));
        };
        Color.prototype.toString = function () {
            return Color.Format.CSS.format(this);
        };
        Color.getLighterColor = function (of, relative, factor) {
            if (of.isLighterThan(relative)) {
                return of;
            }
            factor = factor ? factor : 0.5;
            var lum1 = of.getRelativeLuminance();
            var lum2 = relative.getRelativeLuminance();
            factor = factor * (lum2 - lum1) / lum2;
            return of.lighten(factor);
        };
        Color.getDarkerColor = function (of, relative, factor) {
            if (of.isDarkerThan(relative)) {
                return of;
            }
            factor = factor ? factor : 0.5;
            var lum1 = of.getRelativeLuminance();
            var lum2 = relative.getRelativeLuminance();
            factor = factor * (lum1 - lum2) / lum1;
            return of.darken(factor);
        };
        Color.white = new Color(new RGBA(255, 255, 255, 1));
        Color.black = new Color(new RGBA(0, 0, 0, 1));
        Color.red = new Color(new RGBA(255, 0, 0, 1));
        Color.blue = new Color(new RGBA(0, 0, 255, 1));
        Color.green = new Color(new RGBA(0, 255, 0, 1));
        Color.cyan = new Color(new RGBA(0, 255, 255, 1));
        Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
        Color.transparent = new Color(new RGBA(0, 0, 0, 0));
        return Color;
    }());
    exports.Color = Color;
    (function (Color) {
        var Format;
        (function (Format) {
            var CSS;
            (function (CSS) {
                function formatRGB(color) {
                    if (color.rgba.a === 1) {
                        return "rgb(" + color.rgba.r + ", " + color.rgba.g + ", " + color.rgba.b + ")";
                    }
                    return Color.Format.CSS.formatRGBA(color);
                }
                CSS.formatRGB = formatRGB;
                function formatRGBA(color) {
                    return "rgba(" + color.rgba.r + ", " + color.rgba.g + ", " + color.rgba.b + ", " + +(color.rgba.a).toFixed(2) + ")";
                }
                CSS.formatRGBA = formatRGBA;
                function formatHSL(color) {
                    if (color.hsla.a === 1) {
                        return "hsl(" + color.hsla.h + ", " + (color.hsla.s * 100).toFixed(2) + "%, " + (color.hsla.l * 100).toFixed(2) + "%)";
                    }
                    return Color.Format.CSS.formatHSLA(color);
                }
                CSS.formatHSL = formatHSL;
                function formatHSLA(color) {
                    return "hsla(" + color.hsla.h + ", " + (color.hsla.s * 100).toFixed(2) + "%, " + (color.hsla.l * 100).toFixed(2) + "%, " + color.hsla.a.toFixed(2) + ")";
                }
                CSS.formatHSLA = formatHSLA;
                function _toTwoDigitHex(n) {
                    var r = n.toString(16);
                    return r.length !== 2 ? '0' + r : r;
                }
                /**
                 * Formats the color as #RRGGBB
                 */
                function formatHex(color) {
                    return "#" + _toTwoDigitHex(color.rgba.r) + _toTwoDigitHex(color.rgba.g) + _toTwoDigitHex(color.rgba.b);
                }
                CSS.formatHex = formatHex;
                /**
                 * Formats the color as #RRGGBBAA
                 * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
                 */
                function formatHexA(color, compact) {
                    if (compact === void 0) { compact = false; }
                    if (compact && color.rgba.a === 1) {
                        return Color.Format.CSS.formatHex(color);
                    }
                    return "#" + _toTwoDigitHex(color.rgba.r) + _toTwoDigitHex(color.rgba.g) + _toTwoDigitHex(color.rgba.b) + _toTwoDigitHex(Math.round(color.rgba.a * 255));
                }
                CSS.formatHexA = formatHexA;
                /**
                 * The default format will use HEX if opaque and RGBA otherwise.
                 */
                function format(color) {
                    if (!color) {
                        return null;
                    }
                    if (color.isOpaque()) {
                        return Color.Format.CSS.formatHex(color);
                    }
                    return Color.Format.CSS.formatRGBA(color);
                }
                CSS.format = format;
                /**
                 * Converts an Hex color value to a Color.
                 * returns r, g, and b are contained in the set [0, 255]
                 * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).
                 */
                function parseHex(hex) {
                    if (!hex) {
                        // Invalid color
                        return null;
                    }
                    var length = hex.length;
                    if (length === 0) {
                        // Invalid color
                        return null;
                    }
                    if (hex.charCodeAt(0) !== 35 /* Hash */) {
                        // Does not begin with a #
                        return null;
                    }
                    if (length === 7) {
                        // #RRGGBB format
                        var r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                        var g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                        var b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                        return new Color(new RGBA(r, g, b, 1));
                    }
                    if (length === 9) {
                        // #RRGGBBAA format
                        var r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
                        var g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
                        var b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
                        var a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
                        return new Color(new RGBA(r, g, b, a / 255));
                    }
                    if (length === 4) {
                        // #RGB format
                        var r = _parseHexDigit(hex.charCodeAt(1));
                        var g = _parseHexDigit(hex.charCodeAt(2));
                        var b = _parseHexDigit(hex.charCodeAt(3));
                        return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
                    }
                    if (length === 5) {
                        // #RGBA format
                        var r = _parseHexDigit(hex.charCodeAt(1));
                        var g = _parseHexDigit(hex.charCodeAt(2));
                        var b = _parseHexDigit(hex.charCodeAt(3));
                        var a = _parseHexDigit(hex.charCodeAt(4));
                        return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));
                    }
                    // Invalid color
                    return null;
                }
                CSS.parseHex = parseHex;
                function _parseHexDigit(charCode) {
                    switch (charCode) {
                        case 48 /* Digit0 */: return 0;
                        case 49 /* Digit1 */: return 1;
                        case 50 /* Digit2 */: return 2;
                        case 51 /* Digit3 */: return 3;
                        case 52 /* Digit4 */: return 4;
                        case 53 /* Digit5 */: return 5;
                        case 54 /* Digit6 */: return 6;
                        case 55 /* Digit7 */: return 7;
                        case 56 /* Digit8 */: return 8;
                        case 57 /* Digit9 */: return 9;
                        case 97 /* a */: return 10;
                        case 65 /* A */: return 10;
                        case 98 /* b */: return 11;
                        case 66 /* B */: return 11;
                        case 99 /* c */: return 12;
                        case 67 /* C */: return 12;
                        case 100 /* d */: return 13;
                        case 68 /* D */: return 13;
                        case 101 /* e */: return 14;
                        case 69 /* E */: return 14;
                        case 102 /* f */: return 15;
                        case 70 /* F */: return 15;
                    }
                    return 0;
                }
            })(CSS = Format.CSS || (Format.CSS = {}));
        })(Format = Color.Format || (Color.Format = {}));
    })(Color = exports.Color || (exports.Color = {}));
    exports.Color = Color;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define(__m[104/*vs/base/common/events*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event = (function () {
        function Event(originalEvent) {
            this.time = (new Date()).getTime();
            this.originalEvent = originalEvent;
            this.source = null;
        }
        return Event;
    }());
    exports.Event = Event;
    var PropertyChangeEvent = (function (_super) {
        __extends(PropertyChangeEvent, _super);
        function PropertyChangeEvent(key, oldValue, newValue, originalEvent) {
            var _this = _super.call(this, originalEvent) || this;
            _this.key = key;
            _this.oldValue = oldValue;
            _this.newValue = newValue;
            return _this;
        }
        return PropertyChangeEvent;
    }(Event));
    exports.PropertyChangeEvent = PropertyChangeEvent;
    var ViewerEvent = (function (_super) {
        __extends(ViewerEvent, _super);
        function ViewerEvent(element, originalEvent) {
            var _this = _super.call(this, originalEvent) || this;
            _this.element = element;
            return _this;
        }
        return ViewerEvent;
    }(Event));
    exports.ViewerEvent = ViewerEvent;
    exports.EventType = {
        PROPERTY_CHANGED: 'propertyChanged',
        SELECTION: 'selection',
        FOCUS: 'focus',
        BLUR: 'blur',
        HIGHLIGHT: 'highlight',
        EXPAND: 'expand',
        COLLAPSE: 'collapse',
        TOGGLE: 'toggle',
        BEFORE_RUN: 'beforeRun',
        RUN: 'run',
        EDIT: 'edit',
        SAVE: 'save',
        CANCEL: 'cancel',
        CHANGE: 'change',
        DISPOSE: 'dispose',
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[33/*vs/base/common/functional*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function not(fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !fn.apply(void 0, args);
        };
    }
    exports.not = not;
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
});

define(__m[86/*vs/base/common/idGenerator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var IdGenerator = (function () {
        function IdGenerator(prefix) {
            this._prefix = prefix;
            this._lastId = 0;
        }
        IdGenerator.prototype.nextId = function () {
            return this._prefix + (++this._lastId);
        };
        return IdGenerator;
    }());
    exports.IdGenerator = IdGenerator;
    exports.defaultGenerator = new IdGenerator('id#');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[17/*vs/base/common/lifecycle*/], __M([1/*require*/,0/*exports*/,33/*vs/base/common/functional*/]), function (require, exports, functional_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.empty = Object.freeze({
        dispose: function () { }
    });
    function dispose(first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (Array.isArray(first)) {
            first.forEach(function (d) { return d && d.dispose(); });
            return [];
        }
        else if (rest.length === 0) {
            if (first) {
                first.dispose();
                return first;
            }
            return undefined;
        }
        else {
            dispose(first);
            dispose(rest);
            return [];
        }
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return {
            dispose: function () {
                for (var _i = 0, fns_1 = fns; _i < fns_1.length; _i++) {
                    var fn = fns_1[_i];
                    fn();
                }
            }
        };
    }
    exports.toDisposable = toDisposable;
    var Disposable = (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var OneDisposable = (function () {
        function OneDisposable() {
        }
        Object.defineProperty(OneDisposable.prototype, "value", {
            set: function (value) {
                if (this._value) {
                    this._value.dispose();
                }
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        OneDisposable.prototype.dispose = function () {
            this.value = null;
        };
        return OneDisposable;
    }());
    exports.OneDisposable = OneDisposable;
    var ReferenceCollection = (function () {
        function ReferenceCollection() {
            this.references = Object.create(null);
        }
        ReferenceCollection.prototype.acquire = function (key) {
            var _this = this;
            var reference = this.references[key];
            if (!reference) {
                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };
            }
            var object = reference.object;
            var dispose = functional_1.once(function () {
                if (--reference.counter === 0) {
                    _this.destroyReferencedObject(reference.object);
                    delete _this.references[key];
                }
            });
            reference.counter++;
            return { object: object, dispose: dispose };
        };
        return ReferenceCollection;
    }());
    exports.ReferenceCollection = ReferenceCollection;
    var ImmortalReference = (function () {
        function ImmortalReference(object) {
            this.object = object;
        }
        ImmortalReference.prototype.dispose = function () { };
        return ImmortalReference;
    }());
    exports.ImmortalReference = ImmortalReference;
});

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (Source EULAd)
 * https://github.com/chjj/marked
 */

// TODO MonacoChange: we have our own way of defining modules
// ;(function() {
// END MonacoChange

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
	// explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

// TODO MonacoChange: we have our own way of defining modules
define("vs/base/common/marked/raw.marked", [], function() {
  return marked;
});
//if (typeof module !== 'undefined' && typeof exports === 'object') {
//  module.exports = marked;
//} else if (typeof define === 'function' && define.amd) {
//  define(function() { return marked; });
//} else {
//  this.marked = marked;
//}
//
//}).call(function() {
//  return this || (typeof window !== 'undefined' ? window : global);
//}());
// END MonacoChange
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define(__m[94/*vs/base/common/marked/marked*/], __M([169/*vs/base/common/marked/raw.marked*/]), function (marked) {
	return {
		marked: marked
	};
});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[27/*vs/base/common/htmlContent*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/arrays*/,94/*vs/base/common/marked/marked*/]), function (require, exports, arrays_1, marked_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MarkdownString = (function () {
        function MarkdownString(value) {
            if (value === void 0) { value = ''; }
            this.value = value;
        }
        MarkdownString.prototype.appendText = function (value) {
            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
            this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
            return this;
        };
        MarkdownString.prototype.appendMarkdown = function (value) {
            this.value += value;
            return this;
        };
        MarkdownString.prototype.appendCodeblock = function (langId, code) {
            this.value += '\n```';
            this.value += langId;
            this.value += '\n';
            this.value += code;
            this.value += '\n```\n';
            return this;
        };
        return MarkdownString;
    }());
    exports.MarkdownString = MarkdownString;
    function isEmptyMarkdownString(oneOrMany) {
        if (isMarkdownString(oneOrMany)) {
            return !oneOrMany.value;
        }
        else if (Array.isArray(oneOrMany)) {
            return oneOrMany.every(isEmptyMarkdownString);
        }
        else {
            return true;
        }
    }
    exports.isEmptyMarkdownString = isEmptyMarkdownString;
    function isMarkdownString(thing) {
        if (thing instanceof MarkdownString) {
            return true;
        }
        else if (typeof thing === 'object') {
            return typeof thing.value === 'string'
                && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === void 0);
        }
        return false;
    }
    exports.isMarkdownString = isMarkdownString;
    function markedStringsEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else if (Array.isArray(a) && Array.isArray(b)) {
            return arrays_1.equals(a, b, markdownStringEqual);
        }
        else if (isMarkdownString(a) && isMarkdownString(b)) {
            return markdownStringEqual(a, b);
        }
        else {
            return false;
        }
    }
    exports.markedStringsEquals = markedStringsEquals;
    function markdownStringEqual(a, b) {
        if (a === b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else {
            return a.value === b.value && a.isTrusted === b.isTrusted;
        }
    }
    function removeMarkdownEscapes(text) {
        if (!text) {
            return text;
        }
        return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
    }
    exports.removeMarkdownEscapes = removeMarkdownEscapes;
    function containsCommandLink(value) {
        var uses = false;
        var renderer = new marked_1.marked.Renderer();
        renderer.link = function (href, title, text) {
            if (href.match(/^command:/i)) {
                uses = true;
            }
            return 'link';
        };
        marked_1.marked(value, { renderer: renderer });
        return uses;
    }
    exports.containsCommandLink = containsCommandLink;
});

define(__m[110/*vs/base/common/network*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        /**
         * A walk-through document.
         */
        Schemas.walkThrough = 'walkThrough';
        /**
         * An embedded code snippet.
         */
        Schemas.walkThroughSnippet = 'walkThroughSnippet';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
        Schemas.untitled = 'untitled';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
});

define(__m[9/*vs/base/common/platform*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isRootUser = false;
    var _isNative = false;
    var _isWeb = false;
    var _locale = undefined;
    var _language = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    // OS detection
    if (typeof process === 'object') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _isRootUser = !_isWindows && (process.getuid() === 0);
        var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
        if (rawNlsConfig) {
            try {
                var nlsConfig = JSON.parse(rawNlsConfig);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
    }
    var Platform;
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(Platform = exports.Platform || (exports.Platform = {}));
    var _platform = Platform.Web;
    if (_isNative) {
        if (_isMacintosh) {
            _platform = Platform.Mac;
        }
        else if (_isWindows) {
            _platform = Platform.Windows;
        }
        else if (_isLinux) {
            _platform = Platform.Linux;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isRootUser = _isRootUser;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.platform = _platform;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    var _globals = (typeof self === 'object' ? self : global);
    exports.globals = _globals;
    function hasWebWorkerSupport() {
        return typeof _globals.Worker !== 'undefined';
    }
    exports.hasWebWorkerSupport = hasWebWorkerSupport;
    exports.setTimeout = _globals.setTimeout.bind(_globals);
    exports.clearTimeout = _globals.clearTimeout.bind(_globals);
    exports.setInterval = _globals.setInterval.bind(_globals);
    exports.clearInterval = _globals.clearInterval.bind(_globals);
    var OperatingSystem;
    (function (OperatingSystem) {
        OperatingSystem[OperatingSystem["Windows"] = 1] = "Windows";
        OperatingSystem[OperatingSystem["Macintosh"] = 2] = "Macintosh";
        OperatingSystem[OperatingSystem["Linux"] = 3] = "Linux";
    })(OperatingSystem = exports.OperatingSystem || (exports.OperatingSystem = {}));
    exports.OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
    var AccessibilitySupport;
    (function (AccessibilitySupport) {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
        AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
        AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
    })(AccessibilitySupport = exports.AccessibilitySupport || (exports.AccessibilitySupport = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[76/*vs/base/common/scorer*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Based on material from:
    /*!
    BEGIN THIRD PARTY
    */
    /*!
    * string_score.js: String Scoring Algorithm 0.1.22
    *
    * http://joshaven.com/string_score
    * https://github.com/joshaven/string_score
    *
    * Copyright (C) 2009-2014 Joshaven Potter <yourtech@gmail.com>
    * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
    * Source EULA: http://opensource.org/licenses/MIT
    *
    * Date: Tue Mar 1 2011
    * Updated: Tue Mar 10 2015
    */
    /**
     * Compute a score for the given string and the given query.
     *
     * Rules:
     * Character score: 1
     * Same case bonus: 1
     * Upper case bonus: 1
     * Consecutive match bonus: 5
     * Start of word/path bonus: 7
     * Start of string bonus: 8
     */
    var wordPathBoundary = ['-', '_', ' ', '/', '\\', '.'];
    function score(target, query, cache) {
        if (!target || !query) {
            return 0; // return early if target or query are undefined
        }
        var hash = target + query;
        var cached = cache && cache[hash];
        if (typeof cached === 'number') {
            return cached;
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var queryLower = query.toLowerCase();
        var index = 0;
        var startAt = 0;
        var score = 0;
        var _loop_1 = function () {
            var indexOf = targetLower.indexOf(queryLower[index], startAt);
            if (indexOf < 0) {
                score = 0; // This makes sure that the query is contained in the target
                return "break";
            }
            // Character match bonus
            score += 1;
            // Consecutive match bonus
            if (startAt === indexOf) {
                score += 5;
            }
            // Same case bonus
            if (target[indexOf] === query[indexOf]) {
                score += 1;
            }
            // Start of word bonus
            if (indexOf === 0) {
                score += 8;
            }
            else if (wordPathBoundary.some(function (w) { return w === target[indexOf - 1]; })) {
                score += 7;
            }
            else if (isUpper(target.charCodeAt(indexOf))) {
                score += 1;
            }
            startAt = indexOf + 1;
            index++;
        };
        while (index < queryLen) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        if (cache) {
            cache[hash] = score;
        }
        return score;
    }
    exports.score = score;
    function isUpper(code) {
        return 65 <= code && code <= 90;
    }
    /**
     * A fast method to check if a given string would produce a score > 0 for the given query.
     */
    function matches(target, queryLower) {
        if (!target || !queryLower) {
            return false; // return early if target or query are undefined
        }
        var queryLen = queryLower.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(queryLower[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.matches = matches;
});
/*!
END THIRD PARTY
*/ 

define(__m[14/*vs/base/common/types*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        // The method can't do a type cast since there are type (like strings) which
        // are subclasses of any put not positvely matched by the function. Hence type
        // narrowing results in wrong results.
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (arg && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[11/*vs/base/common/objects*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/]), function (require, exports, types_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function clone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            // See https://github.com/Microsoft/TypeScript/issues/10990
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = clone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.clone = clone;
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (types_1.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (types_1.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (types_1.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!types_1.isObject(destination)) {
            return source;
        }
        if (types_1.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function toObject(arr, keyMap) {
        return arr.reduce(function (o, d) {
            return assign(o, (_a = {}, _a[keyMap(d)] = d, _a));
            var _a;
        }, Object.create(null));
    }
    exports.toObject = toObject;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i;
        var key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function ensureProperty(obj, property, defaultValue) {
        if (typeof obj[property] === 'undefined') {
            obj[property] = defaultValue;
        }
    }
    exports.ensureProperty = ensureProperty;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Started from TypeScript's __extends function to make a type a subclass of a specific class.
     * Modified to work with properties already defined on the derivedClass, since we can't get TS
     * to call this method before the constructor definition.
     */
    function derive(baseClass, derivedClass) {
        for (var prop in baseClass) {
            if (baseClass.hasOwnProperty(prop)) {
                derivedClass[prop] = baseClass[prop];
            }
        }
        derivedClass = derivedClass || function () { };
        var basePrototype = baseClass.prototype;
        var derivedPrototype = derivedClass.prototype;
        derivedClass.prototype = Object.create(basePrototype);
        for (var prop in derivedPrototype) {
            if (derivedPrototype.hasOwnProperty(prop)) {
                // handle getters and setters properly
                Object.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));
            }
        }
        // Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.
        Object.defineProperty(derivedClass.prototype, 'constructor', { value: derivedClass, writable: true, configurable: true, enumerable: true });
    }
    exports.derive = derive;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
    function distinct(base, target) {
        var result = Object.create(null);
        if (!base || !target) {
            return result;
        }
        var targetKeys = Object.keys(target);
        targetKeys.forEach(function (k) {
            var baseValue = base[k];
            var targetValue = target[k];
            if (!equals(baseValue, targetValue)) {
                result[k] = targetValue;
            }
        });
        return result;
    }
    exports.distinct = distinct;
});

define(__m[92/*vs/base/common/parsers*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/]), function (require, exports, Types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationState;
    (function (ValidationState) {
        ValidationState[ValidationState["OK"] = 0] = "OK";
        ValidationState[ValidationState["Info"] = 1] = "Info";
        ValidationState[ValidationState["Warning"] = 2] = "Warning";
        ValidationState[ValidationState["Error"] = 3] = "Error";
        ValidationState[ValidationState["Fatal"] = 4] = "Fatal";
    })(ValidationState = exports.ValidationState || (exports.ValidationState = {}));
    var ValidationStatus = (function () {
        function ValidationStatus() {
            this._state = ValidationState.OK;
        }
        Object.defineProperty(ValidationStatus.prototype, "state", {
            get: function () {
                return this._state;
            },
            set: function (value) {
                if (value > this._state) {
                    this._state = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ValidationStatus.prototype.isOK = function () {
            return this._state === ValidationState.OK;
        };
        ValidationStatus.prototype.isFatal = function () {
            return this._state === ValidationState.Fatal;
        };
        return ValidationStatus;
    }());
    exports.ValidationStatus = ValidationStatus;
    var NullProblemReporter = (function () {
        function NullProblemReporter() {
            this.status = new ValidationStatus();
        }
        NullProblemReporter.prototype.info = function (message) { };
        ;
        NullProblemReporter.prototype.warn = function (message) { };
        ;
        NullProblemReporter.prototype.error = function (message) { };
        ;
        NullProblemReporter.prototype.fatal = function (message) { };
        ;
        return NullProblemReporter;
    }());
    exports.NullProblemReporter = NullProblemReporter;
    var Parser = (function () {
        function Parser(problemReporter) {
            this._problemReporter = problemReporter;
        }
        Parser.prototype.reset = function () {
            this._problemReporter.status.state = ValidationState.OK;
        };
        Object.defineProperty(Parser.prototype, "problemReporter", {
            get: function () {
                return this._problemReporter;
            },
            enumerable: true,
            configurable: true
        });
        Parser.prototype.info = function (message) {
            this._problemReporter.info(message);
        };
        Parser.prototype.warn = function (message) {
            this._problemReporter.warn(message);
        };
        Parser.prototype.error = function (message) {
            this._problemReporter.error(message);
        };
        Parser.prototype.fatal = function (message) {
            this._problemReporter.fatal(message);
        };
        Parser.prototype.is = function (value, func, wrongTypeState, wrongTypeMessage, undefinedState, undefinedMessage) {
            if (Types.isUndefined(value)) {
                if (undefinedState) {
                    this._problemReporter.status.state = undefinedState;
                }
                if (undefinedMessage) {
                    this._problemReporter.info(undefinedMessage);
                }
                return false;
            }
            if (!func(value)) {
                if (wrongTypeState) {
                    this._problemReporter.status.state = wrongTypeState;
                }
                if (wrongTypeMessage) {
                    this.info(wrongTypeMessage);
                }
                return false;
            }
            return true;
        };
        Parser.merge = function (destination, source, overwrite) {
            var _this = this;
            Object.keys(source).forEach(function (key) {
                var destValue = destination[key];
                var sourceValue = source[key];
                if (Types.isUndefined(sourceValue)) {
                    return;
                }
                if (Types.isUndefined(destValue)) {
                    destination[key] = sourceValue;
                }
                else {
                    if (overwrite) {
                        if (Types.isObject(destValue) && Types.isObject(sourceValue)) {
                            _this.merge(destValue, sourceValue, overwrite);
                        }
                        else {
                            destination[key] = sourceValue;
                        }
                    }
                }
            });
        };
        return Parser;
    }());
    exports.Parser = Parser;
    var AbstractSystemVariables = (function () {
        function AbstractSystemVariables() {
        }
        AbstractSystemVariables.prototype.resolve = function (value) {
            if (Types.isString(value)) {
                return this.resolveString(value);
            }
            else if (Types.isArray(value)) {
                return this.__resolveArray(value);
            }
            else if (Types.isObject(value)) {
                return this.__resolveLiteral(value);
            }
            return value;
        };
        AbstractSystemVariables.prototype.resolveAny = function (value) {
            if (Types.isString(value)) {
                return this.resolveString(value);
            }
            else if (Types.isArray(value)) {
                return this.__resolveAnyArray(value);
            }
            else if (Types.isObject(value)) {
                return this.__resolveAnyLiteral(value);
            }
            return value;
        };
        AbstractSystemVariables.prototype.resolveString = function (value) {
            var _this = this;
            var regexp = /\$\{(.*?)\}/g;
            return value.replace(regexp, function (match, name) {
                var newValue = _this[name];
                if (Types.isString(newValue)) {
                    return newValue;
                }
                else {
                    return match && match.indexOf('env.') > 0 ? '' : match;
                }
            });
        };
        AbstractSystemVariables.prototype.__resolveLiteral = function (values) {
            var _this = this;
            var result = Object.create(null);
            Object.keys(values).forEach(function (key) {
                var value = values[key];
                result[key] = _this.resolve(value);
            });
            return result;
        };
        AbstractSystemVariables.prototype.__resolveAnyLiteral = function (values) {
            var _this = this;
            var result = Object.create(null);
            Object.keys(values).forEach(function (key) {
                var value = values[key];
                result[key] = _this.resolveAny(value);
            });
            return result;
        };
        AbstractSystemVariables.prototype.__resolveArray = function (value) {
            var _this = this;
            return value.map(function (s) { return _this.resolveString(s); });
        };
        AbstractSystemVariables.prototype.__resolveAnyArray = function (value) {
            var _this = this;
            return value.map(function (s) { return _this.resolveAny(s); });
        };
        return AbstractSystemVariables;
    }());
    exports.AbstractSystemVariables = AbstractSystemVariables;
});

define(__m[6/*vs/base/common/uri*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/platform*/]), function (require, exports, platform) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function _encode(ch) {
        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    }
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
    function encodeURIComponent2(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);
    }
    function encodeNoop(str) {
        return str.replace(/[#?]/, _encode);
    }
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component paths
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     *
     *
     */
    var URI = (function () {
        /**
         * @internal
         */
        function URI(scheme, authority, path, query, fragment) {
            this._formatted = null;
            this._fsPath = null;
            this.scheme = scheme || URI._empty;
            this.authority = authority || URI._empty;
            this.path = path || URI._empty;
            this.query = query || URI._empty;
            this.fragment = fragment || URI._empty;
            this._validate(this);
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string';
        };
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths and normalize windows drive letters to lower-case. Also
             * uses the platform specific path separator. Will *not* validate the path for
             * invalid characters and semantics. Will *not* look at the scheme of this URI.
             */
            get: function () {
                if (!this._fsPath) {
                    var value = void 0;
                    if (this.authority && this.path && this.scheme === 'file') {
                        // unc path: file://shares/c$/far/boo
                        value = "//" + this.authority + this.path;
                    }
                    else if (URI._driveLetterPath.test(this.path)) {
                        // windows drive letter: file:///c:/far/boo
                        value = this.path[1].toLowerCase() + this.path.substr(2);
                    }
                    else {
                        // other path
                        value = this.path;
                    }
                    if (platform.isWindows) {
                        value = value.replace(/\//g, '\\');
                    }
                    this._fsPath = value;
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === void 0) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = '';
            }
            if (authority === void 0) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = '';
            }
            if (path === void 0) {
                path = this.path;
            }
            else if (path === null) {
                path = '';
            }
            if (query === void 0) {
                query = this.query;
            }
            else if (query === null) {
                query = '';
            }
            if (fragment === void 0) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = '';
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            return new URI(scheme, authority, path, query, fragment);
        };
        // ---- parse & validate ------------------------
        URI.parse = function (value) {
            var match = URI._regexp.exec(value);
            if (!match) {
                return new URI(URI._empty, URI._empty, URI._empty, URI._empty, URI._empty);
            }
            return new URI(match[2] || URI._empty, decodeURIComponent(match[4] || URI._empty), decodeURIComponent(match[5] || URI._empty), decodeURIComponent(match[7] || URI._empty), decodeURIComponent(match[9] || URI._empty));
        };
        URI.file = function (path) {
            var authority = URI._empty;
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            if (platform.isWindows) {
                path = path.replace(/\\/g, URI._slash);
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === URI._slash && path[0] === path[1]) {
                var idx = path.indexOf(URI._slash, 2);
                if (idx === -1) {
                    authority = path.substring(2);
                    path = URI._empty;
                }
                else {
                    authority = path.substring(2, idx);
                    path = path.substring(idx);
                }
            }
            // Ensure that path starts with a slash
            // or that it is at least a slash
            if (path[0] !== URI._slash) {
                path = URI._slash + path;
            }
            return new URI('file', authority, path, URI._empty, URI._empty);
        };
        URI.from = function (components) {
            return new URI(components.scheme, components.authority, components.path, components.query, components.fragment);
        };
        URI.prototype._validate = function (ret) {
            // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
            // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
            if (ret.scheme && !URI._schemePattern.test(ret.scheme)) {
                throw new Error('[UriError]: Scheme contains illegal characters.');
            }
            // path, http://tools.ietf.org/html/rfc3986#section-3.3
            // If a URI contains an authority component, then the path component
            // must either be empty or begin with a slash ("/") character.  If a URI
            // does not contain an authority component, then the path cannot begin
            // with two slash characters ("//").
            if (ret.path) {
                if (ret.authority) {
                    if (!URI._singleSlashStart.test(ret.path)) {
                        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                    }
                }
                else {
                    if (URI._doubleSlashStart.test(ret.path)) {
                        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                    }
                }
            }
        };
        // ---- printing/externalize ---------------------------
        /**
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = URI._asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return URI._asFormatted(this, true);
            }
        };
        URI._asFormatted = function (uri, skipEncoding) {
            var encoder = !skipEncoding
                ? encodeURIComponent2
                : encodeNoop;
            var parts = [];
            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
            if (scheme) {
                parts.push(scheme, ':');
            }
            if (authority || scheme === 'file') {
                parts.push('//');
            }
            if (authority) {
                authority = authority.toLowerCase();
                var idx = authority.indexOf(':');
                if (idx === -1) {
                    parts.push(encoder(authority));
                }
                else {
                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));
                }
            }
            if (path) {
                // lower-case windows drive letters in /C:/fff or C:/fff
                var m = URI._upperCaseDrive.exec(path);
                if (m) {
                    if (m[1]) {
                        path = '/' + m[2].toLowerCase() + path.substr(3); // "/c:".length === 3
                    }
                    else {
                        path = m[2].toLowerCase() + path.substr(2); // // "c:".length === 2
                    }
                }
                // encode every segement but not slashes
                // make sure that # and ? are always encoded
                // when occurring in paths - otherwise the result
                // cannot be parsed back again
                var lastIdx = 0;
                while (true) {
                    var idx = path.indexOf(URI._slash, lastIdx);
                    if (idx === -1) {
                        parts.push(encoder(path.substring(lastIdx)));
                        break;
                    }
                    parts.push(encoder(path.substring(lastIdx, idx)), URI._slash);
                    lastIdx = idx + 1;
                }
                ;
            }
            if (query) {
                parts.push('?', encoder(query));
            }
            if (fragment) {
                parts.push('#', encoder(fragment));
            }
            return parts.join(URI._empty);
        };
        URI.prototype.toJSON = function () {
            var res = {
                fsPath: this.fsPath,
                external: this.toString(),
                $mid: 1
            };
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        URI.revive = function (data) {
            var result = new URI(data.scheme, data.authority, data.path, data.query, data.fragment);
            result._fsPath = data.fsPath;
            result._formatted = data.external;
            return result;
        };
        URI._empty = '';
        URI._slash = '/';
        URI._regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        URI._driveLetterPath = /^\/[a-zA-Z]:/;
        URI._upperCaseDrive = /^(\/)?([A-Z]:)/;
        URI._schemePattern = /^\w[\w\d+.-]*$/;
        URI._singleSlashStart = /^\//;
        URI._doubleSlashStart = /^\/\//;
        return URI;
    }());
    exports.default = URI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[21/*vs/base/common/map*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function values(map) {
        var result = [];
        map.forEach(function (value) { return result.push(value); });
        return result;
    }
    exports.values = values;
    function keys(map) {
        var result = [];
        map.forEach(function (value, key) { return result.push(key); });
        return result;
    }
    exports.keys = keys;
    function getOrSet(map, key, value) {
        var result = map.get(key);
        if (result === void 0) {
            result = value;
            map.set(key, result);
        }
        return result;
    }
    exports.getOrSet = getOrSet;
    /**
     * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,
     * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,
     * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).
     */
    var BoundedMap = (function () {
        function BoundedMap(limit, ratio, value) {
            if (limit === void 0) { limit = Number.MAX_VALUE; }
            if (ratio === void 0) { ratio = 1; }
            var _this = this;
            this.limit = limit;
            this.map = new Map();
            this.ratio = limit * ratio;
            if (value) {
                value.entries.forEach(function (entry) {
                    _this.set(entry.key, entry.value);
                });
            }
        }
        BoundedMap.prototype.setLimit = function (limit) {
            if (limit < 0) {
                return; // invalid limit
            }
            this.limit = limit;
            while (this.map.size > this.limit) {
                this.trim();
            }
        };
        BoundedMap.prototype.serialize = function () {
            var serialized = { entries: [] };
            this.map.forEach(function (entry) {
                serialized.entries.push({ key: entry.key, value: entry.value });
            });
            return serialized;
        };
        Object.defineProperty(BoundedMap.prototype, "size", {
            get: function () {
                return this.map.size;
            },
            enumerable: true,
            configurable: true
        });
        BoundedMap.prototype.set = function (key, value) {
            if (this.map.has(key)) {
                return false; // already present!
            }
            var entry = { key: key, value: value };
            this.push(entry);
            if (this.size > this.limit) {
                this.trim();
            }
            return true;
        };
        BoundedMap.prototype.get = function (key) {
            var entry = this.map.get(key);
            return entry ? entry.value : null;
        };
        BoundedMap.prototype.getOrSet = function (k, t) {
            var res = this.get(k);
            if (res) {
                return res;
            }
            this.set(k, t);
            return t;
        };
        BoundedMap.prototype.delete = function (key) {
            var entry = this.map.get(key);
            if (entry) {
                this.map.delete(key);
                if (entry.next) {
                    entry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]
                }
                else {
                    this.head = entry.prev; // [A]-[x] = [A]
                }
                if (entry.prev) {
                    entry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]
                }
                else {
                    this.tail = entry.next; // [x]-[A] = [A]
                }
                return entry.value;
            }
            return null;
        };
        BoundedMap.prototype.has = function (key) {
            return this.map.has(key);
        };
        BoundedMap.prototype.clear = function () {
            this.map.clear();
            this.head = null;
            this.tail = null;
        };
        BoundedMap.prototype.push = function (entry) {
            if (this.head) {
                // [A]-[B] = [A]-[B]->[X]
                entry.prev = this.head;
                this.head.next = entry;
            }
            if (!this.tail) {
                this.tail = entry;
            }
            this.head = entry;
            this.map.set(entry.key, entry);
        };
        BoundedMap.prototype.trim = function () {
            if (this.tail) {
                // Remove all elements until ratio is reached
                if (this.ratio < this.limit) {
                    var index = 0;
                    var current = this.tail;
                    while (current.next) {
                        // Remove the entry
                        this.map.delete(current.key);
                        // if we reached the element that overflows our ratio condition
                        // make its next element the new tail of the Map and adjust the size
                        if (index === this.ratio) {
                            this.tail = current.next;
                            this.tail.prev = null;
                            break;
                        }
                        // Move on
                        current = current.next;
                        index++;
                    }
                }
                else {
                    this.map.delete(this.tail.key);
                    // [x]-[B] = [B]
                    this.tail = this.tail.next;
                    if (this.tail) {
                        this.tail.prev = null;
                    }
                }
            }
        };
        return BoundedMap;
    }());
    exports.BoundedMap = BoundedMap;
    // --- trie'ish datastructure
    var Node = (function () {
        function Node() {
            this.children = new Map();
        }
        return Node;
    }());
    /**
     * A trie map that allows for fast look up when keys are substrings
     * to the actual search keys (dir/subdir-problem).
     */
    var TrieMap = (function () {
        function TrieMap(splitter) {
            if (splitter === void 0) { splitter = TrieMap.PathSplitter; }
            this._root = new Node();
            this._splitter = function (s) { return splitter(s).filter(function (s) { return Boolean(s); }); };
        }
        TrieMap.prototype.insert = function (path, element) {
            var parts = this._splitter(path);
            var i = 0;
            // find insertion node
            var node = this._root;
            for (; i < parts.length; i++) {
                var child = node.children.get(parts[i]);
                if (child) {
                    node = child;
                    continue;
                }
                break;
            }
            // create new nodes
            var newNode;
            for (; i < parts.length; i++) {
                newNode = new Node();
                node.children.set(parts[i], newNode);
                node = newNode;
            }
            node.element = element;
        };
        TrieMap.prototype.lookUp = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                node = children.get(part);
                if (!node) {
                    return undefined;
                }
                children = node.children;
            }
            return node.element;
        };
        TrieMap.prototype.findSubstr = function (path) {
            var parts = this._splitter(path);
            var lastNode;
            var children = this._root.children;
            for (var _i = 0, parts_2 = parts; _i < parts_2.length; _i++) {
                var part = parts_2[_i];
                var node = children.get(part);
                if (!node) {
                    break;
                }
                if (node.element) {
                    lastNode = node;
                }
                children = node.children;
            }
            // return the last matching node
            // that had an element
            if (lastNode) {
                return lastNode.element;
            }
            return undefined;
        };
        TrieMap.prototype.findSuperstr = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_3 = parts; _i < parts_3.length; _i++) {
                var part = parts_3[_i];
                node = children.get(part);
                if (!node) {
                    return undefined;
                }
                children = node.children;
            }
            var result = new TrieMap(this._splitter);
            result._root = node;
            return result;
        };
        TrieMap.PathSplitter = function (s) { return s.split(/[\\/]/).filter(function (s) { return !!s; }); };
        return TrieMap;
    }());
    exports.TrieMap = TrieMap;
    var ResourceMap = (function () {
        function ResourceMap(ignoreCase) {
            this.ignoreCase = ignoreCase;
            this.map = new Map();
        }
        ResourceMap.prototype.set = function (resource, value) {
            this.map.set(this.toKey(resource), value);
        };
        ResourceMap.prototype.get = function (resource) {
            return this.map.get(this.toKey(resource));
        };
        ResourceMap.prototype.has = function (resource) {
            return this.map.has(this.toKey(resource));
        };
        Object.defineProperty(ResourceMap.prototype, "size", {
            get: function () {
                return this.map.size;
            },
            enumerable: true,
            configurable: true
        });
        ResourceMap.prototype.clear = function () {
            this.map.clear();
        };
        ResourceMap.prototype.delete = function (resource) {
            return this.map.delete(this.toKey(resource));
        };
        ResourceMap.prototype.forEach = function (clb) {
            this.map.forEach(clb);
        };
        ResourceMap.prototype.values = function () {
            return values(this.map);
        };
        ResourceMap.prototype.toKey = function (resource) {
            var key = resource.toString();
            if (this.ignoreCase) {
                key = key.toLowerCase();
            }
            return key;
        };
        return ResourceMap;
    }());
    exports.ResourceMap = ResourceMap;
    var StrictResourceMap = (function (_super) {
        __extends(StrictResourceMap, _super);
        function StrictResourceMap() {
            return _super.call(this) || this;
        }
        StrictResourceMap.prototype.keys = function () {
            return keys(this.map).map(function (key) { return uri_1.default.parse(key); });
        };
        return StrictResourceMap;
    }(ResourceMap));
    exports.StrictResourceMap = StrictResourceMap;
    var Touch;
    (function (Touch) {
        Touch.None = 0;
        Touch.First = 1;
        Touch.Last = 2;
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = (function () {
        function LinkedMap() {
            this._map = new Map();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        }
        LinkedMap.prototype.clear = function () {
            this._map.clear();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        };
        LinkedMap.prototype.isEmpty = function () {
            return !this._head && !this._tail;
        };
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.has = function (key) {
            return this._map.has(key);
        };
        LinkedMap.prototype.get = function (key) {
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            return item.value;
        };
        LinkedMap.prototype.set = function (key, value, touch) {
            if (touch === void 0) { touch = Touch.None; }
            var item = this._map.get(key);
            if (item) {
                item.value = value;
                if (touch !== Touch.None) {
                    this.touch(item, touch);
                }
            }
            else {
                item = { key: key, value: value, next: undefined, previous: undefined };
                switch (touch) {
                    case Touch.None:
                        this.addItemLast(item);
                        break;
                    case Touch.First:
                        this.addItemFirst(item);
                        break;
                    case Touch.Last:
                        this.addItemLast(item);
                        break;
                    default:
                        this.addItemLast(item);
                        break;
                }
                this._map.set(key, item);
                this._size++;
            }
        };
        LinkedMap.prototype.delete = function (key) {
            return !!this.remove(key);
        };
        LinkedMap.prototype.remove = function (key) {
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            this._map.delete(key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.shift = function () {
            if (!this._head && !this._tail) {
                return undefined;
            }
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            var item = this._head;
            this._map.delete(item.key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.forEach = function (callbackfn, thisArg) {
            var current = this._head;
            while (current) {
                if (thisArg) {
                    callbackfn.bind(thisArg)(current.value, current.key, this);
                }
                else {
                    callbackfn(current.value, current.key, this);
                }
                current = current.next;
            }
        };
        LinkedMap.prototype.forEachReverse = function (callbackfn, thisArg) {
            var current = this._tail;
            while (current) {
                if (thisArg) {
                    callbackfn.bind(thisArg)(current.value, current.key, this);
                }
                else {
                    callbackfn(current.value, current.key, this);
                }
                current = current.previous;
            }
        };
        LinkedMap.prototype.values = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.value);
                current = current.next;
            }
            return result;
        };
        LinkedMap.prototype.keys = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.key);
                current = current.next;
            }
            return result;
        };
        /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator
        public keys(): IterableIterator<K> {
            let current = this._head;
            let iterator: IterableIterator<K> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<K> {
                    if (current) {
                        let result = { value: current.key, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
    
        public values(): IterableIterator<V> {
            let current = this._head;
            let iterator: IterableIterator<V> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<V> {
                    if (current) {
                        let result = { value: current.value, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
        */
        LinkedMap.prototype.addItemFirst = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._tail = item;
            }
            else if (!this._head) {
                throw new Error('Invalid list');
            }
            else {
                item.next = this._head;
                this._head.previous = item;
            }
            this._head = item;
        };
        LinkedMap.prototype.addItemLast = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._head = item;
            }
            else if (!this._tail) {
                throw new Error('Invalid list');
            }
            else {
                item.previous = this._tail;
                this._tail.next = item;
            }
            this._tail = item;
        };
        LinkedMap.prototype.removeItem = function (item) {
            if (item === this._head && item === this._tail) {
                this._head = undefined;
                this._tail = undefined;
            }
            else if (item === this._head) {
                this._head = item.next;
            }
            else if (item === this._tail) {
                this._tail = item.previous;
            }
            else {
                var next = item.next;
                var previous = item.previous;
                if (!next || !previous) {
                    throw new Error('Invalid list');
                }
                next.previous = previous;
                previous.next = next;
            }
        };
        LinkedMap.prototype.touch = function (item, touch) {
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            if ((touch !== Touch.First && touch !== Touch.Last)) {
                return;
            }
            if (touch === Touch.First) {
                if (item === this._head) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item
                if (item === this._tail) {
                    // previous must be defined since item was not head but is tail
                    // So there are more than on item in the map
                    previous.next = undefined;
                    this._tail = previous;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                // Insert the node at head
                item.previous = undefined;
                item.next = this._head;
                this._head.previous = item;
                this._head = item;
            }
            else if (touch === Touch.Last) {
                if (item === this._tail) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item.
                if (item === this._head) {
                    // next must be defined since item was not tail but is head
                    // So there are more than on item in the map
                    next.previous = undefined;
                    this._head = next;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                item.next = undefined;
                item.previous = this._tail;
                this._tail.next = item;
                this._tail = item;
            }
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
});

define(__m[61/*vs/base/common/marshalling*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        return JSON.parse(text, reviver);
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function reviver(key, value) {
        var marshallingConst;
        if (value !== void 0 && value !== null) {
            marshallingConst = value.$mid;
        }
        switch (marshallingConst) {
            case 1: return uri_1.default.revive(value);
            case 2: return new RegExp(value.source, value.flags);
            default: return value;
        }
    }
});

define(__m[8/*vs/base/common/strings*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/map*/]), function (require, exports, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The empty string.
     */
    exports.empty = '';
    function isFalsyOrWhitespace(str) {
        if (!str || typeof str !== 'string') {
            return true;
        }
        return str.trim().length === 0;
    }
    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\[\]\(\)\#]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.indexOf(needle, diff) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, options) {
        if (options === void 0) { options = {}; }
        if (!searchString) {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = escapeRegExpCharacters(searchString);
        }
        if (options.wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (options.global) {
            modifiers += 'g';
        }
        if (!options.matchCase) {
            modifiers += 'i';
        }
        if (options.multiline) {
            modifiers += 'm';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    var normalizedCache = new map_1.BoundedMap(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize('NFC');
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
    exports.normalizeNFC = normalizeNFC;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = str.length; }
        for (var i = start; i < end; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return str.substring(start, i);
            }
        }
        return str.substring(start, end);
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compare = compare;
    function compareIgnoreCase(a, b) {
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                // equal
                continue;
            }
            if (isUpperAsciiLetter(codeA)) {
                codeA += 32;
            }
            if (isUpperAsciiLetter(codeB)) {
                codeB += 32;
            }
            var diff = codeA - codeB;
            if (diff === 0) {
                // equal -> ignoreCase
                continue;
            }
            else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
                //
                return diff;
            }
            else {
                return compare(a.toLowerCase(), b.toLowerCase());
            }
        }
        if (a.length < b.length) {
            return -1;
        }
        else if (a.length > b.length) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compareIgnoreCase = compareIgnoreCase;
    function isLowerAsciiLetter(code) {
        return code >= 97 /* a */ && code <= 122 /* z */;
    }
    function isUpperAsciiLetter(code) {
        return code >= 65 /* A */ && code <= 90 /* Z */;
    }
    function isAsciiLetter(code) {
        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a ? a.length : 0;
        var len2 = b ? b.length : 0;
        if (len1 !== len2) {
            return false;
        }
        return doEqualsIgnoreCase(a, b);
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    function doEqualsIgnoreCase(a, b, stopAt) {
        if (stopAt === void 0) { stopAt = a.length; }
        if (typeof a !== 'string' || typeof b !== 'string') {
            return false;
        }
        for (var i = 0; i < stopAt; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            // a-z A-Z
            if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            else {
                if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    function beginsWithIgnoreCase(str, candidate) {
        var candidateLength = candidate.length;
        if (candidate.length > str.length) {
            return false;
        }
        return doEqualsIgnoreCase(str, candidate, candidateLength);
    }
    exports.beginsWithIgnoreCase = beginsWithIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {
        while (aStart < aEnd && bStart < bEnd) {
            if (a[aStart] !== b[bStart]) {
                return false;
            }
            aStart += 1;
            bStart += 1;
        }
        return true;
    }
    /**
     * Return the overlap between the suffix of `a` and the prefix of `b`.
     * For instance `overlap("foobar", "arr, I'm a pirate") === 2`.
     */
    function overlap(a, b) {
        var aEnd = a.length;
        var bEnd = b.length;
        var aStart = aEnd - bEnd;
        if (aStart === 0) {
            return a === b ? aEnd : 0;
        }
        else if (aStart < 0) {
            bEnd += aStart;
            aStart = 0;
        }
        while (aStart < aEnd && bEnd > 0) {
            if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {
                return bEnd;
            }
            bEnd -= 1;
            aStart += 1;
        }
        return 0;
    }
    exports.overlap = overlap;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    exports.isLowSurrogate = isLowSurrogate;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
     */
    var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
    /**
     * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
     */
    function containsRTL(str) {
        return CONTAINS_RTL.test(str);
    }
    exports.containsRTL = containsRTL;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
     */
    var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;
    function containsEmoji(str) {
        return CONTAINS_EMOJI.test(str);
    }
    exports.containsEmoji = containsEmoji;
    var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    /**
     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
     */
    function isBasicASCII(str) {
        return IS_BASIC_ASCII.test(str);
    }
    exports.isBasicASCII = isBasicASCII;
    function containsFullWidthCharacter(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (isFullWidthCharacter(str.charCodeAt(i))) {
                return true;
            }
        }
        return false;
    }
    exports.containsFullWidthCharacter = containsFullWidthCharacter;
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80 — 2EFF   CJK Radicals Supplement
        //          2F00 — 2FDF   Kangxi Radicals
        //          2FF0 — 2FFF   Ideographic Description Characters
        //          3000 — 303F   CJK Symbols and Punctuation
        //          3040 — 309F   Hiragana
        //          30A0 — 30FF   Katakana
        //          3100 — 312F   Bopomofo
        //          3130 — 318F   Hangul Compatibility Jamo
        //          3190 — 319F   Kanbun
        //          31A0 — 31BF   Bopomofo Extended
        //          31F0 — 31FF   Katakana Phonetic Extensions
        //          3200 — 32FF   Enclosed CJK Letters and Months
        //          3300 — 33FF   CJK Compatibility
        //          3400 — 4DBF   CJK Unified Ideographs Extension A
        //          4DC0 — 4DFF   Yijing Hexagram Symbols
        //          4E00 — 9FFF   CJK Unified Ideographs
        //          A000 — A48F   Yi Syllables
        //          A490 — A4CF   Yi Radicals
        //          AC00 — D7AF   Hangul Syllables
        // [IGNORE] D800 — DB7F   High Surrogates
        // [IGNORE] DB80 — DBFF   High Private Use Surrogates
        // [IGNORE] DC00 — DFFF   Low Surrogates
        // [IGNORE] E000 — F8FF   Private Use Area
        //          F900 — FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00 — FE0F   Variation Selectors
        // [IGNORE] FE20 — FE2F   Combining Half Marks
        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
        // [IGNORE] FE50 — FE6F   Small Form Variants
        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
        //          FF00 — FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0 — FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Computes the difference score for two strings. More similar strings have a higher score.
     * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.
     * Strings that have a large length difference will get a bad default score 0.
     * Complexity - both time and space O(first.length * second.length)
     * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
     *
     * @param first a string
     * @param second a string
     */
    function difference(first, second, maxLenDelta) {
        if (maxLenDelta === void 0) { maxLenDelta = 4; }
        var lengthDifference = Math.abs(first.length - second.length);
        // We only compute score if length of the currentWord and length of entry.name are similar.
        if (lengthDifference > maxLenDelta) {
            return 0;
        }
        // Initialize LCS (largest common subsequence) matrix.
        var LCS = [];
        var zeroArray = [];
        var i, j;
        for (i = 0; i < second.length + 1; ++i) {
            zeroArray.push(0);
        }
        for (i = 0; i < first.length + 1; ++i) {
            LCS.push(zeroArray);
        }
        for (i = 1; i < first.length + 1; ++i) {
            for (j = 1; j < second.length + 1; ++j) {
                if (first[i - 1] === second[j - 1]) {
                    LCS[i][j] = LCS[i - 1][j - 1] + 1;
                }
                else {
                    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
                }
            }
        }
        return LCS[first.length][second.length] - Math.sqrt(lengthDifference);
    }
    exports.difference = difference;
    /**
     * Returns an array in which every entry is the offset of a
     * line. There is always one entry which is zero.
     */
    function computeLineStarts(text) {
        var regexp = /\r\n|\r|\n/g, ret = [0], match;
        while ((match = regexp.exec(text))) {
            ret.push(regexp.lastIndex);
        }
        return ret;
    }
    exports.computeLineStarts = computeLineStarts;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var segments = text.split(/\b/), count = 0;
        for (var i = segments.length - 1; i >= 0; i--) {
            count += segments[i].length;
            if (count > n) {
                segments.splice(0, i);
                break;
            }
        }
        return segments.join(exports.empty).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    /**
     * Appends two strings. If the appended result is longer than maxLength,
     * trims the start of the result and replaces it with '...'.
     */
    function appendWithLimit(first, second, maxLength) {
        var newLength = first.length + second.length;
        if (newLength > maxLength) {
            first = '...' + first.substr(newLength - maxLength);
        }
        if (second.length > maxLength) {
            first += second.substr(second.length - maxLength);
        }
        else {
            first += second;
        }
        return first;
    }
    exports.appendWithLimit = appendWithLimit;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
});

define(__m[13/*vs/base/common/paths*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/platform*/,15/*vs/base/common/arrays*/,8/*vs/base/common/strings*/]), function (require, exports, platform_1, arrays_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    function relative(from, to) {
        // ignore trailing slashes
        var originalNormalizedFrom = strings_1.rtrim(normalize(from), exports.sep);
        var originalNormalizedTo = strings_1.rtrim(normalize(to), exports.sep);
        // we're assuming here that any non=linux OS is case insensitive
        // so we must compare each part in its lowercase form
        var normalizedFrom = platform_1.isLinux ? originalNormalizedFrom : originalNormalizedFrom.toLowerCase();
        var normalizedTo = platform_1.isLinux ? originalNormalizedTo : originalNormalizedTo.toLowerCase();
        var fromParts = normalizedFrom.split(exports.sep);
        var toParts = normalizedTo.split(exports.sep);
        var i = 0, max = Math.min(fromParts.length, toParts.length);
        for (; i < max; i++) {
            if (fromParts[i] !== toParts[i]) {
                break;
            }
        }
        var result = arrays_1.fill(fromParts.length - i, function () { return '..'; }).concat(originalNormalizedTo.split(exports.sep).slice(i));
        return result.join(exports.sep);
    }
    exports.relative = relative;
    /**
     * @returns the directory name of a path.
     */
    function dirname(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else {
            var res = path.substring(0, ~idx);
            if (platform_1.isWindows && res[res.length - 1] === ':') {
                res += exports.nativeSep; // make sure drive letters end with backslash
            }
            return res;
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns {{.far}} from boo.far or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = platform_1.isWindows && toOSPath;
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            code = path.charCodeAt(1);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === 58 /* Colon */) {
                code = path.charCodeAt(2);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        // Not using a function with var-args because of how TS compiles
        // them to JS - it would result in 2*n runtime cost instead
        // of 1*n, where n is parts.length.
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                    var next = part.charCodeAt(0);
                    if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === 92 /* Backslash */) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === 92 /* Backslash */) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    function isEqual(pathA, pathB, ignoreCase) {
        var identityEquals = (pathA === pathB);
        if (!ignoreCase || identityEquals) {
            return identityEquals;
        }
        if (!pathA || !pathB) {
            return false;
        }
        return strings_1.equalsIgnoreCase(pathA, pathB);
    }
    exports.isEqual = isEqual;
    function isEqualOrParent(path, candidate, ignoreCase) {
        if (path === candidate) {
            return true;
        }
        if (!path || !candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (ignoreCase) {
            var beginsWith = strings_1.beginsWithIgnoreCase(path, candidate);
            if (!beginsWith) {
                return false;
            }
            if (candidate.length === path.length) {
                return true; // same path, different casing
            }
            var sepOffset = candidate.length;
            if (candidate.charAt(candidate.length - 1) === exports.nativeSep) {
                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
            }
            return path.charAt(sepOffset) === exports.nativeSep;
        }
        if (candidate.charAt(candidate.length - 1) !== exports.nativeSep) {
            candidate += exports.nativeSep;
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isEqualOrParent = isEqualOrParent;
    /**
     * Adapted from Node's path.isAbsolute functions
     */
    function isAbsolute(path) {
        return platform_1.isWindows ?
            isAbsolute_win32(path) :
            isAbsolute_posix(path);
    }
    exports.isAbsolute = isAbsolute;
    function isAbsolute_win32(path) {
        if (!path) {
            return false;
        }
        var char0 = path.charCodeAt(0);
        if (char0 === 47 /* Slash */ || char0 === 92 /* Backslash */) {
            return true;
        }
        else if ((char0 >= 65 /* A */ && char0 <= 90 /* Z */) || (char0 >= 97 /* a */ && char0 <= 122 /* z */)) {
            if (path.length > 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var char2 = path.charCodeAt(2);
                if (char2 === 47 /* Slash */ || char2 === 92 /* Backslash */) {
                    return true;
                }
            }
        }
        return false;
    }
    exports.isAbsolute_win32 = isAbsolute_win32;
    function isAbsolute_posix(path) {
        return path && path.charCodeAt(0) === 47 /* Slash */;
    }
    exports.isAbsolute_posix = isAbsolute_posix;
});

define(__m[65/*vs/base/common/labels*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,9/*vs/base/common/platform*/,13/*vs/base/common/paths*/,8/*vs/base/common/strings*/]), function (require, exports, uri_1, platform, paths_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getPathLabel(resource, rootProvider, userHomeProvider) {
        if (!resource) {
            return null;
        }
        if (typeof resource === 'string') {
            resource = uri_1.default.file(resource);
        }
        // return early if we can resolve a relative path label from the root
        var baseResource = rootProvider ? rootProvider.getRoot(resource) : null;
        if (baseResource) {
            var hasMultipleRoots = rootProvider.getWorkspace().roots.length > 1;
            var pathLabel = void 0;
            if (paths_1.isEqual(baseResource.fsPath, resource.fsPath, !platform.isLinux /* ignorecase */)) {
                pathLabel = ''; // no label if pathes are identical
            }
            else {
                pathLabel = paths_1.normalize(strings_1.ltrim(resource.fsPath.substr(baseResource.fsPath.length), paths_1.nativeSep), true);
            }
            if (hasMultipleRoots) {
                var rootName = paths_1.basename(baseResource.fsPath);
                pathLabel = pathLabel ? paths_1.join(rootName, pathLabel) : rootName; // always show root basename if there are multiple
            }
            return pathLabel;
        }
        // convert c:\something => C:\something
        if (platform.isWindows && resource.fsPath && resource.fsPath[1] === ':') {
            return paths_1.normalize(resource.fsPath.charAt(0).toUpperCase() + resource.fsPath.slice(1), true);
        }
        // normalize and tildify (macOS, Linux only)
        var res = paths_1.normalize(resource.fsPath, true);
        if (!platform.isWindows && userHomeProvider) {
            res = tildify(res, userHomeProvider.userHome);
        }
        return res;
    }
    exports.getPathLabel = getPathLabel;
    function tildify(path, userHome) {
        if (path && (platform.isMacintosh || platform.isLinux) && paths_1.isEqualOrParent(path, userHome, !platform.isLinux /* ignorecase */)) {
            path = "~" + path.substr(userHome.length);
        }
        return path;
    }
    exports.tildify = tildify;
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     *
     * Algorithm for shortening paths is as follows:
     * 1. For every path in list, find unique substring of that path.
     * 2. Unique substring along with ellipsis is shortened path of that path.
     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
     *    and if present segment is not substring to any other paths then present segment is unique path,
     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
     *    if it is true take present segment as unique path.
     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
     *
     * Example 1
     * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
     * 2. find unique path of first path,
     * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
     * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
     * 	c. 'd\\c' is suffix of path2.
     *  d. 'b\\c' is not suffix of present path.
     *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
     * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
     *
     * Example 2
     * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
     * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
     */
    var ellipsis = '\u2026';
    var unc = '\\\\';
    var home = '~';
    function shorten(paths) {
        var shortenedPaths = new Array(paths.length);
        // for every path
        var match = false;
        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            var path = paths[pathIndex];
            if (path === '') {
                shortenedPaths[pathIndex] = "." + paths_1.nativeSep;
                continue;
            }
            if (!path) {
                shortenedPaths[pathIndex] = path;
                continue;
            }
            match = true;
            // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
            var prefix = '';
            if (path.indexOf(unc) === 0) {
                prefix = path.substr(0, path.indexOf(unc) + unc.length);
                path = path.substr(path.indexOf(unc) + unc.length);
            }
            else if (path.indexOf(paths_1.nativeSep) === 0) {
                prefix = path.substr(0, path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
                path = path.substr(path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
            }
            else if (path.indexOf(home) === 0) {
                prefix = path.substr(0, path.indexOf(home) + home.length);
                path = path.substr(path.indexOf(home) + home.length);
            }
            // pick the first shortest subpath found
            var segments = path.split(paths_1.nativeSep);
            for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                    match = false;
                    var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                    // that is unique to any other path
                    for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                            var isSubpathEnding = (start + subpathLength === segments.length);
                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
                            var subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(paths_1.nativeSep) > -1) ? paths_1.nativeSep + subpath : subpath;
                            var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);
                            match = !isSubpathEnding || isOtherPathEnding;
                        }
                    }
                    // found unique subpath
                    if (!match) {
                        var result = '';
                        // preserve disk drive or root prefix
                        if (strings_1.endsWith(segments[0], ':') || prefix !== '') {
                            if (start === 1) {
                                // extend subpath to include disk drive prefix
                                start = 0;
                                subpathLength++;
                                subpath = segments[0] + paths_1.nativeSep + subpath;
                            }
                            if (start > 0) {
                                result = segments[0] + paths_1.nativeSep;
                            }
                            result = prefix + result;
                        }
                        // add ellipsis at the beginning if neeeded
                        if (start > 0) {
                            result = result + ellipsis + paths_1.nativeSep;
                        }
                        result = result + subpath;
                        // add ellipsis at the end if needed
                        if (start + subpathLength < segments.length) {
                            result = result + paths_1.nativeSep + ellipsis;
                        }
                        shortenedPaths[pathIndex] = result;
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    exports.shorten = shorten;
    var Type;
    (function (Type) {
        Type[Type["TEXT"] = 0] = "TEXT";
        Type[Type["VARIABLE"] = 1] = "VARIABLE";
        Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
    })(Type || (Type = {}));
    /**
     * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
     * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
     * @param value string to which templating is applied
     * @param values the values of the templates to use
     */
    function template(template, values) {
        if (values === void 0) { values = Object.create(null); }
        var segments = [];
        var inVariable = false;
        var char;
        var curVal = '';
        for (var i = 0; i < template.length; i++) {
            char = template[i];
            // Beginning of variable
            if (char === '$' || (inVariable && char === '{')) {
                if (curVal) {
                    segments.push({ value: curVal, type: Type.TEXT });
                }
                curVal = '';
                inVariable = true;
            }
            else if (char === '}' && inVariable) {
                var resolved = values[curVal];
                // Variable
                if (typeof resolved === 'string') {
                    if (resolved.length) {
                        segments.push({ value: resolved, type: Type.VARIABLE });
                    }
                }
                else if (resolved) {
                    var prevSegment = segments[segments.length - 1];
                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                    }
                }
                curVal = '';
                inVariable = false;
            }
            else {
                curVal += char;
            }
        }
        // Tail
        if (curVal && !inVariable) {
            segments.push({ value: curVal, type: Type.TEXT });
        }
        return segments.filter(function (segment, index) {
            // Only keep separator if we have values to the left and right
            if (segment.type === Type.SEPARATOR) {
                var left = segments[index - 1];
                var right = segments[index + 1];
                return [left, right].every(function (segment) { return segment && segment.type === Type.VARIABLE && segment.value.length > 0; });
            }
            // accept any TEXT and VARIABLE
            return true;
        }).map(function (segment) { return segment.value; }).join('');
    }
    exports.template = template;
    /**
     * Handles mnemonics for menu items. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via & character (replace && with &)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicMenuLabel(label, forceDisableMnemonics) {
        if (platform.isMacintosh || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, '&');
    }
    exports.mnemonicMenuLabel = mnemonicMenuLabel;
    /**
     * Handles mnemonics for buttons. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via _ character (replace && with _)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicButtonLabel(label) {
        if (platform.isMacintosh) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, platform.isWindows ? '&' : '_');
    }
    exports.mnemonicButtonLabel = mnemonicButtonLabel;
    function unmnemonicLabel(label) {
        return label.replace(/&/g, '&&');
    }
    exports.unmnemonicLabel = unmnemonicLabel;
});











define(__m[58/*vs/base/common/uuid*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        ValueUUID.prototype.equals = function (other) {
            return this.asHex() === other.asHex();
        };
        return ValueUUID;
    }());
    var V4UUID = (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            return _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join('')) || this;
        }
        V4UUID._oneOf = function (array) {
            return array[Math.floor(array.length * Math.random())];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
        return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!isUUID(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the Source EULA.
 */
(function() {

var _modules = {};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

var exported = _modules["WinJS/Core/_WinJS"];

if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base.raw", exported);
} else {
    module.exports = exported;
}

if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
    _modules["WinJS/Core/_BaseCoreUtils"]._setImmediate = function(handler) {
        return process.nextTick(handler);
    };
}

})();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define(__m[2/*vs/base/common/winjs.base*/], __M([168/*vs/base/common/winjs.base.raw*/]), function (winjs) {
	'use strict';
	return {
		Promise: winjs.Promise,
		TPromise: winjs.Promise,
		PPromise: winjs.Promise
	};
});

define(__m[12/*vs/base/common/errors*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/platform*/,14/*vs/base/common/types*/,2/*vs/base/common/winjs.base*/]), function (require, exports, platform, types, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ BEGIN Hook up error listeners to winjs promises
    var outstandingPromiseErrors = {};
    function promiseErrorHandler(e) {
        //
        // e.detail looks like: { exception, error, promise, handler, id, parent }
        //
        var details = e.detail;
        var id = details.id;
        // If the error has a parent promise then this is not the origination of the
        //  error so we check if it has a handler, and if so we mark that the error
        //  was handled by removing it from outstandingPromiseErrors
        //
        if (details.parent) {
            if (details.handler && outstandingPromiseErrors) {
                delete outstandingPromiseErrors[id];
            }
            return;
        }
        // Indicate that this error was originated and needs to be handled
        outstandingPromiseErrors[id] = details;
        // The first time the queue fills up this iteration, schedule a timeout to
        // check if any errors are still unhandled.
        if (Object.keys(outstandingPromiseErrors).length === 1) {
            setTimeout(function () {
                var errors = outstandingPromiseErrors;
                outstandingPromiseErrors = {};
                Object.keys(errors).forEach(function (errorId) {
                    var error = errors[errorId];
                    if (error.exception) {
                        onUnexpectedError(error.exception);
                    }
                    else if (error.error) {
                        onUnexpectedError(error.error);
                    }
                    console.log('WARNING: Promise with no error callback:' + error.id);
                    console.log(error);
                    if (error.exception) {
                        console.log(error.exception.stack);
                    }
                });
            }, 0);
        }
    }
    winjs_base_1.TPromise.addEventListener('error', promiseErrorHandler);
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                platform.setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        // For external errors, we don't want the listeners to be called
        ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
            this.unexpectedErrorHandler(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
        return undefined;
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedExternalError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedExternalError(e);
        }
        return undefined;
    }
    exports.onUnexpectedExternalError = onUnexpectedExternalError;
    function onUnexpectedPromiseError(promise) {
        return promise.then(null, onUnexpectedError);
    }
    exports.onUnexpectedPromiseError = onUnexpectedPromiseError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    /**
     * Returns an error that signals something is not implemented.
     */
    function notImplemented() {
        return new Error('Not Implemented');
    }
    exports.notImplemented = notImplemented;
    function illegalArgument(name) {
        if (name) {
            return new Error("Illegal argument: " + name);
        }
        else {
            return new Error('Illegal argument');
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error("Illegal state: " + name);
        }
        else {
            return new Error('Illegal state');
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function disposed(what) {
        var result = new Error(what + " has been disposed");
        result.name = 'DISPOSED';
        return result;
    }
    exports.disposed = disposed;
    function create(message, options) {
        if (options === void 0) { options = {}; }
        var result = new Error(message);
        if (types.isNumber(options.severity)) {
            result.severity = options.severity;
        }
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
    function getErrorMessage(err) {
        if (!err) {
            return 'Error';
        }
        if (err.message) {
            return err.message;
        }
        if (err.stack) {
            return err.stack.split('\n')[0];
        }
        return String(err);
    }
    exports.getErrorMessage = getErrorMessage;
});

define(__m[57/*vs/base/common/callbackList*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CallbackList = (function () {
        function CallbackList() {
        }
        CallbackList.prototype.add = function (callback, context, bucket) {
            var _this = this;
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                this._callbacks = [];
                this._contexts = [];
            }
            this._callbacks.push(callback);
            this._contexts.push(context);
            if (Array.isArray(bucket)) {
                bucket.push({ dispose: function () { return _this.remove(callback, context); } });
            }
        };
        CallbackList.prototype.remove = function (callback, context) {
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                return;
            }
            var foundCallbackWithDifferentContext = false;
            for (var i = 0, len = this._callbacks.length; i < len; i++) {
                if (this._callbacks[i] === callback) {
                    if (this._contexts[i] === context) {
                        // callback & context match => remove it
                        this._callbacks.splice(i, 1);
                        this._contexts.splice(i, 1);
                        return;
                    }
                    else {
                        foundCallbackWithDifferentContext = true;
                    }
                }
            }
            if (foundCallbackWithDifferentContext) {
                throw new Error('When adding a listener with a context, you should remove it with the same context');
            }
        };
        CallbackList.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this._callbacks) {
                return undefined;
            }
            var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
            for (var i = 0, len = callbacks.length; i < len; i++) {
                try {
                    ret.push(callbacks[i].apply(contexts[i], args));
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            return ret;
        };
        CallbackList.prototype.isEmpty = function () {
            return !this._callbacks || this._callbacks.length === 0;
        };
        CallbackList.prototype.entries = function () {
            var _this = this;
            if (!this._callbacks) {
                return [];
            }
            return this._callbacks.map(function (fn, index) { return [fn, _this._contexts[index]]; });
        };
        CallbackList.prototype.dispose = function () {
            this._callbacks = undefined;
            this._contexts = undefined;
        };
        return CallbackList;
    }());
    exports.default = CallbackList;
});

define(__m[3/*vs/base/common/event*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/lifecycle*/,57/*vs/base/common/callbackList*/,2/*vs/base/common/winjs.base*/,33/*vs/base/common/functional*/]), function (require, exports, lifecycle_1, callbackList_1, winjs_base_1, functional_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event || (Event = {}));
    exports.default = Event;
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._callbacks) {
                            _this._callbacks = new callbackList_1.default();
                        }
                        var firstListener = _this._callbacks.isEmpty();
                        if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        _this._callbacks.add(listener, thisArgs);
                        if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                            _this._options.onFirstListenerDidAdd(_this);
                        }
                        if (_this._options && _this._options.onListenerDidAdd) {
                            _this._options.onListenerDidAdd(_this, listener, thisArgs);
                        }
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    _this._callbacks.remove(listener, thisArgs);
                                    if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._callbacks) {
                this._callbacks.invoke.call(this._callbacks, event);
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._callbacks) {
                this._callbacks.dispose();
                this._callbacks = undefined;
                this._disposed = true;
            }
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    var EventMultiplexer = (function () {
        function EventMultiplexer() {
            var _this = this;
            this.hasListeners = false;
            this.events = [];
            this.emitter = new Emitter({
                onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
                onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
            });
        }
        Object.defineProperty(EventMultiplexer.prototype, "event", {
            get: function () {
                return this.emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        EventMultiplexer.prototype.add = function (event) {
            var _this = this;
            var e = { event: event, listener: null };
            this.events.push(e);
            if (this.hasListeners) {
                this.hook(e);
            }
            var dispose = function () {
                if (_this.hasListeners) {
                    _this.unhook(e);
                }
                var idx = _this.events.indexOf(e);
                _this.events.splice(idx, 1);
            };
            return lifecycle_1.toDisposable(functional_1.once(dispose));
        };
        EventMultiplexer.prototype.onFirstListenerAdd = function () {
            var _this = this;
            this.hasListeners = true;
            this.events.forEach(function (e) { return _this.hook(e); });
        };
        EventMultiplexer.prototype.onLastListenerRemove = function () {
            var _this = this;
            this.hasListeners = false;
            this.events.forEach(function (e) { return _this.unhook(e); });
        };
        EventMultiplexer.prototype.hook = function (e) {
            var _this = this;
            e.listener = e.event(function (r) { return _this.emitter.fire(r); });
        };
        EventMultiplexer.prototype.unhook = function (e) {
            e.listener.dispose();
            e.listener = null;
        };
        EventMultiplexer.prototype.dispose = function () {
            this.emitter.dispose();
        };
        return EventMultiplexer;
    }());
    exports.EventMultiplexer = EventMultiplexer;
    /**
     * Creates an Event which is backed-up by the event emitter. This allows
     * to use the existing eventing pattern and is likely using less memory.
     * Sample:
     *
     * 	class Document {
     *
     *		private _eventbus = new EventEmitter();
     *
     *		public onDidChange = fromEventEmitter(this._eventbus, 'changed');
     *
     *		// getter-style
     *		// get onDidChange(): Event<(value:string)=>any> {
     *		// 	cache fromEventEmitter result and return
     *		// }
     *
     *		private _doIt() {
     *			// ...
     *			this._eventbus.emit('changed', value)
     *		}
     *	}
     */
    function fromEventEmitter(emitter, eventType) {
        return function (listener, thisArgs, disposables) {
            var result = emitter.addListener(eventType, function () {
                listener.apply(thisArgs, arguments);
            });
            if (Array.isArray(disposables)) {
                disposables.push(result);
            }
            return result;
        };
    }
    exports.fromEventEmitter = fromEventEmitter;
    function fromCallback(fn) {
        var listener;
        var emitter = new Emitter({
            onFirstListenerAdd: function () { return listener = fn(function (e) { return emitter.fire(e); }); },
            onLastListenerRemove: function () { return listener.dispose(); }
        });
        return emitter.event;
    }
    exports.fromCallback = fromCallback;
    function fromPromise(promise) {
        var emitter = new Emitter();
        var shouldEmit = false;
        promise
            .then(null, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(); }, 0);
            }
            else {
                emitter.fire();
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    exports.fromPromise = fromPromise;
    function toPromise(event) {
        return new winjs_base_1.TPromise(function (complete) {
            var sub = event(function (e) {
                sub.dispose();
                complete(e);
            });
        });
    }
    exports.toPromise = toPromise;
    function delayed(promise) {
        var toCancel = null;
        var listener = null;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                toCancel = promise.then(function (event) { return listener = event(function (e) { return emitter.fire(e); }); }, function () { return null; });
            },
            onLastListenerRemove: function () {
                if (toCancel) {
                    toCancel.cancel();
                    toCancel = null;
                }
                if (listener) {
                    listener.dispose();
                    listener = null;
                }
            }
        });
        return emitter.event;
    }
    exports.delayed = delayed;
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            var result = event(function (e) {
                result.dispose();
                return listener.call(thisArgs, e);
            }, null, disposables);
            return result;
        };
    }
    exports.once = once;
    function any() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return lifecycle_1.combinedDisposable(events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));
        };
    }
    exports.any = any;
    function debounceEvent(event, merger, delay, leading) {
        if (delay === void 0) { delay = 100; }
        if (leading === void 0) { leading = false; }
        var subscription;
        var output;
        var handle;
        var numDebouncedCalls = 0;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    numDebouncedCalls++;
                    output = merger(output, cur);
                    if (!handle && leading) {
                        emitter.fire(output);
                    }
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        handle = null;
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.wrapEvent(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.bufferEvents(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    var ChainableEvent = (function () {
        function ChainableEvent(_event) {
            this._event = _event;
        }
        Object.defineProperty(ChainableEvent.prototype, "event", {
            get: function () { return this._event; },
            enumerable: true,
            configurable: true
        });
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(mapEvent(this._event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filterEvent(this._event, fn));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this._event(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    exports.chain = chain;
    function stopwatch(event) {
        var start = new Date().getTime();
        return mapEvent(once(event), function (_) { return new Date().getTime() - start; });
    }
    exports.stopwatch = stopwatch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            buffer.forEach(function (e) { return emitter.fire(e); });
            buffer = null;
        };
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                listener.dispose();
                listener = null;
            }
        });
        return emitter.event;
    }
    exports.buffer = buffer;
    /**
     * Similar to `buffer` but it buffers indefinitely and repeats
     * the buffered events to every new listener.
     */
    function echo(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        event(function (e) {
            buffer.push(e);
            emitter.fire(e);
        });
        var flush = function (listener, thisArgs) { return buffer.forEach(function (e) { return listener.call(thisArgs, e); }); };
        var emitter = new Emitter({
            onListenerDidAdd: function (emitter, listener, thisArgs) {
                if (nextTick) {
                    setTimeout(function () { return flush(listener, thisArgs); });
                }
                else {
                    flush(listener, thisArgs);
                }
            }
        });
        return emitter.event;
    }
    exports.echo = echo;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[29/*vs/base/common/cancellation*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/]), function (require, exports, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.default.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: shortcutEvent
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var MutableToken = (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this._emitter = undefined;
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return MutableToken;
    }());
    var CancellationTokenSource = (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else {
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            this.cancel();
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[10/*vs/base/common/async*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/errors*/,9/*vs/base/common/platform*/,2/*vs/base/common/winjs.base*/,29/*vs/base/common/cancellation*/,17/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, errors, platform, winjs_base_1, cancellation_1, lifecycle_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    function toThenable(arg) {
        if (isThenable(arg)) {
            return arg;
        }
        else {
            return winjs_base_1.TPromise.as(arg);
        }
    }
    exports.toThenable = toThenable;
    function asWinJsPromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        return new winjs_base_1.TPromise(function (resolve, reject, progress) {
            var item = callback(source.token);
            if (item instanceof winjs_base_1.TPromise) {
                item.then(resolve, reject, progress);
            }
            else if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        }, function () {
            source.cancel();
        });
    }
    exports.asWinJsPromise = asWinJsPromise;
    /**
     * Hook a cancellation token to a WinJS Promise
     */
    function wireCancellationToken(token, promise, resolveAsUndefinedWhenCancelled) {
        var subscription = token.onCancellationRequested(function () { return promise.cancel(); });
        if (resolveAsUndefinedWhenCancelled) {
            promise = promise.then(undefined, function (err) {
                if (!errors.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                return undefined;
            });
        }
        return always(promise, function () { return subscription.dispose(); });
    }
    exports.wireCancellationToken = wireCancellationToken;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.TPromise(function (c, e, p) {
                        _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                    }, function () {
                        _this.activePromise.cancel();
                    });
                }
                return new winjs_base_1.TPromise(function (c, e, p) {
                    _this.queuedPromise.then(c, e, p);
                }, function () {
                    // no-op
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.activePromise.done(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                }, p);
            }, function () {
                _this.activePromise.cancel();
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.as(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so the he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.onSuccess = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.TPromise(function (c) {
                    _this.onSuccess = c;
                }, function () {
                    // no-op
                }).then(function () {
                    _this.completionPromise = null;
                    _this.onSuccess = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.onSuccess(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.completionPromise.cancel();
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail man strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            var _this = _super.call(this, defaultDelay) || this;
            _this.throttler = new Throttler();
            return _this;
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * Similar to the ThrottledDelayer, except it also guarantees that the promise
     * factory doesn't get called more often than every `minimumPeriod` milliseconds.
     */
    var PeriodThrottledDelayer = (function (_super) {
        __extends(PeriodThrottledDelayer, _super);
        function PeriodThrottledDelayer(defaultDelay, minimumPeriod) {
            if (minimumPeriod === void 0) { minimumPeriod = 0; }
            var _this = _super.call(this, defaultDelay) || this;
            _this.minimumPeriod = minimumPeriod;
            _this.periodThrottler = new Throttler();
            return _this;
        }
        PeriodThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () {
                return _this.periodThrottler.queue(function () {
                    return winjs_base_1.Promise.join([
                        winjs_base_1.TPromise.timeout(_this.minimumPeriod),
                        promiseFactory()
                    ]).then(function (r) { return r[1]; });
                });
            }, delay);
        };
        return PeriodThrottledDelayer;
    }(ThrottledDelayer));
    exports.PeriodThrottledDelayer = PeriodThrottledDelayer;
    var PromiseSource = (function () {
        function PromiseSource() {
            var _this = this;
            this._value = new winjs_base_1.TPromise(function (c, e) {
                _this._completeCallback = c;
                _this._errorCallback = e;
            });
        }
        Object.defineProperty(PromiseSource.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        PromiseSource.prototype.complete = function (value) {
            this._completeCallback(value);
        };
        PromiseSource.prototype.error = function (err) {
            this._errorCallback(err);
        };
        return PromiseSource;
    }());
    exports.PromiseSource = PromiseSource;
    var ShallowCancelThenPromise = (function (_super) {
        __extends(ShallowCancelThenPromise, _super);
        function ShallowCancelThenPromise(outer) {
            var _this = this;
            var completeCallback, errorCallback, progressCallback;
            _this = _super.call(this, function (c, e, p) {
                completeCallback = c;
                errorCallback = e;
                progressCallback = p;
            }, function () {
                // cancel this promise but not the
                // outer promise
                errorCallback(errors.canceled());
            }) || this;
            outer.then(completeCallback, errorCallback, progressCallback);
            return _this;
        }
        return ShallowCancelThenPromise;
    }(winjs_base_1.TPromise));
    exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
    /**
     * Returns a new promise that joins the provided promise. Upon completion of
     * the provided promise the provided function will always be called. This
     * method is comparable to a try-finally code block.
     * @param promise a promise
     * @param f a function that will be call in the success and error case.
     */
    function always(promise, f) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            promise.done(function (result) {
                try {
                    f(result);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                c(result);
            }, function (err) {
                try {
                    f(err);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                e(err);
            }, function (progress) {
                p(progress);
            });
        }, function () {
            promise.cancel();
        });
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactories) {
        var results = [];
        // reverse since we start with last element using pop()
        promiseFactories = promiseFactories.reverse();
        function next() {
            if (promiseFactories.length) {
                return promiseFactories.pop()();
            }
            return null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function first(promiseFactories, shouldStop) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        promiseFactories = promiseFactories.reverse().slice();
        var loop = function () {
            if (promiseFactories.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            var factory = promiseFactories.pop();
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return winjs_base_1.TPromise.as(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first = first;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
            this._onFinished = new event_1.Emitter();
        }
        Object.defineProperty(Limiter.prototype, "onFinished", {
            get: function () {
                return this._onFinished.event;
            },
            enumerable: true,
            configurable: true
        });
        Limiter.prototype.queue = function (promiseFactory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.outstandingPromises.push({
                    factory: promiseFactory,
                    c: c,
                    e: e,
                    p: p
                });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
                promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            if (this.outstandingPromises.length > 0) {
                this.consume();
            }
            else {
                this._onFinished.fire();
            }
        };
        Limiter.prototype.dispose = function () {
            this._onFinished.dispose();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    var Queue = (function (_super) {
        __extends(Queue, _super);
        function Queue() {
            return _super.call(this, 1) || this;
        }
        return Queue;
    }(Limiter));
    exports.Queue = Queue;
    function setDisposableTimeout(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var handle = setTimeout.apply(void 0, [handler, timeout].concat(args));
        return { dispose: function () { clearTimeout(handle); } };
    }
    exports.setDisposableTimeout = setDisposableTimeout;
    var TimeoutTimer = (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = platform.setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                platform.clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Replace runner. If there is a runner already scheduled, the new runner will be called.
         */
        RunOnceScheduler.prototype.setRunner = function (runner) {
            this.runner = runner;
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = platform.setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.runner();
            }
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); }, function () { return null; });
    }
    exports.ninvoke = ninvoke;
});

define(__m[28/*vs/base/common/glob*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/arrays*/,11/*vs/base/common/objects*/,8/*vs/base/common/strings*/,13/*vs/base/common/paths*/,21/*vs/base/common/map*/,2/*vs/base/common/winjs.base*/]), function (require, exports, arrays, objects, strings, paths, map_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getEmptyExpression() {
        return Object.create(null);
    }
    exports.getEmptyExpression = getEmptyExpression;
    function mergeExpressions() {
        var expressions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            expressions[_i] = arguments[_i];
        }
        return objects.assign.apply(objects, [getEmptyExpression()].concat(expressions.filter(function (expr) { return !!expr; })));
    }
    exports.mergeExpressions = mergeExpressions;
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    var ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, '/');
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === '**'; })) {
            regEx = '.*';
        }
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === '**') {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (char !== ']' && inBrackets) {
                        var res = void 0;
                        switch (char) {
                            case '-':// allow the range operator
                                res = char;
                                break;
                            case '^':// allow the negate operator
                                res = char;
                                break;
                            default:
                                res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the next one is not a globstar
                if (index < segments.length - 1 && segments[index + 1] !== '**') {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    var CACHE = new map_1.BoundedMap(10000); // bounded to 10000 elements
    var FALSE = function () {
        return false;
    };
    var NULL = function () {
        return null;
    };
    function parsePattern(pattern, options) {
        if (!pattern) {
            return NULL;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var patternKey = pattern + "_" + !!options.trimForExclusions;
        var parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return parsedPattern;
        }
        // Check for Trivias
        var match;
        if (T1.test(pattern)) {
            var base_1 = pattern.substr(4); // '**/*'.length === 4
            parsedPattern = function (path, basename) {
                return path && strings.endsWith(path, base_1) ? pattern : null;
            };
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return parsedPattern;
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, originalPattern) {
        var slashBase = "/" + base;
        var backslashBase = "\\" + base;
        var parsedPattern = function (path, basename) {
            if (!path) {
                return null;
            }
            if (basename) {
                return basename === base ? originalPattern : null;
            }
            return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
        };
        var basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [originalPattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
            .map(function (pattern) { return parsePattern(pattern, options); })
            .filter(function (pattern) { return pattern !== NULL; }), pattern);
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (n === 1) {
            return parsedPatterns[0];
        }
        var parsedPattern = function (path, basename) {
            for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(path, pattern, matchPathEnds) {
        var nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
        var nativePathEnd = paths.nativeSep + nativePath;
        var parsedPattern = matchPathEnds ? function (path, basename) {
            return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        } : function (path, basename) {
            return path && path === nativePath ? pattern : null;
        };
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
            return function (path, basename) {
                regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return path && regExp_1.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function match(arg1, path, siblingsFn) {
        if (!arg1 || !path) {
            return false;
        }
        return parse(arg1)(path, undefined, siblingsFn);
    }
    exports.match = match;
    function parse(arg1, options) {
        if (options === void 0) { options = {}; }
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string') {
            var parsedPattern_1 = parsePattern(arg1, options);
            if (parsedPattern_1 === NULL) {
                return FALSE;
            }
            var resultPattern = function (path, basename) {
                return !!parsedPattern_1(path, basename);
            };
            if (parsedPattern_1.allBasenames) {
                resultPattern.allBasenames = parsedPattern_1.allBasenames;
            }
            if (parsedPattern_1.allPaths) {
                resultPattern.allPaths = parsedPattern_1.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    exports.parse = parse;
    /**
     * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise
     */
    function parseToAsync(expression, options) {
        var parsedExpression = parse(expression, options);
        return function (path, basename, siblingsFn) {
            var result = parsedExpression(path, basename, siblingsFn);
            return result instanceof winjs_base_1.TPromise ? result : winjs_base_1.TPromise.as(result);
        };
    }
    exports.parseToAsync = parseToAsync;
    function getBasenameTerms(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    exports.getBasenameTerms = getBasenameTerms;
    function getPathTerms(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    exports.getPathTerms = getPathTerms;
    function parsedExpression(expression, options) {
        var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
            .filter(function (pattern) { return pattern !== NULL; }));
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (!parsedPatterns.some(function (parsedPattern) { return parsedPattern.requiresSiblings; })) {
            if (n === 1) {
                return parsedPatterns[0];
            }
            var resultExpression_1 = function (path, basename, siblingsFn) {
                for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                    // Pattern matches path
                    var result = parsedPatterns[i](path, basename);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
            if (withBasenames_1) {
                resultExpression_1.allBasenames = withBasenames_1.allBasenames;
            }
            var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
            if (allPaths_1.length) {
                resultExpression_1.allPaths = allPaths_1;
            }
            return resultExpression_1;
        }
        var resultExpression = function (path, basename, siblingsFn) {
            var siblingsPattern;
            var siblingsResolved = !siblingsFn;
            function siblingsToSiblingsPattern(siblings) {
                if (siblings && siblings.length) {
                    if (!basename) {
                        basename = paths.basename(path);
                    }
                    var name_1 = basename.substr(0, basename.length - paths.extname(path).length);
                    return { siblings: siblings, name: name_1 };
                }
                return undefined;
            }
            function siblingsPatternFn() {
                // Resolve siblings only once
                if (!siblingsResolved) {
                    siblingsResolved = true;
                    var siblings = siblingsFn();
                    siblingsPattern = winjs_base_1.TPromise.is(siblings) ?
                        siblings.then(siblingsToSiblingsPattern) :
                        siblingsToSiblingsPattern(siblings);
                }
                return siblingsPattern;
            }
            for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
                // Pattern matches path
                var result = parsedPatterns[i](path, basename, siblingsPatternFn);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        var parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            var when_1 = value.when;
            if (typeof when_1 === 'string') {
                var siblingsPatternToMatchingPattern_1 = function (siblingsPattern) {
                    var clausePattern = when_1.replace('$(basename)', siblingsPattern.name);
                    if (siblingsPattern.siblings.indexOf(clausePattern) !== -1) {
                        return pattern;
                    }
                    else {
                        return null; // pattern does not match in the end because the when clause is not satisfied
                    }
                };
                var result = function (path, basename, siblingsPatternFn) {
                    if (!parsedPattern(path, basename)) {
                        return null;
                    }
                    var siblingsPattern = siblingsPatternFn();
                    if (!siblingsPattern) {
                        return null; // pattern is malformed or we don't have siblings
                    }
                    return winjs_base_1.TPromise.is(siblingsPattern) ?
                        siblingsPattern.then(siblingsPatternToMatchingPattern_1) :
                        siblingsPatternToMatchingPattern_1(siblingsPattern);
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is Anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        var basenames = basenamePatterns.reduce(function (all, current) { return all.concat(current.basenames); }, []);
        var patterns;
        if (result) {
            patterns = [];
            for (var i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce(function (all, current) { return all.concat(current.patterns); }, []);
        }
        var aggregate = function (path, basename) {
            if (!path) {
                return null;
            }
            if (!basename) {
                var i = void 0;
                for (i = path.length; i > 0; i--) {
                    var ch = path.charCodeAt(i - 1);
                    if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            var index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
});

define(__m[54/*vs/base/common/mime*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/paths*/,14/*vs/base/common/types*/,8/*vs/base/common/strings*/,28/*vs/base/common/glob*/]), function (require, exports, paths, types, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    var nonUserRegisteredAssociations = [];
    var userRegisteredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association) {
        // Register
        var associationItem = toTextMimeAssociationItem(association);
        registeredAssociations.push(associationItem);
        if (!associationItem.userConfigured) {
            nonUserRegisteredAssociations.push(associationItem);
        }
        else {
            userRegisteredAssociations.push(associationItem);
        }
        // Check for conflicts unless this is a user configured association
        if (!associationItem.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === associationItem.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (associationItem.extension && a.extension === associationItem.extension) {
                    console.warn("Overwriting extension <<" + associationItem.extension + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filename && a.filename === associationItem.filename) {
                    console.warn("Overwriting filename <<" + associationItem.filename + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                    console.warn("Overwriting filepattern <<" + associationItem.filepattern + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.firstline && a.firstline === associationItem.firstline) {
                    console.warn("Overwriting firstline <<" + associationItem.firstline + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    function toTextMimeAssociationItem(association) {
        return {
            id: association.id,
            mime: association.mime,
            filename: association.filename,
            extension: association.extension,
            filepattern: association.filepattern,
            firstline: association.firstline,
            userConfigured: association.userConfigured,
            filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
            extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
            filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
            filepatternOnPath: association.filepattern ? association.filepattern.indexOf(paths.sep) >= 0 : false
        };
    }
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
            nonUserRegisteredAssociations = [];
            userRegisteredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
            userRegisteredAssociations = [];
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        var filename = paths.basename(path);
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, filename, associations) {
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        // We want to prioritize associations based on the order they are registered so that the last registered
        // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074
        for (var i = associations.length - 1; i >= 0; i--) {
            var association = associations[i];
            // First exact name match
            if (filename === association.filenameLowercase) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                    var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
                    if (glob_1.match(association.filepatternLowercase, target)) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                    if (strings.endsWith(filename, association.extensionLowercase)) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isBinaryMime(mimes) {
        if (!mimes) {
            return false;
        }
        var mimeVals;
        if (types.isArray(mimes)) {
            mimeVals = mimes;
        }
        else {
            mimeVals = mimes.split(',').map(function (mime) { return mime.trim(); });
        }
        return mimeVals.indexOf(exports.MIME_BINARY) >= 0;
    }
    exports.isBinaryMime = isBinaryMime;
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    function suggestFilename(langId, prefix) {
        for (var i = 0; i < registeredAssociations.length; i++) {
            var association = registeredAssociations[i];
            if (association.userConfigured) {
                continue; // only support registered ones
            }
            if (association.id === langId && association.extension) {
                return prefix + association.extension;
            }
        }
        return prefix; // without any known extension, just return the prefix
    }
    exports.suggestFilename = suggestFilename;
});











define(__m[126/*vs/base/common/scrollable*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScrollbarVisibility;
    (function (ScrollbarVisibility) {
        ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
        ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
    })(ScrollbarVisibility = exports.ScrollbarVisibility || (exports.ScrollbarVisibility = {}));
    var ScrollState = (function () {
        function ScrollState(width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
            width = width | 0;
            scrollWidth = scrollWidth | 0;
            scrollLeft = scrollLeft | 0;
            height = height | 0;
            scrollHeight = scrollHeight | 0;
            scrollTop = scrollTop | 0;
            if (width < 0) {
                width = 0;
            }
            if (scrollLeft + width > scrollWidth) {
                scrollLeft = scrollWidth - width;
            }
            if (scrollLeft < 0) {
                scrollLeft = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (scrollTop + height > scrollHeight) {
                scrollTop = scrollHeight - height;
            }
            if (scrollTop < 0) {
                scrollTop = 0;
            }
            this.width = width;
            this.scrollWidth = scrollWidth;
            this.scrollLeft = scrollLeft;
            this.height = height;
            this.scrollHeight = scrollHeight;
            this.scrollTop = scrollTop;
        }
        ScrollState.prototype.equals = function (other) {
            return (this.width === other.width
                && this.scrollWidth === other.scrollWidth
                && this.scrollLeft === other.scrollLeft
                && this.height === other.height
                && this.scrollHeight === other.scrollHeight
                && this.scrollTop === other.scrollTop);
        };
        ScrollState.prototype.withScrollDimensions = function (update) {
            return new ScrollState((typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), this.scrollTop);
        };
        ScrollState.prototype.withScrollPosition = function (update) {
            return new ScrollState(this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.scrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.scrollTop));
        };
        ScrollState.prototype.createScrollEvent = function (previous) {
            var widthChanged = (this.width !== previous.width);
            var scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);
            var scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);
            var heightChanged = (this.height !== previous.height);
            var scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);
            var scrollTopChanged = (this.scrollTop !== previous.scrollTop);
            return {
                width: this.width,
                scrollWidth: this.scrollWidth,
                scrollLeft: this.scrollLeft,
                height: this.height,
                scrollHeight: this.scrollHeight,
                scrollTop: this.scrollTop,
                widthChanged: widthChanged,
                scrollWidthChanged: scrollWidthChanged,
                scrollLeftChanged: scrollLeftChanged,
                heightChanged: heightChanged,
                scrollHeightChanged: scrollHeightChanged,
                scrollTopChanged: scrollTopChanged,
            };
        };
        return ScrollState;
    }());
    exports.ScrollState = ScrollState;
    var Scrollable = (function (_super) {
        __extends(Scrollable, _super);
        function Scrollable(smoothScrollDuration, scheduleAtNextAnimationFrame) {
            var _this = _super.call(this) || this;
            _this._onScroll = _this._register(new event_1.Emitter());
            _this.onScroll = _this._onScroll.event;
            _this._smoothScrollDuration = smoothScrollDuration;
            _this._scheduleAtNextAnimationFrame = scheduleAtNextAnimationFrame;
            _this._state = new ScrollState(0, 0, 0, 0, 0, 0);
            _this._smoothScrolling = null;
            return _this;
        }
        Scrollable.prototype.dispose = function () {
            if (this._smoothScrolling) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
            }
            _super.prototype.dispose.call(this);
        };
        Scrollable.prototype.setSmoothScrollDuration = function (smoothScrollDuration) {
            this._smoothScrollDuration = smoothScrollDuration;
        };
        Scrollable.prototype.validateScrollPosition = function (scrollPosition) {
            return this._state.withScrollPosition(scrollPosition);
        };
        Scrollable.prototype.getScrollDimensions = function () {
            return this._state;
        };
        Scrollable.prototype.setScrollDimensions = function (dimensions) {
            var newState = this._state.withScrollDimensions(dimensions);
            this._setState(newState);
            // Validate outstanding animated scroll position target
            if (this._smoothScrolling) {
                this._smoothScrolling.acceptScrollDimensions(this._state);
            }
        };
        /**
         * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
         * If no scroll animation is occuring, it will return the current scroll position instead.
         */
        Scrollable.prototype.getFutureScrollPosition = function () {
            if (this._smoothScrolling) {
                return this._smoothScrolling.to;
            }
            return this._state;
        };
        /**
         * Returns the current scroll position.
         * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
         */
        Scrollable.prototype.getCurrentScrollPosition = function () {
            return this._state;
        };
        Scrollable.prototype.setScrollPositionNow = function (update) {
            // no smooth scrolling requested
            var newState = this._state.withScrollPosition(update);
            // Terminate any outstanding smooth scrolling
            if (this._smoothScrolling) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
            }
            this._setState(newState);
        };
        Scrollable.prototype.setScrollPositionSmooth = function (update) {
            var _this = this;
            if (this._smoothScrollDuration === 0) {
                // Smooth scrolling not supported.
                return this.setScrollPositionNow(update);
            }
            if (this._smoothScrolling) {
                // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop
                update = {
                    scrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),
                    scrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)
                };
                // Validate `update`
                var validTarget = this._state.withScrollPosition(update);
                if (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {
                    // No need to interrupt or extend the current animation since we're going to the same place
                    return;
                }
                var newSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);
                this._smoothScrolling.dispose();
                this._smoothScrolling = newSmoothScrolling;
            }
            else {
                // Validate `update`
                var validTarget = this._state.withScrollPosition(update);
                this._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);
            }
            // Begin smooth scrolling animation
            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
                if (!_this._smoothScrolling) {
                    return;
                }
                _this._smoothScrolling.animationFrameDisposable = null;
                _this._performSmoothScrolling();
            });
        };
        Scrollable.prototype._performSmoothScrolling = function () {
            var _this = this;
            var update = this._smoothScrolling.tick();
            var newState = this._state.withScrollPosition(update);
            this._setState(newState);
            if (update.isDone) {
                this._smoothScrolling.dispose();
                this._smoothScrolling = null;
                return;
            }
            // Continue smooth scrolling animation
            this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(function () {
                if (!_this._smoothScrolling) {
                    return;
                }
                _this._smoothScrolling.animationFrameDisposable = null;
                _this._performSmoothScrolling();
            });
        };
        Scrollable.prototype._setState = function (newState) {
            var oldState = this._state;
            if (oldState.equals(newState)) {
                // no change
                return;
            }
            this._state = newState;
            this._onScroll.fire(this._state.createScrollEvent(oldState));
        };
        return Scrollable;
    }(lifecycle_1.Disposable));
    exports.Scrollable = Scrollable;
    var SmoothScrollingUpdate = (function () {
        function SmoothScrollingUpdate(scrollLeft, scrollTop, isDone) {
            this.scrollLeft = scrollLeft;
            this.scrollTop = scrollTop;
            this.isDone = isDone;
        }
        return SmoothScrollingUpdate;
    }());
    exports.SmoothScrollingUpdate = SmoothScrollingUpdate;
    function createEaseOutCubic(from, to) {
        var delta = to - from;
        return function (completion) {
            return from + delta * easeOutCubic(completion);
        };
    }
    function createComposed(a, b, cut) {
        return function (completion) {
            if (completion < cut) {
                return a(completion / cut);
            }
            return b((completion - cut) / (1 - cut));
        };
    }
    var SmoothScrollingOperation = (function () {
        function SmoothScrollingOperation(from, to, startTime, duration) {
            this.from = from;
            this.to = to;
            this.duration = duration;
            this._startTime = startTime;
            this.animationFrameDisposable = null;
            this._initAnimations();
        }
        SmoothScrollingOperation.prototype._initAnimations = function () {
            this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
            this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
        };
        SmoothScrollingOperation.prototype._initAnimation = function (from, to, viewportSize) {
            var delta = Math.abs(from - to);
            if (delta > 2.5 * viewportSize) {
                var stop1 = void 0, stop2 = void 0;
                if (from < to) {
                    // scroll to 75% of the viewportSize
                    stop1 = from + 0.75 * viewportSize;
                    stop2 = to - 0.75 * viewportSize;
                }
                else {
                    stop1 = from - 0.75 * viewportSize;
                    stop2 = to + 0.75 * viewportSize;
                }
                return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
            }
            return createEaseOutCubic(from, to);
        };
        SmoothScrollingOperation.prototype.dispose = function () {
            if (this.animationFrameDisposable !== null) {
                this.animationFrameDisposable.dispose();
                this.animationFrameDisposable = null;
            }
        };
        SmoothScrollingOperation.prototype.acceptScrollDimensions = function (state) {
            this.to = state.withScrollPosition(this.to);
            this._initAnimations();
        };
        SmoothScrollingOperation.prototype.tick = function () {
            return this._tick(Date.now());
        };
        SmoothScrollingOperation.prototype._tick = function (now) {
            var completion = (now - this._startTime) / this.duration;
            if (completion < 1) {
                var newScrollLeft = this.scrollLeft(completion);
                var newScrollTop = this.scrollTop(completion);
                return new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);
            }
            return new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);
        };
        SmoothScrollingOperation.prototype.combine = function (from, to, duration) {
            return SmoothScrollingOperation.start(from, to, duration);
        };
        SmoothScrollingOperation.start = function (from, to, duration) {
            // +10 / -10 : pretend the animation already started for a quicker response to a scroll request
            duration = duration + 10;
            var startTime = Date.now() - 10;
            return new SmoothScrollingOperation(from, to, startTime, duration);
        };
        return SmoothScrollingOperation;
    }());
    exports.SmoothScrollingOperation = SmoothScrollingOperation;
    function easeInCubic(t) {
        return Math.pow(t, 3);
    }
    function easeOutCubic(t) {
        return 1 - easeInCubic(1 - t);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[127/*vs/base/node/decoder*/], __M([1/*require*/,0/*exports*/,167/*string_decoder*/]), function (require, exports, sd) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenient way to iterate over output line by line. This helper accommodates for the fact that
     * a buffer might not end with new lines all the way.
     *
     * To use:
     * - call the write method
     * - forEach() over the result to get the lines
     */
    var LineDecoder = (function () {
        function LineDecoder(encoding) {
            if (encoding === void 0) { encoding = 'utf8'; }
            this.stringDecoder = new sd.StringDecoder(encoding);
            this.remaining = null;
        }
        LineDecoder.prototype.write = function (buffer) {
            var result = [];
            var value = this.remaining
                ? this.remaining + this.stringDecoder.write(buffer)
                : this.stringDecoder.write(buffer);
            if (value.length < 1) {
                return result;
            }
            var start = 0;
            var ch;
            var idx = start;
            while (idx < value.length) {
                ch = value.charCodeAt(idx);
                if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                    result.push(value.substring(start, idx));
                    idx++;
                    if (idx < value.length) {
                        var lastChar = ch;
                        ch = value.charCodeAt(idx);
                        if ((lastChar === 13 /* CarriageReturn */ && ch === 10 /* LineFeed */) || (lastChar === 10 /* LineFeed */ && ch === 13 /* CarriageReturn */)) {
                            idx++;
                        }
                    }
                    start = idx;
                }
                else {
                    idx++;
                }
            }
            this.remaining = start < value.length ? value.substr(start) : null;
            return result;
        };
        LineDecoder.prototype.end = function () {
            return this.remaining;
        };
        return LineDecoder;
    }());
    exports.LineDecoder = LineDecoder;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[53/*vs/base/node/event*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/]), function (require, exports, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function fromEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };
        var result = new event_1.Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    exports.fromEventEmitter = fromEventEmitter;
    ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[66/*vs/base/node/flow*/], __M([1/*require*/,0/*exports*/,72/*assert*/]), function (require, exports, assert) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as
     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.
     */
    function parallel(list, fn, callback) {
        var results = new Array(list.length);
        var errors = new Array(list.length);
        var didErrorOccur = false;
        var doneCount = 0;
        if (list.length === 0) {
            return callback(null, []);
        }
        list.forEach(function (item, index) {
            fn(item, function (error, result) {
                if (error) {
                    didErrorOccur = true;
                    results[index] = null;
                    errors[index] = error;
                }
                else {
                    results[index] = result;
                    errors[index] = null;
                }
                if (++doneCount === list.length) {
                    return callback(didErrorOccur ? errors : null, results);
                }
            });
        });
    }
    exports.parallel = parallel;
    function loop(param, fn, callback) {
        // Assert
        assert.ok(param, 'Missing first parameter');
        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');
        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');
        // Param is function, execute to retrieve array
        if (typeof (param) === 'function') {
            try {
                param(function (error, result) {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        loop(result, fn, callback);
                    }
                });
            }
            catch (error) {
                callback(error, null);
            }
        }
        else {
            var results_1 = [];
            var looper_1 = function (i) {
                // Still work to do
                if (i < param.length) {
                    // Execute function on array element
                    try {
                        fn(param[i], function (error, result) {
                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                            if (error === true || error === false) {
                                result = error;
                                error = null;
                            }
                            // Quit looping on error
                            if (error) {
                                callback(error, null);
                            }
                            else {
                                if (result) {
                                    results_1.push(result);
                                }
                                process.nextTick(function () {
                                    looper_1(i + 1);
                                });
                            }
                        }, i, param.length);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                }
                else {
                    callback(null, results_1);
                }
            };
            // Start looping with first element in array
            looper_1(0);
        }
    }
    exports.loop = loop;
    function Sequence(sequences) {
        // Assert
        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');
        sequences.forEach(function (sequence) {
            assert.ok(typeof (sequence) === 'function');
        });
        // Execute in Loop
        var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler
        var sequenceResult = null;
        loop(sequences, function (sequence, clb) {
            var sequenceFunction = function (error, result) {
                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                if (error === true || error === false) {
                    result = error;
                    error = null;
                }
                // Handle Error and Result
                if (error) {
                    clb(error, null);
                }
                else {
                    sequenceResult = result; //Remember result of sequence
                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it
                }
            };
            // We call the sequence function setting "this" to be the callback we define here
            // and we pass in the "sequenceResult" as first argument. Doing all this avoids having
            // to pass in a callback to the sequence because the callback is already "this".
            try {
                sequence.call(sequenceFunction, sequenceResult);
            }
            catch (error) {
                clb(error, null);
            }
        }, function (error, result) {
            if (error) {
                errorHandler(error);
            }
        });
    }
    function sequence(sequences) {
        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));
    }
    exports.sequence = sequence;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[73/*vs/base/node/extfs*/], __M([1/*require*/,0/*exports*/,58/*vs/base/common/uuid*/,8/*vs/base/common/strings*/,9/*vs/base/common/platform*/,66/*vs/base/node/flow*/,32/*fs*/,20/*path*/]), function (require, exports, uuid, strings, platform, flow, fs, paths) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var loop = flow.loop;
    function readdirSync(path) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdirSync(path).map(function (c) { return strings.normalizeNFC(c); });
        }
        return fs.readdirSync(path);
    }
    exports.readdirSync = readdirSync;
    function readdir(path, callback) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdir(path, function (error, children) {
                if (error) {
                    return callback(error, null);
                }
                return callback(null, children.map(function (c) { return strings.normalizeNFC(c); }));
            });
        }
        return fs.readdir(path, callback);
    }
    exports.readdir = readdir;
    function mkdirp(path, mode, callback) {
        fs.exists(path, function (exists) {
            if (exists) {
                return isDirectory(path, function (err, itIs) {
                    if (err) {
                        return callback(err);
                    }
                    if (!itIs) {
                        return callback(new Error('"' + path + '" is not a directory.'));
                    }
                    callback(null);
                });
            }
            mkdirp(paths.dirname(path), mode, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                if (mode) {
                    fs.mkdir(path, mode, function (error) {
                        if (error) {
                            return callback(error);
                        }
                        fs.chmod(path, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                    });
                }
                else {
                    fs.mkdir(path, null, callback);
                }
            });
        });
    }
    exports.mkdirp = mkdirp;
    function isDirectory(path, callback) {
        fs.stat(path, function (error, stat) {
            if (error) {
                return callback(error);
            }
            callback(null, stat.isDirectory());
        });
    }
    function copy(source, target, callback, copiedSources) {
        if (!copiedSources) {
            copiedSources = Object.create(null);
        }
        fs.stat(source, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (!stat.isDirectory()) {
                return pipeFs(source, target, stat.mode & 511, callback);
            }
            if (copiedSources[source]) {
                return callback(null); // escape when there are cycles (can happen with symlinks)
            }
            else {
                copiedSources[source] = true; // remember as copied
            }
            mkdirp(target, stat.mode & 511, function (err) {
                readdir(source, function (err, files) {
                    loop(files, function (file, clb) {
                        copy(paths.join(source, file), paths.join(target, file), function (error) { return clb(error, undefined); }, copiedSources);
                    }, callback);
                });
            });
        });
    }
    exports.copy = copy;
    function pipeFs(source, target, mode, callback) {
        var callbackHandled = false;
        var readStream = fs.createReadStream(source);
        var writeStream = fs.createWriteStream(target, { mode: mode });
        var onError = function (error) {
            if (!callbackHandled) {
                callbackHandled = true;
                callback(error);
            }
        };
        readStream.on('error', onError);
        writeStream.on('error', onError);
        readStream.on('end', function () {
            writeStream.end(function () {
                if (!callbackHandled) {
                    callbackHandled = true;
                    fs.chmod(target, mode, callback); // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                }
            });
        });
        // In node 0.8 there is no easy way to find out when the pipe operation has finished. As such, we use the end property = false
        // so that we are in charge of calling end() on the write stream and we will be notified when the write stream is really done.
        // We can do this because file streams have an end() method that allows to pass in a callback.
        // In node 0.10 there is an event 'finish' emitted from the write stream that can be used. See
        // https://groups.google.com/forum/?fromgroups=#!topic/nodejs/YWQ1sRoXOdI
        readStream.pipe(writeStream, { end: false });
    }
    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
    function del(path, tmpFolder, callback, done) {
        fs.exists(path, function (exists) {
            if (!exists) {
                return callback(null);
            }
            fs.stat(path, function (err, stat) {
                if (err || !stat) {
                    return callback(err);
                }
                // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                    return rmRecursive(path, callback);
                }
                var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
                fs.rename(path, pathInTemp, function (error) {
                    if (error) {
                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                    }
                    // Return early since the move succeeded
                    callback(null);
                    // do the heavy deletion outside the callers callback
                    rmRecursive(pathInTemp, function (error) {
                        if (error) {
                            console.error(error);
                        }
                        if (done) {
                            done(error);
                        }
                    });
                });
            });
        });
    }
    exports.del = del;
    function rmRecursive(path, callback) {
        if (path === '\\' || path === '/') {
            return callback(new Error('Will not delete root!'));
        }
        fs.exists(path, function (exists) {
            if (!exists) {
                callback(null);
            }
            else {
                fs.lstat(path, function (err, stat) {
                    if (err || !stat) {
                        callback(err);
                    }
                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                        var mode = stat.mode;
                        if (!(mode & 128)) {
                            fs.chmod(path, mode | 128, function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    fs.unlink(path, callback);
                                }
                            });
                        }
                        else {
                            fs.unlink(path, callback);
                        }
                    }
                    else {
                        readdir(path, function (err, children) {
                            if (err || !children) {
                                callback(err);
                            }
                            else if (children.length === 0) {
                                fs.rmdir(path, callback);
                            }
                            else {
                                var firstError_1 = null;
                                var childrenLeft_1 = children.length;
                                children.forEach(function (child) {
                                    rmRecursive(paths.join(path, child), function (err) {
                                        childrenLeft_1--;
                                        if (err) {
                                            firstError_1 = firstError_1 || err;
                                        }
                                        if (childrenLeft_1 === 0) {
                                            if (firstError_1) {
                                                callback(firstError_1);
                                            }
                                            else {
                                                fs.rmdir(path, callback);
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    }
                });
            }
        });
    }
    function delSync(path) {
        try {
            var stat = fs.lstatSync(path);
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                readdirSync(path).forEach(function (child) { return delSync(paths.join(path, child)); });
                fs.rmdirSync(path);
            }
            else {
                fs.unlinkSync(path);
            }
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return; // not found
            }
            throw err;
        }
    }
    exports.delSync = delSync;
    function mv(source, target, callback) {
        if (source === target) {
            return callback(null);
        }
        function updateMtime(err) {
            if (err) {
                return callback(err);
            }
            fs.stat(target, function (error, stat) {
                if (error) {
                    return callback(error);
                }
                if (stat.isDirectory()) {
                    return callback(null);
                }
                fs.open(target, 'a', null, function (err, fd) {
                    if (err) {
                        return callback(err);
                    }
                    fs.futimes(fd, stat.atime, new Date(), function (err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.close(fd, callback);
                    });
                });
            });
        }
        // Try native rename()
        fs.rename(source, target, function (err) {
            if (!err) {
                return updateMtime(null);
            }
            // In two cases we fallback to classic copy and delete:
            //
            // 1.) The EXDEV error indicates that source and target are on different devices
            // In this case, fallback to using a copy() operation as there is no way to
            // rename() between different devices.
            //
            // 2.) The user tries to rename a file/folder that ends with a dot. This is not
            // really possible to move then, at least on UNC devices.
            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
                return copy(source, target, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    rmRecursive(source, updateMtime);
                });
            }
            return callback(err);
        });
    }
    exports.mv = mv;
    // Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk
    // We do this in cases where we want to make sure the data is really on disk and
    // not in some cache.
    //
    // See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194
    var canFlush = true;
    function writeFileAndFlush(path, data, options, callback) {
        if (!canFlush) {
            return fs.writeFile(path, data, options, callback);
        }
        if (!options) {
            options = { mode: 438, flag: 'w' };
        }
        // Open the file with same flags and mode as fs.writeFile()
        fs.open(path, options.flag, options.mode, function (openError, fd) {
            if (openError) {
                return callback(openError);
            }
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFile(fd, data, function (writeError) {
                if (writeError) {
                    return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!
                }
                // Flush contents (not metadata) of the file to disk
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    return fs.close(fd, function (closeError) { return callback(closeError); });
                });
            });
        });
    }
    exports.writeFileAndFlush = writeFileAndFlush;
    /**
     * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83
     *
     * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.
     * On a case insensitive file system, the returned path might differ from the original path by character casing.
     * On a case sensitive file system, the returned path will always be identical to the original path.
     * In case of errors, null is returned. But you cannot use this function to verify that a path exists.
     * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.
     */
    function realcaseSync(path) {
        var dir = paths.dirname(path);
        if (path === dir) {
            return path;
        }
        var name = paths.basename(path).toLowerCase();
        try {
            var entries = readdirSync(dir);
            var found = entries.filter(function (e) { return e.toLowerCase() === name; }); // use a case insensitive search
            if (found.length === 1) {
                // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition
                var prefix = realcaseSync(dir); // recurse
                if (prefix) {
                    return paths.join(prefix, found[0]);
                }
            }
            else if (found.length > 1) {
                // must be a case sensitive $filesystem
                var ix = found.indexOf(name);
                if (ix >= 0) {
                    var prefix = realcaseSync(dir); // recurse
                    if (prefix) {
                        return paths.join(prefix, found[ix]);
                    }
                }
            }
        }
        catch (error) {
            // silently ignore error
        }
        return null;
    }
    exports.realcaseSync = realcaseSync;
    function realpathSync(path) {
        try {
            return fs.realpathSync(path);
        }
        catch (error) {
            // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error
            return normalizedPath;
        }
    }
    exports.realpathSync = realpathSync;
    function realpath(path, callback) {
        return fs.realpath(path, function (error, realpath) {
            if (!error) {
                return callback(null, realpath);
            }
            // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            return fs.access(normalizedPath, fs.constants.R_OK, function (error) {
                return callback(error, normalizedPath);
            });
        });
    }
    exports.realpath = realpath;
    function normalizePath(path) {
        return strings.rtrim(paths.normalize(path), paths.sep);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[47/*vs/base/node/pfs*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,73/*vs/base/node/extfs*/,20/*path*/,10/*vs/base/common/async*/,32/*fs*/,46/*os*/,9/*vs/base/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, extfs, path_1, async_1, fs, os, platform, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function readdir(path) {
        return async_1.nfcall(extfs.readdir, path);
    }
    exports.readdir = readdir;
    function exists(path) {
        return new winjs_base_1.TPromise(function (c) { return fs.exists(path, c); });
    }
    exports.exists = exists;
    function chmod(path, mode) {
        return async_1.nfcall(fs.chmod, path, mode);
    }
    exports.chmod = chmod;
    function mkdirp(path, mode) {
        var mkdir = function () { return async_1.nfcall(fs.mkdir, path, mode)
            .then(null, function (err) {
            if (err.code === 'EEXIST') {
                return async_1.nfcall(fs.stat, path)
                    .then(function (stat) { return stat.isDirectory
                    ? null
                    : winjs_base_1.TPromise.wrapError(new Error("'" + path + "' exists and is not a directory.")); });
            }
            return winjs_base_1.TPromise.wrapError(err);
        }); };
        // is root?
        if (path === path_1.dirname(path)) {
            return winjs_base_1.TPromise.as(true);
        }
        return mkdir().then(null, function (err) {
            if (err.code === 'ENOENT') {
                return mkdirp(path_1.dirname(path), mode).then(mkdir);
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.mkdirp = mkdirp;
    function rimraf(path) {
        return lstat(path).then(function (stat) {
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                return readdir(path)
                    .then(function (children) { return winjs_base_1.TPromise.join(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })
                    .then(function () { return rmdir(path); });
            }
            else {
                return unlink(path);
            }
        }, function (err) {
            if (err.code === 'ENOENT') {
                return void 0;
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.rimraf = rimraf;
    function realpath(path) {
        return async_1.nfcall(extfs.realpath, path);
    }
    exports.realpath = realpath;
    function stat(path) {
        return async_1.nfcall(fs.stat, path);
    }
    exports.stat = stat;
    function lstat(path) {
        return async_1.nfcall(fs.lstat, path);
    }
    exports.lstat = lstat;
    function rename(oldPath, newPath) {
        return async_1.nfcall(fs.rename, oldPath, newPath);
    }
    exports.rename = rename;
    function rmdir(path) {
        return async_1.nfcall(fs.rmdir, path);
    }
    exports.rmdir = rmdir;
    function unlink(path) {
        return async_1.nfcall(fs.unlink, path);
    }
    exports.unlink = unlink;
    function symlink(target, path, type) {
        return async_1.nfcall(fs.symlink, target, path, type);
    }
    exports.symlink = symlink;
    function readlink(path) {
        return async_1.nfcall(fs.readlink, path);
    }
    exports.readlink = readlink;
    function touch(path) {
        var now = Date.now() / 1000; // the value should be a Unix timestamp in seconds
        return async_1.nfcall(fs.utimes, path, now, now);
    }
    exports.touch = touch;
    function truncate(path, len) {
        return async_1.nfcall(fs.truncate, path, len);
    }
    exports.truncate = truncate;
    function readFile(path, encoding) {
        return async_1.nfcall(fs.readFile, path, encoding);
    }
    exports.readFile = readFile;
    // According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)
    // it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.
    // Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.
    var writeFilePathQueue = Object.create(null);
    function writeFile(path, data, options) {
        var queueKey = toQueueKey(path);
        return ensureWriteFileQueue(queueKey).queue(function () { return async_1.nfcall(extfs.writeFileAndFlush, path, data, options); });
    }
    exports.writeFile = writeFile;
    function toQueueKey(path) {
        var queueKey = path;
        if (platform.isWindows || platform.isMacintosh) {
            queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems
        }
        return queueKey;
    }
    function ensureWriteFileQueue(queueKey) {
        var writeFileQueue = writeFilePathQueue[queueKey];
        if (!writeFileQueue) {
            writeFileQueue = new async_1.Queue();
            writeFilePathQueue[queueKey] = writeFileQueue;
            var onFinish = event_1.once(writeFileQueue.onFinished);
            onFinish(function () {
                delete writeFilePathQueue[queueKey];
                writeFileQueue.dispose();
            });
        }
        return writeFileQueue;
    }
    /**
    * Read a dir and return only subfolders
    */
    function readDirsInDir(dirPath) {
        return readdir(dirPath).then(function (children) {
            return winjs_base_1.TPromise.join(children.map(function (c) { return dirExists(path_1.join(dirPath, c)); })).then(function (exists) {
                return children.filter(function (_, i) { return exists[i]; });
            });
        });
    }
    exports.readDirsInDir = readDirsInDir;
    /**
    * `path` exists and is a directory
    */
    function dirExists(path) {
        return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });
    }
    exports.dirExists = dirExists;
    /**
    * `path` exists and is a file.
    */
    function fileExists(path) {
        return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });
    }
    exports.fileExists = fileExists;
    /**
     * Deletes a path from disk.
     */
    var tmpDir = os.tmpdir();
    function del(path, tmp) {
        if (tmp === void 0) { tmp = tmpDir; }
        return async_1.nfcall(extfs.del, path, tmp);
    }
    exports.del = del;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[91/*vs/base/node/stdFork*/], __M([1/*require*/,0/*exports*/,20/*path*/,46/*os*/,44/*net*/,43/*child_process*/,6/*vs/base/common/uri*/]), function (require, exports, path, os, net, cp, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeRandomHexString(length) {
        var chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        var result = '';
        for (var i = 0; i < length; i++) {
            var idx = Math.floor(chars.length * Math.random());
            result += chars[idx];
        }
        return result;
    }
    function generatePipeName() {
        var randomName = 'vscode-' + makeRandomHexString(40);
        if (process.platform === 'win32') {
            return '\\\\.\\pipe\\' + randomName + '-sock';
        }
        // Mac/Unix: use socket file
        return path.join(os.tmpdir(), randomName + '.sock');
    }
    function generatePatchedEnv(env, stdInPipeName, stdOutPipeName, stdErrPipeName) {
        // Set the two unique pipe names and the electron flag as process env
        var newEnv = {};
        for (var key in env) {
            newEnv[key] = env[key];
        }
        newEnv['STDIN_PIPE_NAME'] = stdInPipeName;
        newEnv['STDOUT_PIPE_NAME'] = stdOutPipeName;
        newEnv['STDERR_PIPE_NAME'] = stdErrPipeName;
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        newEnv['ELECTRON_NO_ASAR'] = '1';
        return newEnv;
    }
    function fork(modulePath, args, options, callback) {
        var callbackCalled = false;
        var resolve = function (result) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(null, result);
        };
        var reject = function (err) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(err, null);
        };
        // Generate three unique pipe names
        var stdInPipeName = generatePipeName();
        var stdOutPipeName = generatePipeName();
        var stdErrPipeName = generatePipeName();
        var newEnv = generatePatchedEnv(options.env || process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);
        var childProcess;
        // Begin listening to stderr pipe
        var stdErrServer = net.createServer(function (stdErrStream) {
            // From now on the childProcess.stderr is available for reading
            childProcess.stderr = stdErrStream;
        });
        stdErrServer.listen(stdErrPipeName);
        // Begin listening to stdout pipe
        var stdOutServer = net.createServer(function (stdOutStream) {
            // The child process will write exactly one chunk with content `ready` when it has installed a listener to the stdin pipe
            stdOutStream.once('data', function (chunk) {
                // The child process is sending me the `ready` chunk, time to connect to the stdin pipe
                childProcess.stdin = net.connect(stdInPipeName);
                // From now on the childProcess.stdout is available for reading
                childProcess.stdout = stdOutStream;
                resolve(childProcess);
            });
        });
        stdOutServer.listen(stdOutPipeName);
        var serverClosed = false;
        var closeServer = function () {
            if (serverClosed) {
                return;
            }
            serverClosed = true;
            process.removeListener('exit', closeServer);
            stdOutServer.close();
            stdErrServer.close();
        };
        // Create the process
        var bootstrapperPath = (uri_1.default.parse(require.toUrl('./stdForkStart.js')).fsPath);
        childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {
            silent: true,
            cwd: options.cwd,
            env: newEnv,
            execArgv: options.execArgv
        });
        childProcess.once('error', function (err) {
            closeServer();
            reject(err);
        });
        childProcess.once('exit', function (err) {
            closeServer();
            reject(err);
        });
        // On vscode exit still close server #7758
        process.once('exit', closeServer);
    }
    exports.fork = fork;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[35/*vs/base/parts/ipc/common/ipc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,17/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/]), function (require, exports, winjs_base_1, lifecycle_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["RequestCommon"] = 0] = "RequestCommon";
        MessageType[MessageType["RequestCancel"] = 1] = "RequestCancel";
        MessageType[MessageType["ResponseInitialize"] = 2] = "ResponseInitialize";
        MessageType[MessageType["ResponseSuccess"] = 3] = "ResponseSuccess";
        MessageType[MessageType["ResponseProgress"] = 4] = "ResponseProgress";
        MessageType[MessageType["ResponseError"] = 5] = "ResponseError";
        MessageType[MessageType["ResponseErrorObj"] = 6] = "ResponseErrorObj";
    })(MessageType || (MessageType = {}));
    function isResponse(messageType) {
        return messageType >= MessageType.ResponseInitialize;
    }
    var State;
    (function (State) {
        State[State["Uninitialized"] = 0] = "Uninitialized";
        State[State["Idle"] = 1] = "Idle";
    })(State || (State = {}));
    var ChannelServer = (function () {
        function ChannelServer(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.channels = Object.create(null);
            this.activeRequests = Object.create(null);
            this.protocolListener = this.protocol.onMessage(function (r) { return _this.onMessage(r); });
            this.protocol.send({ type: MessageType.ResponseInitialize });
        }
        ChannelServer.prototype.registerChannel = function (channelName, channel) {
            this.channels[channelName] = channel;
        };
        ChannelServer.prototype.onMessage = function (request) {
            switch (request.type) {
                case MessageType.RequestCommon:
                    this.onCommonRequest(request);
                    break;
                case MessageType.RequestCancel:
                    this.onCancelRequest(request);
                    break;
            }
        };
        ChannelServer.prototype.onCommonRequest = function (request) {
            var _this = this;
            var channel = this.channels[request.channelName];
            var promise;
            try {
                promise = channel.call(request.name, request.arg);
            }
            catch (err) {
                promise = winjs_base_1.TPromise.wrapError(err);
            }
            var id = request.id;
            var requestPromise = promise.then(function (data) {
                _this.protocol.send({ id: id, data: data, type: MessageType.ResponseSuccess });
                delete _this.activeRequests[request.id];
            }, function (data) {
                if (data instanceof Error) {
                    _this.protocol.send({
                        id: id, data: {
                            message: data.message,
                            name: data.name,
                            stack: data.stack ? data.stack.split('\n') : void 0
                        }, type: MessageType.ResponseError
                    });
                }
                else {
                    _this.protocol.send({ id: id, data: data, type: MessageType.ResponseErrorObj });
                }
                delete _this.activeRequests[request.id];
            }, function (data) {
                _this.protocol.send({ id: id, data: data, type: MessageType.ResponseProgress });
            });
            this.activeRequests[request.id] = lifecycle_1.toDisposable(function () { return requestPromise.cancel(); });
        };
        ChannelServer.prototype.onCancelRequest = function (request) {
            var disposable = this.activeRequests[request.id];
            if (disposable) {
                disposable.dispose();
                delete this.activeRequests[request.id];
            }
        };
        ChannelServer.prototype.dispose = function () {
            var _this = this;
            this.protocolListener.dispose();
            this.protocolListener = null;
            Object.keys(this.activeRequests).forEach(function (id) {
                _this.activeRequests[id].dispose();
            });
            this.activeRequests = null;
        };
        return ChannelServer;
    }());
    exports.ChannelServer = ChannelServer;
    var ChannelClient = (function () {
        function ChannelClient(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.state = State.Uninitialized;
            this.activeRequests = [];
            this.bufferedRequests = [];
            this.handlers = Object.create(null);
            this.lastRequestId = 0;
            this.protocolListener = this.protocol.onMessage(function (r) { return _this.onMessage(r); });
        }
        ChannelClient.prototype.getChannel = function (channelName) {
            var _this = this;
            var call = function (command, arg) { return _this.request(channelName, command, arg); };
            return { call: call };
        };
        ChannelClient.prototype.request = function (channelName, name, arg) {
            var _this = this;
            var request = {
                raw: {
                    id: this.lastRequestId++,
                    type: MessageType.RequestCommon,
                    channelName: channelName,
                    name: name,
                    arg: arg
                }
            };
            var activeRequest = this.state === State.Uninitialized
                ? this.bufferRequest(request)
                : this.doRequest(request);
            this.activeRequests.push(activeRequest);
            activeRequest
                .then(null, function (_) { return null; })
                .done(function () { return _this.activeRequests = _this.activeRequests.filter(function (i) { return i !== activeRequest; }); });
            return activeRequest;
        };
        ChannelClient.prototype.doRequest = function (request) {
            var _this = this;
            var id = request.raw.id;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.handlers[id] = function (response) {
                    switch (response.type) {
                        case MessageType.ResponseSuccess:
                            delete _this.handlers[id];
                            c(response.data);
                            break;
                        case MessageType.ResponseError:
                            delete _this.handlers[id];
                            var error = new Error(response.data.message);
                            error.stack = response.data.stack;
                            error.name = response.data.name;
                            e(error);
                            break;
                        case MessageType.ResponseErrorObj:
                            delete _this.handlers[id];
                            e(response.data);
                            break;
                        case MessageType.ResponseProgress:
                            p(response.data);
                            break;
                    }
                };
                _this.send(request.raw);
            }, function () { return _this.send({ id: id, type: MessageType.RequestCancel }); });
        };
        ChannelClient.prototype.bufferRequest = function (request) {
            var _this = this;
            var flushedRequest = null;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.bufferedRequests.push(request);
                request.flush = function () {
                    request.flush = null;
                    flushedRequest = _this.doRequest(request).then(c, e, p);
                };
            }, function () {
                request.flush = null;
                if (_this.state !== State.Uninitialized) {
                    if (flushedRequest) {
                        flushedRequest.cancel();
                        flushedRequest = null;
                    }
                    return;
                }
                var idx = _this.bufferedRequests.indexOf(request);
                if (idx === -1) {
                    return;
                }
                _this.bufferedRequests.splice(idx, 1);
            });
        };
        ChannelClient.prototype.onMessage = function (response) {
            if (!isResponse(response.type)) {
                return;
            }
            if (this.state === State.Uninitialized && response.type === MessageType.ResponseInitialize) {
                this.state = State.Idle;
                this.bufferedRequests.forEach(function (r) { return r.flush && r.flush(); });
                this.bufferedRequests = null;
                return;
            }
            var handler = this.handlers[response.id];
            if (handler) {
                handler(response);
            }
        };
        ChannelClient.prototype.send = function (raw) {
            try {
                this.protocol.send(raw);
            }
            catch (err) {
                // noop
            }
        };
        ChannelClient.prototype.dispose = function () {
            this.protocolListener.dispose();
            this.protocolListener = null;
            this.activeRequests.forEach(function (r) { return r.cancel(); });
            this.activeRequests = [];
        };
        return ChannelClient;
    }());
    exports.ChannelClient = ChannelClient;
    /**
     * An `IPCServer` is both a channel server and a routing channel
     * client.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCServer = (function () {
        function IPCServer(onDidClientConnect) {
            var _this = this;
            this.channels = Object.create(null);
            this.channelClients = Object.create(null);
            this.onClientAdded = new event_1.Emitter();
            onDidClientConnect(function (_a) {
                var protocol = _a.protocol, onDidClientDisconnect = _a.onDidClientDisconnect;
                var onFirstMessage = event_1.once(protocol.onMessage);
                onFirstMessage(function (id) {
                    var channelServer = new ChannelServer(protocol);
                    var channelClient = new ChannelClient(protocol);
                    Object.keys(_this.channels)
                        .forEach(function (name) { return channelServer.registerChannel(name, _this.channels[name]); });
                    _this.channelClients[id] = channelClient;
                    _this.onClientAdded.fire(id);
                    onDidClientDisconnect(function () {
                        channelServer.dispose();
                        channelClient.dispose();
                        delete _this.channelClients[id];
                    });
                });
            });
        }
        IPCServer.prototype.getChannel = function (channelName, router) {
            var _this = this;
            var call = function (command, arg) {
                var id = router.route(command, arg);
                if (!id) {
                    return winjs_base_1.TPromise.wrapError(new Error('Client id should be provided'));
                }
                return _this.getClient(id).then(function (client) { return client.getChannel(channelName).call(command, arg); });
            };
            return { call: call };
        };
        IPCServer.prototype.registerChannel = function (channelName, channel) {
            this.channels[channelName] = channel;
        };
        IPCServer.prototype.getClient = function (clientId) {
            var _this = this;
            var client = this.channelClients[clientId];
            if (client) {
                return winjs_base_1.TPromise.as(client);
            }
            return new winjs_base_1.TPromise(function (c) {
                var onClient = event_1.once(event_1.filterEvent(_this.onClientAdded.event, function (id) { return id === clientId; }));
                onClient(function () { return c(_this.channelClients[clientId]); });
            });
        };
        IPCServer.prototype.dispose = function () {
            this.channels = null;
            this.channelClients = null;
            this.onClientAdded.dispose();
        };
        return IPCServer;
    }());
    exports.IPCServer = IPCServer;
    /**
     * An `IPCClient` is both a channel client and a channel server.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCClient = (function () {
        function IPCClient(protocol, id) {
            protocol.send(id);
            this.channelClient = new ChannelClient(protocol);
            this.channelServer = new ChannelServer(protocol);
        }
        IPCClient.prototype.getChannel = function (channelName) {
            return this.channelClient.getChannel(channelName);
        };
        IPCClient.prototype.registerChannel = function (channelName, channel) {
            this.channelServer.registerChannel(channelName, channel);
        };
        IPCClient.prototype.dispose = function () {
            this.channelClient.dispose();
            this.channelClient = null;
            this.channelServer.dispose();
            this.channelServer = null;
        };
        return IPCClient;
    }());
    exports.IPCClient = IPCClient;
    function getDelayedChannel(promise) {
        var call = function (command, arg) { return promise.then(function (c) { return c.call(command, arg); }); };
        return { call: call };
    }
    exports.getDelayedChannel = getDelayedChannel;
    function getNextTickChannel(channel) {
        var didTick = false;
        var call = function (command, arg) {
            if (didTick) {
                return channel.call(command, arg);
            }
            return winjs_base_1.TPromise.timeout(0)
                .then(function () { return didTick = true; })
                .then(function () { return channel.call(command, arg); });
        };
        return { call: call };
    }
    exports.getNextTickChannel = getNextTickChannel;
    function eventToCall(event, serializer) {
        if (serializer === void 0) { serializer = function (t) { return t; }; }
        var disposable;
        return new winjs_base_1.TPromise(function (c, e, p) { return disposable = event(function (t) { return p(serializer(t)); }); }, function () { return disposable.dispose(); });
    }
    exports.eventToCall = eventToCall;
    function eventFromCall(channel, name, arg, deserializer) {
        if (arg === void 0) { arg = null; }
        if (deserializer === void 0) { deserializer = function (t) { return t; }; }
        var promise;
        var emitter = new event_1.Emitter({
            onFirstListenerAdd: function () {
                promise = channel.call(name, arg)
                    .then(null, function (err) { return null; }, function (e) { return emitter.fire(deserializer(e)); });
            },
            onLastListenerRemove: function () {
                promise.cancel();
                promise = null;
            }
        });
        return emitter.event;
    }
    exports.eventFromCall = eventFromCall;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[101/*vs/base/parts/ipc/node/ipc.net*/], __M([1/*require*/,0/*exports*/,44/*net*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,53/*vs/base/node/event*/,35/*vs/base/parts/ipc/common/ipc*/,20/*path*/,46/*os*/,58/*vs/base/common/uuid*/]), function (require, exports, net_1, winjs_base_1, event_1, event_2, ipc_1, path_1, os_1, uuid_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateRandomPipeName() {
        var randomSuffix = uuid_1.generateUuid();
        if (process.platform === 'win32') {
            return "\\\\.\\pipe\\vscode-" + randomSuffix + "-sock";
        }
        else {
            // Mac/Unix: use socket file
            return path_1.join(os_1.tmpdir(), "vscode-" + randomSuffix + ".sock");
        }
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    var Protocol = (function () {
        function Protocol(_socket) {
            var _this = this;
            this._socket = _socket;
            this._onMessage = new event_1.Emitter();
            this.onMessage = this._onMessage.event;
            this._writeBuffer = new (function () {
                function class_1() {
                    this._data = [];
                    this._totalLength = 0;
                }
                class_1.prototype.add = function (head, body) {
                    var wasEmpty = this._totalLength === 0;
                    this._data.push(head, body);
                    this._totalLength += head.length + body.length;
                    return wasEmpty;
                };
                class_1.prototype.take = function () {
                    var ret = Buffer.concat(this._data, this._totalLength);
                    this._data.length = 0;
                    this._totalLength = 0;
                    return ret;
                };
                return class_1;
            }());
            var chunks = [];
            var totalLength = 0;
            var state = {
                readHead: true,
                bodyIsJson: false,
                bodyLen: -1,
            };
            _socket.on('data', function (data) {
                chunks.push(data);
                totalLength += data.length;
                while (totalLength > 0) {
                    if (state.readHead) {
                        // expecting header -> read 17bytes for header
                        // information: `bodyIsJson` and `bodyLen`
                        if (totalLength >= Protocol._headerLen) {
                            var all = Buffer.concat(chunks);
                            state.bodyIsJson = all.readInt8(0) === 1;
                            state.bodyLen = all.readInt32BE(1);
                            state.readHead = false;
                            var rest = all.slice(Protocol._headerLen);
                            totalLength = rest.length;
                            chunks = [rest];
                        }
                        else {
                            break;
                        }
                    }
                    if (!state.readHead) {
                        // expecting body -> read bodyLen-bytes for
                        // the actual message or wait for more data
                        if (totalLength >= state.bodyLen) {
                            var all = Buffer.concat(chunks);
                            var message = all.toString('utf8', 0, state.bodyLen);
                            if (state.bodyIsJson) {
                                message = JSON.parse(message);
                            }
                            _this._onMessage.fire(message);
                            var rest = all.slice(state.bodyLen);
                            totalLength = rest.length;
                            chunks = [rest];
                            state.bodyIsJson = false;
                            state.bodyLen = -1;
                            state.readHead = true;
                        }
                        else {
                            break;
                        }
                    }
                }
            });
        }
        Protocol.prototype.send = function (message) {
            // [bodyIsJson|bodyLen|message]
            // |^header^^^^^^^^^^^|^data^^]
            var header = Buffer.alloc(Protocol._headerLen);
            // ensure string
            if (typeof message !== 'string') {
                message = JSON.stringify(message);
                header.writeInt8(1, 0);
            }
            var data = Buffer.from(message);
            header.writeInt32BE(data.length, 1);
            this._writeSoon(header, data);
        };
        Protocol.prototype._writeSoon = function (header, data) {
            var _this = this;
            if (this._writeBuffer.add(header, data)) {
                setImmediate(function () {
                    // return early if socket has been destroyed in the meantime
                    if (_this._socket.destroyed) {
                        return;
                    }
                    // we ignore the returned value from `write` because we would have to cached the data
                    // anyways and nodejs is already doing that for us:
                    // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
                    // > However, the false return value is only advisory and the writable stream will unconditionally
                    // > accept and buffer chunk even if it has not not been allowed to drain.
                    _this._socket.write(_this._writeBuffer.take());
                });
            }
        };
        Protocol._headerLen = 17;
        return Protocol;
    }());
    exports.Protocol = Protocol;
    var Server = (function (_super) {
        __extends(Server, _super);
        function Server(server) {
            var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;
            _this.server = server;
            return _this;
        }
        Server.toClientConnectionEvent = function (server) {
            var onConnection = event_2.fromEventEmitter(server, 'connection');
            return event_1.mapEvent(onConnection, function (socket) { return ({
                protocol: new Protocol(socket),
                onDidClientDisconnect: event_1.once(event_2.fromEventEmitter(socket, 'close'))
            }); });
        };
        Server.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.server.close();
            this.server = null;
        };
        return Server;
    }(ipc_1.IPCServer));
    exports.Server = Server;
    var Client = (function (_super) {
        __extends(Client, _super);
        function Client(socket, id) {
            var _this = _super.call(this, new Protocol(socket), id) || this;
            _this.socket = socket;
            _this._onClose = new event_1.Emitter();
            socket.once('close', function () { return _this._onClose.fire(); });
            return _this;
        }
        Object.defineProperty(Client.prototype, "onClose", {
            get: function () { return this._onClose.event; },
            enumerable: true,
            configurable: true
        });
        Client.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.socket.end();
            this.socket = null;
        };
        return Client;
    }(ipc_1.IPCClient));
    exports.Client = Client;
    function serve(hook) {
        return new winjs_base_1.TPromise(function (c, e) {
            var server = net_1.createServer();
            server.on('error', e);
            server.listen(hook, function () {
                server.removeListener('error', e);
                c(new Server(server));
            });
        });
    }
    exports.serve = serve;
    function connect(hook, clientId) {
        return new winjs_base_1.TPromise(function (c, e) {
            var socket = net_1.createConnection(hook, function () {
                socket.removeListener('error', e);
                c(new Client(socket, clientId));
            });
            socket.once('error', e);
        });
    }
    exports.connect = connect;
});

define(__m[103/*vs/editor/common/core/position*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A position in the editor.
     */
    var Position = (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        /**
         * Test if this position equals other position
         */
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        /**
         * Test if position `a` equals position `b`
         */
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be false.
         */
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be true.
         */
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        /**
         * A function that compares positions, useful for sorting
         */
        Position.compare = function (a, b) {
            var aLineNumber = a.lineNumber | 0;
            var bLineNumber = b.lineNumber | 0;
            if (aLineNumber === bLineNumber) {
                var aColumn = a.column | 0;
                var bColumn = b.column | 0;
                return aColumn - bColumn;
            }
            return aLineNumber - bLineNumber;
        };
        /**
         * Clone this position.
         */
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        /**
         * Convert to a human-readable representation.
         */
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        /**
         * Create a `Position` from an `IPosition`.
         */
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        /**
         * Test if `obj` is an `IPosition`.
         */
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[42/*vs/editor/common/core/range*/], __M([1/*require*/,0/*exports*/,103/*vs/editor/common/core/position*/]), function (require, exports, position_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
     */
    var Range = (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        /**
         * Test if this range is empty.
         */
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        /**
         * Test if `range` is empty.
         */
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        /**
         * Test if `position` is in `range`. If the position is at the edges, will return true.
         */
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        /**
         * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
         */
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.plusRange = function (a, b) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        /**
         * Test if this range equals other.
         */
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        /**
         * Test if range `a` equals `b`.
         */
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        /**
         * Clone this range.
         */
        Range.prototype.cloneRange = function () {
            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Transform to a user presentable string representation.
         */
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        /**
         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
         */
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        /**
         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
         */
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.prototype.collapseToStart = function () {
            return Range.collapseToStart(this);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.collapseToStart = function (range) {
            return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        };
        // ---
        Range.fromPositions = function (start, end) {
            if (end === void 0) { end = start; }
            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        /**
         * Create a `Range` from an `IRange`.
         */
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        /**
         * Test if `obj` is an `IRange`.
         */
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        /**
         * Test if the two ranges are touching in any way.
         */
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            var aStartLineNumber = a.startLineNumber | 0;
            var bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                var aStartColumn = a.startColumn | 0;
                var bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    var aEndLineNumber = a.endLineNumber | 0;
                    var bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        var aEndColumn = a.endColumn | 0;
                        var bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        /**
         * Test if the range spans multiple lines.
         */
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        return Range;
    }());
    exports.Range = Range;
});

define(__m[107/*vs/editor/common/core/uint*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Uint8Matrix = (function () {
        function Uint8Matrix(rows, cols, defaultValue) {
            var data = new Uint8Array(rows * cols);
            for (var i = 0, len = rows * cols; i < len; i++) {
                data[i] = defaultValue;
            }
            this._data = data;
            this._rows = rows;
            this._cols = cols;
        }
        Uint8Matrix.prototype.get = function (row, col) {
            return this._data[row * this._cols + col];
        };
        Uint8Matrix.prototype.set = function (row, col, value) {
            this._data[row * this._cols + col] = value;
        };
        return Uint8Matrix;
    }());
    exports.Uint8Matrix = Uint8Matrix;
    var Constants;
    (function (Constants) {
        /**
         * MAX SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
        /**
         * MIN SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
        /**
         * Max unsigned integer that fits on 8 bits.
         */
        Constants[Constants["MAX_UINT_8"] = 255] = "MAX_UINT_8";
        /**
         * Max unsigned integer that fits on 16 bits.
         */
        Constants[Constants["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
        /**
         * Max unsigned integer that fits on 32 bits.
         */
        Constants[Constants["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
    })(Constants = exports.Constants || (exports.Constants = {}));
    function toUint8(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 255 /* MAX_UINT_8 */) {
            return 255 /* MAX_UINT_8 */;
        }
        return v | 0;
    }
    exports.toUint8 = toUint8;
    function toUint32(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 4294967295 /* MAX_UINT_32 */) {
            return 4294967295 /* MAX_UINT_32 */;
        }
        return v | 0;
    }
    exports.toUint32 = toUint32;
    function toUint32Array(arr) {
        var len = arr.length;
        var r = new Uint32Array(len);
        for (var i = 0; i < len; i++) {
            r[i] = toUint32(arr[i]);
        }
        return r;
    }
    exports.toUint32Array = toUint32Array;
});

define(__m[23/*vs/editor/common/editorCommon*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    var OverviewRulerLane;
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(OverviewRulerLane = exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    /**
     * End of line character preference.
     */
    var EndOfLinePreference;
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(EndOfLinePreference = exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    /**
     * The default end of line to use when instantiating models.
     */
    var DefaultEndOfLine;
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(DefaultEndOfLine = exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    /**
     * End of line character preference.
     */
    var EndOfLineSequence;
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(EndOfLineSequence = exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var TextModelResolvedOptions = (function () {
        /**
         * @internal
         */
        function TextModelResolvedOptions(src) {
            this.tabSize = src.tabSize | 0;
            this.insertSpaces = Boolean(src.insertSpaces);
            this.defaultEOL = src.defaultEOL | 0;
            this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        }
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.equals = function (other) {
            return (this.tabSize === other.tabSize
                && this.insertSpaces === other.insertSpaces
                && this.defaultEOL === other.defaultEOL
                && this.trimAutoWhitespace === other.trimAutoWhitespace);
        };
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                tabSize: this.tabSize !== newOpts.tabSize,
                insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
                trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
            };
        };
        return TextModelResolvedOptions;
    }());
    exports.TextModelResolvedOptions = TextModelResolvedOptions;
    var FindMatch = (function () {
        /**
         * @internal
         */
        function FindMatch(range, matches) {
            this.range = range;
            this.matches = matches;
        }
        return FindMatch;
    }());
    exports.FindMatch = FindMatch;
    /**
     * Describes the behavior of decorations when typing/editing near their edges.
     * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
     */
    var TrackedRangeStickiness;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(TrackedRangeStickiness = exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    var ScrollType;
    (function (ScrollType) {
        ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
        ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
    })(ScrollType = exports.ScrollType || (exports.ScrollType = {}));
    /**
     * @internal
     */
    function isThemeColor(o) {
        return o && typeof o.id === 'string';
    }
    exports.isThemeColor = isThemeColor;
    /**
     * The type of the `IEditor`.
     */
    exports.EditorType = {
        ICodeEditor: 'vs.editor.ICodeEditor',
        IDiffEditor: 'vs.editor.IDiffEditor'
    };
    /**
     *@internal
     */
    function isCommonCodeEditor(thing) {
        if (thing && typeof thing.getEditorType === 'function') {
            return thing.getEditorType() === exports.EditorType.ICodeEditor;
        }
        else {
            return false;
        }
    }
    exports.isCommonCodeEditor = isCommonCodeEditor;
    /**
     *@internal
     */
    function isCommonDiffEditor(thing) {
        if (thing && typeof thing.getEditorType === 'function') {
            return thing.getEditorType() === exports.EditorType.IDiffEditor;
        }
        else {
            return false;
        }
    }
    exports.isCommonDiffEditor = isCommonDiffEditor;
    /**
     * Built-in commands.
     * @internal
     */
    exports.Handler = {
        ExecuteCommand: 'executeCommand',
        ExecuteCommands: 'executeCommands',
        Type: 'type',
        ReplacePreviousChar: 'replacePreviousChar',
        CompositionStart: 'compositionStart',
        CompositionEnd: 'compositionEnd',
        Paste: 'paste',
        Cut: 'cut',
        Undo: 'undo',
        Redo: 'redo',
    };
});

define(__m[112/*vs/editor/common/model/textSource*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/strings*/,23/*vs/editor/common/editorCommon*/]), function (require, exports, strings, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RawTextSource = (function () {
        function RawTextSource() {
        }
        RawTextSource.fromString = function (rawText) {
            // Count the number of lines that end with \r\n
            var carriageReturnCnt = 0;
            var lastCarriageReturnIndex = -1;
            while ((lastCarriageReturnIndex = rawText.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
                carriageReturnCnt++;
            }
            var containsRTL = strings.containsRTL(rawText);
            var isBasicASCII = (containsRTL ? false : strings.isBasicASCII(rawText));
            // Split the text into lines
            var lines = rawText.split(/\r\n|\r|\n/);
            // Remove the BOM (if present)
            var BOM = '';
            if (strings.startsWithUTF8BOM(lines[0])) {
                BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
            return {
                BOM: BOM,
                lines: lines,
                length: rawText.length,
                containsRTL: containsRTL,
                isBasicASCII: isBasicASCII,
                totalCRCount: carriageReturnCnt
            };
        };
        return RawTextSource;
    }());
    exports.RawTextSource = RawTextSource;
    var TextSource = (function () {
        function TextSource() {
        }
        /**
         * if text source is empty or with precisely one line, returns null. No end of line is detected.
         * if text source contains more lines ending with '\r\n', returns '\r\n'.
         * Otherwise returns '\n'. More lines end with '\n'.
         */
        TextSource._getEOL = function (rawTextSource, defaultEOL) {
            var lineFeedCnt = rawTextSource.lines.length - 1;
            if (lineFeedCnt === 0) {
                // This is an empty file or a file with precisely one line
                return (defaultEOL === editorCommon_1.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            if (rawTextSource.totalCRCount > lineFeedCnt / 2) {
                // More than half of the file contains \r\n ending lines
                return '\r\n';
            }
            // At least one line more ends in \n
            return '\n';
        };
        TextSource.fromRawTextSource = function (rawTextSource, defaultEOL) {
            return {
                length: rawTextSource.length,
                lines: rawTextSource.lines,
                BOM: rawTextSource.BOM,
                EOL: this._getEOL(rawTextSource, defaultEOL),
                containsRTL: rawTextSource.containsRTL,
                isBasicASCII: rawTextSource.isBasicASCII,
            };
        };
        TextSource.fromString = function (text, defaultEOL) {
            return this.fromRawTextSource(RawTextSource.fromString(text), defaultEOL);
        };
        TextSource.create = function (source, defaultEOL) {
            if (typeof source === 'string') {
                return this.fromString(source, defaultEOL);
            }
            return this.fromRawTextSource(source, defaultEOL);
        };
        return TextSource;
    }());
    exports.TextSource = TextSource;
});

define(__m[34/*vs/editor/common/model/wordHelper*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    /**
     * Create a word definition regular expression based on default word separators.
     * Optionally provide allowed separators that should be included in words.
     *
     * The default would look like this:
     * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        var usualSeparators = exports.USUAL_WORD_SEPARATORS;
        var source = '(-?\\d*\\.\\d\\w*)|([^';
        for (var i = 0; i < usualSeparators.length; i++) {
            if (allowInWords.indexOf(usualSeparators[i]) >= 0) {
                continue;
            }
            source += '\\' + usualSeparators[i];
        }
        source += '\\s]+)';
        return new RegExp(source, 'g');
    }
    // catches numbers (including floating numbers) in the first group, and alphanum in the second
    exports.DEFAULT_WORD_REGEXP = createWordRegExp();
    function ensureValidWordDefinition(wordDefinition) {
        var result = exports.DEFAULT_WORD_REGEXP;
        if (wordDefinition && (wordDefinition instanceof RegExp)) {
            if (!wordDefinition.global) {
                var flags = 'g';
                if (wordDefinition.ignoreCase) {
                    flags += 'i';
                }
                if (wordDefinition.multiline) {
                    flags += 'm';
                }
                result = new RegExp(wordDefinition.source, flags);
            }
            else {
                result = wordDefinition;
            }
        }
        result.lastIndex = 0;
        return result;
    }
    exports.ensureValidWordDefinition = ensureValidWordDefinition;
    function getWordAtPosFast(column, wordDefinition, text, textOffset) {
        // find whitespace enclosed text around column and match from there
        var pos = column - 1 - textOffset;
        var start = text.lastIndexOf(' ', pos - 1) + 1;
        var end = text.indexOf(' ', pos);
        if (end === -1) {
            end = text.length;
        }
        wordDefinition.lastIndex = start;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index <= pos && wordDefinition.lastIndex >= pos) {
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
        // matches all words starting at the beginning
        // of the input until it finds a match that encloses
        // the desired column. slow but correct
        var pos = column - 1 - textOffset;
        wordDefinition.lastIndex = 0;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index > pos) {
                // |nW -> matched only after the pos
                return null;
            }
            else if (wordDefinition.lastIndex >= pos) {
                // W|W -> match encloses pos
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtText(column, wordDefinition, text, textOffset) {
        // if `words` can contain whitespace character we have to use the slow variant
        // otherwise we use the fast variant of finding a word
        wordDefinition.lastIndex = 0;
        var match = wordDefinition.exec(text);
        if (!match) {
            return null;
        }
        // todo@joh the `match` could already be the (first) word
        var ret = match[0].indexOf(' ') >= 0
            ? getWordAtPosSlow(column, wordDefinition, text, textOffset)
            : getWordAtPosFast(column, wordDefinition, text, textOffset);
        // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
        // in an undefined state and to not confuse other users of the wordDefinition
        // we reset the lastIndex
        wordDefinition.lastIndex = 0;
        return ret;
    }
    exports.getWordAtText = getWordAtText;
});

define(__m[24/*vs/editor/common/modes/languageConfiguration*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    var IndentAction;
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(IndentAction = exports.IndentAction || (exports.IndentAction = {}));
    /**
     * @internal
     */
    var StandardAutoClosingPairConditional = (function () {
        function StandardAutoClosingPairConditional(source) {
            this.open = source.open;
            this.close = source.close;
            // initially allowed in all tokens
            this._standardTokenMask = 0;
            if (Array.isArray(source.notIn)) {
                for (var i = 0, len = source.notIn.length; i < len; i++) {
                    var notIn = source.notIn[i];
                    switch (notIn) {
                        case 'string':
                            this._standardTokenMask |= 2 /* String */;
                            break;
                        case 'comment':
                            this._standardTokenMask |= 1 /* Comment */;
                            break;
                        case 'regex':
                            this._standardTokenMask |= 4 /* RegEx */;
                            break;
                    }
                }
            }
        }
        StandardAutoClosingPairConditional.prototype.isOK = function (standardToken) {
            return (this._standardTokenMask & standardToken) === 0;
        };
        return StandardAutoClosingPairConditional;
    }());
    exports.StandardAutoClosingPairConditional = StandardAutoClosingPairConditional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[41/*vs/editor/common/modes/languageSelector*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/glob*/]), function (require, exports, glob_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function matches(selection, uri, language) {
        return score(selection, uri, language) > 0;
    }
    exports.default = matches;
    function score(selector, candidateUri, candidateLanguage) {
        if (Array.isArray(selector)) {
            // array -> take max individual value
            var ret = 0;
            for (var _i = 0, selector_1 = selector; _i < selector_1.length; _i++) {
                var filter = selector_1[_i];
                var value = score(filter, candidateUri, candidateLanguage);
                if (value === 10) {
                    return value; // already at the highest
                }
                if (value > ret) {
                    ret = value;
                }
            }
            return ret;
        }
        else if (typeof selector === 'string') {
            // short-hand notion, desugars to
            // 'fooLang' -> [{ language: 'fooLang', scheme: 'file' }, { language: 'fooLang', scheme: 'untitled' }]
            // '*' -> { language: '*', scheme: '*' }
            if (selector === '*') {
                return 5;
            }
            else if (selector === candidateLanguage) {
                return 10;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            // filter -> select accordingly, use defaults for scheme
            var language = selector.language, pattern = selector.pattern, scheme = selector.scheme;
            var ret = 0;
            if (scheme) {
                if (scheme === candidateUri.scheme) {
                    ret = 10;
                }
                else if (scheme === '*') {
                    ret = 5;
                }
                else {
                    return 0;
                }
            }
            if (language) {
                if (language === candidateLanguage) {
                    ret = 10;
                }
                else if (language === '*') {
                    ret = Math.max(ret, 5);
                }
                else {
                    return 0;
                }
            }
            if (pattern) {
                if (pattern === candidateUri.fsPath || glob_1.match(pattern, candidateUri.fsPath)) {
                    ret = 10;
                }
                else {
                    return 0;
                }
            }
            return ret;
        }
        else {
            return 0;
        }
    }
    exports.score = score;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[131/*vs/editor/common/modes/languageFeatureRegistry*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,41/*vs/editor/common/modes/languageSelector*/]), function (require, exports, event_1, languageSelector_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LanguageFeatureRegistry = (function () {
        function LanguageFeatureRegistry() {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider) {
            var _this = this;
            var entry = {
                selector: selector,
                provider: provider,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return {
                dispose: function () {
                    if (entry) {
                        var idx = _this._entries.indexOf(entry);
                        if (idx >= 0) {
                            _this._entries.splice(idx, 1);
                            _this._lastCandidate = undefined;
                            _this._onDidChange.fire(_this._entries.length);
                            entry = undefined;
                        }
                    }
                }
            };
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model || model.isTooLargeForHavingARichMode()) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model || model.isTooLargeForHavingARichMode()) {
                return;
            }
            this._updateScores(model);
            for (var from = 0; from < this._entries.length; from++) {
                var entry = this._entries[from];
                if (entry._score > 0) {
                    callback(entry);
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.uri.toString(),
                language: model.getLanguageIdentifier().language
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.uri, model.getLanguageIdentifier().language);
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    exports.default = LanguageFeatureRegistry;
});

define(__m[134/*vs/editor/common/modes/supports/characterPair*/], __M([1/*require*/,0/*exports*/,24/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharacterPairSupport = (function () {
        function CharacterPairSupport(config) {
            if (config.autoClosingPairs) {
                this._autoClosingPairs = config.autoClosingPairs.map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            }
            else if (config.brackets) {
                this._autoClosingPairs = config.brackets.map(function (b) { return new languageConfiguration_1.StandardAutoClosingPairConditional({ open: b[0], close: b[1] }); });
            }
            else {
                this._autoClosingPairs = [];
            }
            this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
        }
        CharacterPairSupport.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs;
        };
        CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, column) {
            // Always complete on empty line
            if (context.getTokenCount() === 0) {
                return true;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 2);
            var standardTokenType = context.getStandardTokenType(tokenIndex);
            for (var i = 0; i < this._autoClosingPairs.length; ++i) {
                var autoClosingPair = this._autoClosingPairs[i];
                if (autoClosingPair.open === character) {
                    return autoClosingPair.isOK(standardTokenType);
                }
            }
            return true;
        };
        CharacterPairSupport.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs;
        };
        return CharacterPairSupport;
    }());
    exports.CharacterPairSupport = CharacterPairSupport;
});

define(__m[135/*vs/editor/common/modes/supports/indentRules*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/strings*/,24/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, strings, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var IndentConsts;
    (function (IndentConsts) {
        IndentConsts[IndentConsts["INCREASE_MASK"] = 1] = "INCREASE_MASK";
        IndentConsts[IndentConsts["DECREASE_MASK"] = 2] = "DECREASE_MASK";
        IndentConsts[IndentConsts["INDENT_NEXTLINE_MASK"] = 4] = "INDENT_NEXTLINE_MASK";
        IndentConsts[IndentConsts["UNINDENT_MASK"] = 8] = "UNINDENT_MASK";
    })(IndentConsts = exports.IndentConsts || (exports.IndentConsts = {}));
    ;
    var IndentRulesSupport = (function () {
        function IndentRulesSupport(indentationRules) {
            this._indentationRules = indentationRules;
        }
        IndentRulesSupport.prototype.onType = function (text) {
            if (this._indentationRules) {
                if (this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
                    return null;
                }
                if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(text)) {
                    return languageConfiguration_1.IndentAction.Outdent;
                }
            }
            return null;
        };
        IndentRulesSupport.prototype.containNonWhitespace = function (text) {
            // the text doesn't contain any non-whitespace character.
            var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(text);
            if (nonWhitespaceIdx >= 0) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldIncrease = function (text) {
            if (this._indentationRules) {
                if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(text)) {
                    return true;
                }
                // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
                // 	return true;
                // }
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldDecrease = function (text) {
            if (this._indentationRules && this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldIndentNextLine = function (text) {
            if (this._indentationRules && this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.shouldIgnore = function (text) {
            // the text matches `unIndentedLinePattern`
            if (this._indentationRules && this._indentationRules.unIndentedLinePattern && this._indentationRules.unIndentedLinePattern.test(text)) {
                return true;
            }
            return false;
        };
        IndentRulesSupport.prototype.getIndentMetadata = function (text) {
            var ret = 0;
            if (this.shouldIncrease(text)) {
                ret += 1 /* INCREASE_MASK */;
            }
            if (this.shouldDecrease(text)) {
                ret += 2 /* DECREASE_MASK */;
            }
            if (this.shouldIndentNextLine(text)) {
                ret += 4 /* INDENT_NEXTLINE_MASK */;
            }
            if (this.shouldIgnore(text)) {
                ret += 8 /* UNINDENT_MASK */;
            }
            return ret;
        };
        return IndentRulesSupport;
    }());
    exports.IndentRulesSupport = IndentRulesSupport;
});

define(__m[141/*vs/editor/common/modes/supports/onEnter*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/errors*/,8/*vs/base/common/strings*/,24/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, errors_1, strings, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var OnEnterSupport = (function () {
        function OnEnterSupport(opts) {
            opts = opts || {};
            opts.brackets = opts.brackets || [
                ['(', ')'],
                ['{', '}'],
                ['[', ']']
            ];
            this._brackets = opts.brackets.map(function (bracket) {
                return {
                    open: bracket[0],
                    openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                    close: bracket[1],
                    closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
                };
            });
            this._regExpRules = opts.regExpRules || [];
            this._indentationRules = opts.indentationRules;
        }
        OnEnterSupport.prototype.onEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
            // (1): `regExpRules`
            for (var i = 0, len = this._regExpRules.length; i < len; i++) {
                var rule = this._regExpRules[i];
                if (rule.beforeText.test(beforeEnterText)) {
                    if (rule.afterText) {
                        if (rule.afterText.test(afterEnterText)) {
                            return rule.action;
                        }
                    }
                    else {
                        return rule.action;
                    }
                }
            }
            // (2): Special indent-outdent
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return { indentAction: languageConfiguration_1.IndentAction.IndentOutdent };
                    }
                }
            }
            // (4): Open bracket based logic
            if (beforeEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return { indentAction: languageConfiguration_1.IndentAction.Indent };
                    }
                }
            }
            return null;
        };
        OnEnterSupport._createOpenBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(0))) {
                str = '\\b' + str;
            }
            str += '\\s*$';
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._createCloseBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(str.length - 1))) {
                str = str + '\\b';
            }
            str = '^\\s*' + str;
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._safeRegExp = function (def) {
            try {
                return new RegExp(def);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
                return null;
            }
        };
        return OnEnterSupport;
    }());
    exports.OnEnterSupport = OnEnterSupport;
});

define(__m[51/*vs/editor/common/modes/supports/richEditBrackets*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/strings*/,42/*vs/editor/common/core/range*/]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RichEditBracket = (function () {
        function RichEditBracket(languageIdentifier, open, close, forwardRegex, reversedRegex) {
            this.languageIdentifier = languageIdentifier;
            this.open = open;
            this.close = close;
            this.forwardRegex = forwardRegex;
            this.reversedRegex = reversedRegex;
        }
        return RichEditBracket;
    }());
    exports.RichEditBracket = RichEditBracket;
    var RichEditBrackets = (function () {
        function RichEditBrackets(languageIdentifier, brackets) {
            var _this = this;
            this.brackets = brackets.map(function (b) {
                return new RichEditBracket(languageIdentifier, b[0], b[1], getRegexForBracketPair({ open: b[0], close: b[1] }), getReversedRegexForBracketPair({ open: b[0], close: b[1] }));
            });
            this.forwardRegex = getRegexForBrackets(this.brackets);
            this.reversedRegex = getReversedRegexForBrackets(this.brackets);
            this.textIsBracket = {};
            this.textIsOpenBracket = {};
            var maxBracketLength = 0;
            this.brackets.forEach(function (b) {
                _this.textIsBracket[b.open.toLowerCase()] = b;
                _this.textIsBracket[b.close.toLowerCase()] = b;
                _this.textIsOpenBracket[b.open.toLowerCase()] = true;
                _this.textIsOpenBracket[b.close.toLowerCase()] = false;
                maxBracketLength = Math.max(maxBracketLength, b.open.length);
                maxBracketLength = Math.max(maxBracketLength, b.close.length);
            });
            this.maxBracketLength = maxBracketLength;
        }
        return RichEditBrackets;
    }());
    exports.RichEditBrackets = RichEditBrackets;
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createOrRegex([input.open, input.close]);
    });
    var getReversedRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createOrRegex([toReversedString(input.open), toReversedString(input.close)]);
    });
    var getRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(b.open);
            pieces.push(b.close);
        });
        return createOrRegex(pieces);
    });
    var getReversedRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(toReversedString(b.open));
            pieces.push(toReversedString(b.close));
        });
        return createOrRegex(pieces);
    });
    function createOrRegex(pieces) {
        var regexStr = "(" + pieces.map(strings.escapeRegExpCharacters).join(')|(') + ")";
        return strings.createRegExp(regexStr, true);
    }
    var toReversedString = (function () {
        function reverse(str) {
            var reversedStr = '';
            for (var i = str.length - 1; i >= 0; i--) {
                reversedStr += str.charAt(i);
            }
            return reversedStr;
        }
        var lastInput = null;
        var lastOutput = null;
        return function toReversedString(str) {
            if (lastInput !== str) {
                lastInput = str;
                lastOutput = reverse(lastInput);
            }
            return lastOutput;
        };
    })();
    var BracketsUtils = (function () {
        function BracketsUtils() {
        }
        BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
            var m = reversedText.match(reversedBracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = reversedText.length - m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
        };
        BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
            var reversedLineText = toReversedString(lineText);
            var reversedTokenText = reversedLineText.substring(lineText.length - currentTokenEnd, lineText.length - currentTokenStart);
            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedTokenText, currentTokenStart);
        };
        BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
            var m = text.match(bracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
        };
        BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
        };
        return BracketsUtils;
    }());
    exports.BracketsUtils = BracketsUtils;
});

define(__m[64/*vs/editor/common/modes/tokenizationRegistry*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/]), function (require, exports, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenizationRegistryImpl = (function () {
        function TokenizationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._map = Object.create(null);
            this._colorMap = null;
        }
        TokenizationRegistryImpl.prototype.fire = function (languages) {
            this._onDidChange.fire({
                changedLanguages: languages,
                changedColorMap: false
            });
        };
        TokenizationRegistryImpl.prototype.register = function (language, support) {
            var _this = this;
            this._map[language] = support;
            this.fire([language]);
            return {
                dispose: function () {
                    if (_this._map[language] !== support) {
                        return;
                    }
                    delete _this._map[language];
                    _this.fire([language]);
                }
            };
        };
        TokenizationRegistryImpl.prototype.get = function (language) {
            return (this._map[language] || null);
        };
        TokenizationRegistryImpl.prototype.setColorMap = function (colorMap) {
            this._colorMap = colorMap;
            this._onDidChange.fire({
                changedLanguages: Object.keys(this._map),
                changedColorMap: true
            });
        };
        TokenizationRegistryImpl.prototype.getColorMap = function () {
            return this._colorMap;
        };
        TokenizationRegistryImpl.prototype.getDefaultForeground = function () {
            return this._colorMap[1 /* DefaultForeground */];
        };
        TokenizationRegistryImpl.prototype.getDefaultBackground = function () {
            return this._colorMap[2 /* DefaultBackground */];
        };
        return TokenizationRegistryImpl;
    }());
    exports.TokenizationRegistryImpl = TokenizationRegistryImpl;
});

define(__m[38/*vs/editor/common/modes*/], __M([1/*require*/,0/*exports*/,131/*vs/editor/common/modes/languageFeatureRegistry*/,64/*vs/editor/common/modes/tokenizationRegistry*/]), function (require, exports, languageFeatureRegistry_1, tokenizationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Open ended enum at runtime
     * @internal
     */
    var LanguageId;
    (function (LanguageId) {
        LanguageId[LanguageId["Null"] = 0] = "Null";
        LanguageId[LanguageId["PlainText"] = 1] = "PlainText";
    })(LanguageId = exports.LanguageId || (exports.LanguageId = {}));
    /**
     * @internal
     */
    var LanguageIdentifier = (function () {
        function LanguageIdentifier(language, id) {
            this.language = language;
            this.id = id;
        }
        return LanguageIdentifier;
    }());
    exports.LanguageIdentifier = LanguageIdentifier;
    /**
     * A font style. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["NotSet"] = -1] = "NotSet";
        FontStyle[FontStyle["None"] = 0] = "None";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Bold"] = 2] = "Bold";
        FontStyle[FontStyle["Underline"] = 4] = "Underline";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * Open ended enum at runtime
     * @internal
     */
    var ColorId;
    (function (ColorId) {
        ColorId[ColorId["None"] = 0] = "None";
        ColorId[ColorId["DefaultForeground"] = 1] = "DefaultForeground";
        ColorId[ColorId["DefaultBackground"] = 2] = "DefaultBackground";
    })(ColorId = exports.ColorId || (exports.ColorId = {}));
    /**
     * A standard token type. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var StandardTokenType;
    (function (StandardTokenType) {
        StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
        StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
        StandardTokenType[StandardTokenType["String"] = 2] = "String";
        StandardTokenType[StandardTokenType["RegEx"] = 4] = "RegEx";
    })(StandardTokenType = exports.StandardTokenType || (exports.StandardTokenType = {}));
    /**
     * Helpers to manage the "collapsed" metadata of an entire StackElement stack.
     * The following assumptions have been made:
     *  - languageId < 256 => needs 8 bits
     *  - unique color count < 512 => needs 9 bits
     *
     * The binary format is:
     * - -------------------------------------------
     *     3322 2222 2222 1111 1111 1100 0000 0000
     *     1098 7654 3210 9876 5432 1098 7654 3210
     * - -------------------------------------------
     *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
     *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
     * - -------------------------------------------
     *  - L = LanguageId (8 bits)
     *  - T = StandardTokenType (3 bits)
     *  - F = FontStyle (3 bits)
     *  - f = foreground color (9 bits)
     *  - b = background color (9 bits)
     *
     * @internal
     */
    var MetadataConsts;
    (function (MetadataConsts) {
        MetadataConsts[MetadataConsts["LANGUAGEID_MASK"] = 255] = "LANGUAGEID_MASK";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_MASK"] = 1792] = "TOKEN_TYPE_MASK";
        MetadataConsts[MetadataConsts["FONT_STYLE_MASK"] = 14336] = "FONT_STYLE_MASK";
        MetadataConsts[MetadataConsts["FOREGROUND_MASK"] = 8372224] = "FOREGROUND_MASK";
        MetadataConsts[MetadataConsts["BACKGROUND_MASK"] = 4286578688] = "BACKGROUND_MASK";
        MetadataConsts[MetadataConsts["LANGUAGEID_OFFSET"] = 0] = "LANGUAGEID_OFFSET";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_OFFSET"] = 8] = "TOKEN_TYPE_OFFSET";
        MetadataConsts[MetadataConsts["FONT_STYLE_OFFSET"] = 11] = "FONT_STYLE_OFFSET";
        MetadataConsts[MetadataConsts["FOREGROUND_OFFSET"] = 14] = "FOREGROUND_OFFSET";
        MetadataConsts[MetadataConsts["BACKGROUND_OFFSET"] = 23] = "BACKGROUND_OFFSET";
    })(MetadataConsts = exports.MetadataConsts || (exports.MetadataConsts = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    /**
     * @internal
     */
    exports.symbolKindToCssClass = (function () {
        var _fromMapping = Object.create(null);
        _fromMapping[SymbolKind.File] = 'file';
        _fromMapping[SymbolKind.Module] = 'module';
        _fromMapping[SymbolKind.Namespace] = 'namespace';
        _fromMapping[SymbolKind.Package] = 'package';
        _fromMapping[SymbolKind.Class] = 'class';
        _fromMapping[SymbolKind.Method] = 'method';
        _fromMapping[SymbolKind.Property] = 'property';
        _fromMapping[SymbolKind.Field] = 'field';
        _fromMapping[SymbolKind.Constructor] = 'constructor';
        _fromMapping[SymbolKind.Enum] = 'enum';
        _fromMapping[SymbolKind.Interface] = 'interface';
        _fromMapping[SymbolKind.Function] = 'function';
        _fromMapping[SymbolKind.Variable] = 'variable';
        _fromMapping[SymbolKind.Constant] = 'constant';
        _fromMapping[SymbolKind.String] = 'string';
        _fromMapping[SymbolKind.Number] = 'number';
        _fromMapping[SymbolKind.Boolean] = 'boolean';
        _fromMapping[SymbolKind.Array] = 'array';
        _fromMapping[SymbolKind.Object] = 'object';
        _fromMapping[SymbolKind.Key] = 'key';
        _fromMapping[SymbolKind.Null] = 'null';
        _fromMapping[SymbolKind.EnumMember] = 'enum-member';
        _fromMapping[SymbolKind.Struct] = 'struct';
        _fromMapping[SymbolKind.Event] = 'event';
        _fromMapping[SymbolKind.Operator] = 'operator';
        _fromMapping[SymbolKind.TypeParameter] = 'type-parameter';
        return function toCssClassName(kind) {
            return _fromMapping[kind] || 'property';
        };
    })();
    // --- feature registries ------
    /**
     * @internal
     */
    exports.ReferenceProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.RenameProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SuggestRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SignatureHelpProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.HoverProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentSymbolProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentHighlightProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.ImplementationProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.TypeDefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeLensProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeActionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentRangeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.OnTypeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.LinkProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.ColorProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.TokenizationRegistry = new tokenizationRegistry_1.TokenizationRegistryImpl();
});

define(__m[40/*vs/editor/common/modes/supports*/], __M([1/*require*/,0/*exports*/,38/*vs/editor/common/modes*/]), function (require, exports, modes) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createScopedLineTokens(context, offset) {
        var tokenCount = context.getTokenCount();
        var tokenIndex = context.findTokenIndexAtOffset(offset);
        var desiredLanguageId = context.getLanguageId(tokenIndex);
        var lastTokenIndex = tokenIndex;
        while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
            lastTokenIndex++;
        }
        var firstTokenIndex = tokenIndex;
        while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
            firstTokenIndex--;
        }
        return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getTokenStartOffset(firstTokenIndex), context.getTokenEndOffset(lastTokenIndex));
    }
    exports.createScopedLineTokens = createScopedLineTokens;
    var ScopedLineTokens = (function () {
        function ScopedLineTokens(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
            this._actual = actual;
            this.languageId = languageId;
            this._firstTokenIndex = firstTokenIndex;
            this._lastTokenIndex = lastTokenIndex;
            this.firstCharOffset = firstCharOffset;
            this._lastCharOffset = lastCharOffset;
        }
        ScopedLineTokens.prototype.getLineContent = function () {
            var actualLineContent = this._actual.getLineContent();
            return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
        };
        ScopedLineTokens.prototype.getTokenCount = function () {
            return this._lastTokenIndex - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.getTokenStartOffset = function (tokenIndex) {
            return this._actual.getTokenStartOffset(tokenIndex + this._firstTokenIndex) - this.firstCharOffset;
        };
        ScopedLineTokens.prototype.getStandardTokenType = function (tokenIndex) {
            return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
        };
        return ScopedLineTokens;
    }());
    exports.ScopedLineTokens = ScopedLineTokens;
    var IgnoreBracketsInTokens;
    (function (IgnoreBracketsInTokens) {
        IgnoreBracketsInTokens[IgnoreBracketsInTokens["value"] = 7] = "value";
    })(IgnoreBracketsInTokens || (IgnoreBracketsInTokens = {}));
    function ignoreBracketsInToken(standardTokenType) {
        return (standardTokenType & 7 /* value */) !== 0;
    }
    exports.ignoreBracketsInToken = ignoreBracketsInToken;
});

define(__m[67/*vs/editor/common/modes/supports/electricCharacter*/], __M([1/*require*/,0/*exports*/,40/*vs/editor/common/modes/supports*/,51/*vs/editor/common/modes/supports/richEditBrackets*/,24/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, supports_1, richEditBrackets_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var BracketElectricCharacterSupport = (function () {
        function BracketElectricCharacterSupport(richEditBrackets, autoClosePairs, contribution) {
            contribution = contribution || {};
            this._richEditBrackets = richEditBrackets;
            this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; }).map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            if (contribution.docComment) {
                // IDocComment is legacy, only partially supported
                this._complexAutoClosePairs.push(new languageConfiguration_1.StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close }));
            }
        }
        BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
            var result = [];
            if (this._richEditBrackets) {
                for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                    var bracketPair = this._richEditBrackets.brackets[i];
                    var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                    result.push(lastChar);
                }
            }
            // auto close
            for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {
                var pair = _a[_i];
                result.push(pair.open.charAt(pair.open.length - 1));
            }
            // Filter duplicate entries
            result = result.filter(function (item, pos, array) {
                return array.indexOf(item) === pos;
            });
            return result;
        };
        BracketElectricCharacterSupport.prototype.onElectricCharacter = function (character, context, column) {
            return (this._onElectricAutoClose(character, context, column) ||
                this._onElectricAutoIndent(character, context, column));
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoIndent = function (character, context, column) {
            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
                return null;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 1);
            if (supports_1.ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
                return null;
            }
            var reversedBracketRegex = this._richEditBrackets.reversedRegex;
            var text = context.getLineContent().substring(0, column - 1) + character;
            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);
            if (!r) {
                return null;
            }
            var bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);
            bracketText = bracketText.toLowerCase();
            var isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
            if (isOpen) {
                return null;
            }
            var textBeforeBracket = text.substring(0, r.startColumn - 1);
            if (!/^\s*$/.test(textBeforeBracket)) {
                // There is other text on the line before the bracket
                return null;
            }
            return {
                matchOpenBracket: bracketText
            };
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoClose = function (character, context, column) {
            if (!this._complexAutoClosePairs.length) {
                return null;
            }
            var line = context.getLineContent();
            for (var i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {
                var pair = this._complexAutoClosePairs[i];
                // See if the right electric character was pressed
                if (character !== pair.open.charAt(pair.open.length - 1)) {
                    continue;
                }
                // check if the full open bracket matches
                var actual = line.substring(line.length - pair.open.length + 1) + character;
                if (actual !== pair.open) {
                    continue;
                }
                var lastTokenIndex = context.findTokenIndexAtOffset(column - 1);
                var lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);
                // If we're in a scope listed in 'notIn', do nothing
                if (!pair.isOK(lastTokenStandardType)) {
                    continue;
                }
                // If this line already contains the closing tag, do nothing.
                if (line.indexOf(pair.close, column - 1) >= 0) {
                    continue;
                }
                return { appendText: pair.close };
            }
            return null;
        };
        return BracketElectricCharacterSupport;
    }());
    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
});

define(__m[68/*vs/editor/common/modes/languageConfigurationRegistry*/], __M([1/*require*/,0/*exports*/,134/*vs/editor/common/modes/supports/characterPair*/,67/*vs/editor/common/modes/supports/electricCharacter*/,141/*vs/editor/common/modes/supports/onEnter*/,135/*vs/editor/common/modes/supports/indentRules*/,51/*vs/editor/common/modes/supports/richEditBrackets*/,3/*vs/base/common/event*/,12/*vs/base/common/errors*/,8/*vs/base/common/strings*/,34/*vs/editor/common/model/wordHelper*/,40/*vs/editor/common/modes/supports*/,42/*vs/editor/common/core/range*/,24/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, characterPair_1, electricCharacter_1, onEnter_1, indentRules_1, richEditBrackets_1, event_1, errors_1, strings, wordHelper_1, supports_1, range_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RichEditSupport = (function () {
        function RichEditSupport(languageIdentifier, previous, rawConf) {
            var prev = null;
            if (previous) {
                prev = previous._conf;
            }
            this._conf = RichEditSupport._mergeConf(prev, rawConf);
            if (this._conf.brackets) {
                this.brackets = new richEditBrackets_1.RichEditBrackets(languageIdentifier, this._conf.brackets);
            }
            this.onEnter = RichEditSupport._handleOnEnter(this._conf);
            this.comments = RichEditSupport._handleComments(this._conf);
            this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);
            this.electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, this.characterPair.getAutoClosingPairs(), this._conf.__electricCharacterSupport);
            this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;
            this.indentationRules = this._conf.indentationRules;
            if (this._conf.indentationRules) {
                this.indentRulesSupport = new indentRules_1.IndentRulesSupport(this._conf.indentationRules);
            }
        }
        RichEditSupport._mergeConf = function (prev, current) {
            return {
                comments: (prev ? current.comments || prev.comments : current.comments),
                brackets: (prev ? current.brackets || prev.brackets : current.brackets),
                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
                autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
                surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
            };
        };
        RichEditSupport._handleOnEnter = function (conf) {
            // on enter
            var onEnter = {};
            var empty = true;
            if (conf.brackets) {
                empty = false;
                onEnter.brackets = conf.brackets;
            }
            if (conf.indentationRules) {
                empty = false;
                onEnter.indentationRules = conf.indentationRules;
            }
            if (conf.onEnterRules) {
                empty = false;
                onEnter.regExpRules = conf.onEnterRules;
            }
            if (!empty) {
                return new onEnter_1.OnEnterSupport(onEnter);
            }
            return null;
        };
        RichEditSupport._handleComments = function (conf) {
            var commentRule = conf.comments;
            if (!commentRule) {
                return null;
            }
            // comment configuration
            var comments = {};
            if (commentRule.lineComment) {
                comments.lineCommentToken = commentRule.lineComment;
            }
            if (commentRule.blockComment) {
                var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
                comments.blockCommentStartToken = blockStart;
                comments.blockCommentEndToken = blockEnd;
            }
            return comments;
        };
        return RichEditSupport;
    }());
    exports.RichEditSupport = RichEditSupport;
    var LanguageConfigurationRegistryImpl = (function () {
        function LanguageConfigurationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._entries = [];
        }
        LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {
            var _this = this;
            var previous = this._getRichEditSupport(languageIdentifier.id);
            var current = new RichEditSupport(languageIdentifier, previous, configuration);
            this._entries[languageIdentifier.id] = current;
            this._onDidChange.fire(void 0);
            return {
                dispose: function () {
                    if (_this._entries[languageIdentifier.id] === current) {
                        _this._entries[languageIdentifier.id] = previous;
                        _this._onDidChange.fire(void 0);
                    }
                }
            };
        };
        LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {
            return this._entries[languageId] || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentationRules = function (languageId) {
            var value = this._entries[languageId];
            if (!value) {
                return null;
            }
            return value.indentationRules || null;
        };
        // begin electricCharacter
        LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.electricCharacter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {
            var electricCharacterSupport = this._getElectricCharacterSupport(languageId);
            if (!electricCharacterSupport) {
                return [];
            }
            return electricCharacterSupport.getElectricCharacters();
        };
        /**
         * Should return opening bracket type to match indentation with
         */
        LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
            if (!electricCharacterSupport) {
                return null;
            }
            return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end electricCharacter
        LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.comments || null;
        };
        // begin characterPair
        LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.characterPair || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getAutoClosingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getSurroundingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);
            if (!characterPairSupport) {
                return false;
            }
            return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end characterPair
        LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return wordHelper_1.ensureValidWordDefinition(null);
            }
            return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);
        };
        // beigin Indent Rules
        LanguageConfigurationRegistryImpl.prototype.getIndentRulesSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.indentRulesSupport || null;
        };
        /**
         * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
         * Result:
         * -1: run into the boundary of embedded languages
         * 0: every line above are invalid
         * else: nearest preceding line of the same language
         */
        LanguageConfigurationRegistryImpl.prototype.getPrecedingValidLine = function (model, lineNumber, indentRulesSupport) {
            var languageID = model.getLanguageIdAtPosition(lineNumber, 0);
            if (lineNumber > 1) {
                var lastLineNumber = lineNumber - 1;
                var resultLineNumber = -1;
                for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                    if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {
                        return resultLineNumber;
                    }
                    var text = model.getLineContent(lastLineNumber);
                    if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === '') {
                        resultLineNumber = lastLineNumber;
                        continue;
                    }
                    return lastLineNumber;
                }
            }
            return -1;
        };
        /**
         * Get inherited indentation from above lines.
         * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
         * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
         * 3. If this line doesn't match any indent rules
         *   a. check whether the line above it matches indentNextLinePattern
         *   b. If not, the indent level of this line is the result
         *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
         * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
         *
         * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
         */
        LanguageConfigurationRegistryImpl.prototype.getInheritIndentForLine = function (model, lineNumber, honorIntentialIndent) {
            if (honorIntentialIndent === void 0) { honorIntentialIndent = true; }
            var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
            if (!indentRulesSupport) {
                return null;
            }
            if (lineNumber <= 1) {
                return {
                    indentation: '',
                    action: null
                };
            }
            var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);
            if (precedingUnIgnoredLine < 0) {
                return null;
            }
            else if (precedingUnIgnoredLine < 1) {
                return {
                    indentation: '',
                    action: null
                };
            }
            var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
            if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
                return {
                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),
                    action: languageConfiguration_1.IndentAction.Indent,
                    line: precedingUnIgnoredLine
                };
            }
            else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
                return {
                    indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),
                    action: null,
                    line: precedingUnIgnoredLine
                };
            }
            else {
                // precedingUnIgnoredLine can not be ignored.
                // it doesn't increase indent of following lines
                // it doesn't increase just next line
                // so current line is not affect by precedingUnIgnoredLine
                // and then we should get a correct inheritted indentation from above lines
                if (precedingUnIgnoredLine === 1) {
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                        action: null,
                        line: precedingUnIgnoredLine
                    };
                }
                var previousLine = precedingUnIgnoredLine - 1;
                var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
                if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&
                    (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {
                    var stopLine = 0;
                    for (var i = previousLine - 1; i > 0; i--) {
                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                            continue;
                        }
                        stopLine = i;
                        break;
                    }
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                        action: null,
                        line: stopLine + 1
                    };
                }
                if (honorIntentialIndent) {
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                        action: null,
                        line: precedingUnIgnoredLine
                    };
                }
                else {
                    // search from precedingUnIgnoredLine until we find one whose indent is not temporary
                    for (var i = precedingUnIgnoredLine; i > 0; i--) {
                        var lineContent = model.getLineContent(i);
                        if (indentRulesSupport.shouldIncrease(lineContent)) {
                            return {
                                indentation: strings.getLeadingWhitespace(lineContent),
                                action: languageConfiguration_1.IndentAction.Indent,
                                line: i
                            };
                        }
                        else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
                            var stopLine = 0;
                            for (var j = i - 1; j > 0; j--) {
                                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                                    continue;
                                }
                                stopLine = j;
                                break;
                            }
                            return {
                                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                                action: null,
                                line: stopLine + 1
                            };
                        }
                        else if (indentRulesSupport.shouldDecrease(lineContent)) {
                            return {
                                indentation: strings.getLeadingWhitespace(lineContent),
                                action: null,
                                line: i
                            };
                        }
                    }
                    return {
                        indentation: strings.getLeadingWhitespace(model.getLineContent(1)),
                        action: null,
                        line: 1
                    };
                }
            }
        };
        LanguageConfigurationRegistryImpl.prototype.getGoodIndentForLine = function (virtualModel, languageId, lineNumber, indentConverter) {
            var indentRulesSupport = this.getIndentRulesSupport(languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var indent = this.getInheritIndentForLine(virtualModel, lineNumber);
            var lineContent = virtualModel.getLineContent(lineNumber);
            if (indent) {
                var inheritLine = indent.line;
                if (inheritLine !== undefined) {
                    var onEnterSupport = this._getOnEnterSupport(languageId);
                    var enterResult = null;
                    try {
                        enterResult = onEnterSupport.onEnter('', virtualModel.getLineContent(inheritLine), '');
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                    if (enterResult) {
                        var indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
                        if (enterResult.removeText) {
                            indentation = indentation.substring(0, indentation.length - enterResult.removeText);
                        }
                        if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                            (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                            indentation = indentConverter.shiftIndent(indentation);
                        }
                        else if (enterResult.indentAction === languageConfiguration_1.IndentAction.Outdent) {
                            indentation = indentConverter.unshiftIndent(indentation);
                        }
                        if (indentRulesSupport.shouldDecrease(lineContent)) {
                            indentation = indentConverter.unshiftIndent(indentation);
                        }
                        if (enterResult.appendText) {
                            indentation += enterResult.appendText;
                        }
                        return strings.getLeadingWhitespace(indentation);
                    }
                }
                if (indentRulesSupport.shouldDecrease(lineContent)) {
                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {
                        return indent.indentation;
                    }
                    else {
                        return indentConverter.unshiftIndent(indent.indentation);
                    }
                }
                else {
                    if (indent.action === languageConfiguration_1.IndentAction.Indent) {
                        return indentConverter.shiftIndent(indent.indentation);
                    }
                    else {
                        return indent.indentation;
                    }
                }
            }
            return null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentForEnter = function (model, range, indentConverter, autoIndent) {
            model.forceTokenization(range.startLineNumber);
            var lineTokens = model.getLineTokens(range.startLineNumber);
            var beforeEnterText;
            var afterEnterText;
            var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, range.startColumn - 1);
            var scopedLineText = scopedLineTokens.getLineContent();
            var embeddedLanguage = false;
            if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
                // we are in the embeded language content
                embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line
                beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
            }
            if (range.isEmpty()) {
                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var beforeEnterResult = beforeEnterText;
            var beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);
            if (!autoIndent && !embeddedLanguage) {
                var beforeEnterIndentAction = this.getInheritIndentForLine(model, range.startLineNumber);
                if (indentRulesSupport.shouldDecrease(beforeEnterText)) {
                    if (beforeEnterIndentAction) {
                        beforeEnterIndent = beforeEnterIndentAction.indentation;
                        if (beforeEnterIndentAction.action !== languageConfiguration_1.IndentAction.Indent) {
                            beforeEnterIndent = indentConverter.unshiftIndent(beforeEnterIndent);
                        }
                    }
                }
                beforeEnterResult = beforeEnterIndent + strings.ltrim(strings.ltrim(beforeEnterText, ' '), '\t');
            }
            var virtualModel = {
                getLineTokens: function (lineNumber) {
                    return model.getLineTokens(lineNumber);
                },
                getLanguageIdentifier: function () {
                    return model.getLanguageIdentifier();
                },
                getLanguageIdAtPosition: function (lineNumber, column) {
                    return model.getLanguageIdAtPosition(lineNumber, column);
                },
                getLineContent: function (lineNumber) {
                    if (lineNumber === range.startLineNumber) {
                        return beforeEnterResult;
                    }
                    else {
                        return model.getLineContent(lineNumber);
                    }
                }
            };
            var currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());
            var afterEnterAction = this.getInheritIndentForLine(virtualModel, range.startLineNumber + 1);
            if (!afterEnterAction) {
                var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
                return {
                    beforeEnter: beforeEnter,
                    afterEnter: beforeEnter
                };
            }
            var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
            if (afterEnterAction.action === languageConfiguration_1.IndentAction.Indent) {
                afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
            }
            if (indentRulesSupport.shouldDecrease(afterEnterText)) {
                afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
            }
            return {
                beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
                afterEnter: afterEnterIndent
            };
        };
        /**
         * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
         * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
         */
        LanguageConfigurationRegistryImpl.prototype.getIndentActionForType = function (model, range, ch, indentConverter) {
            var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
            var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
            if (!indentRulesSupport) {
                return null;
            }
            var scopedLineText = scopedLineTokens.getLineContent();
            var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            var afterTypeText;
            // selection support
            if (range.isEmpty()) {
                afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted
            // Users might change the indentation by purpose and we should honor that instead of readjusting.
            if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
                // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.
                // 1. Get inherited indent action
                var r = this.getInheritIndentForLine(model, range.startLineNumber, false);
                if (!r) {
                    return null;
                }
                var indentation = r.indentation;
                if (r.action !== languageConfiguration_1.IndentAction.Indent) {
                    indentation = indentConverter.unshiftIndent(indentation);
                }
                return indentation;
            }
            return null;
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentMetadata = function (model, lineNumber) {
            var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);
            if (!indentRulesSupport) {
                return null;
            }
            if (lineNumber < 1 || lineNumber > model.getLineCount()) {
                return null;
            }
            return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
        };
        // end Indent Rules
        // begin onEnter
        LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.onEnter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
            var r = this.getEnterAction(model, new range_1.Range(lineNumber, column, lineNumber, column));
            return r ? r.enterAction : null;
        };
        LanguageConfigurationRegistryImpl.prototype.getEnterAction = function (model, range) {
            var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
            var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
            var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);
            if (!onEnterSupport) {
                return null;
            }
            var scopedLineText = scopedLineTokens.getLineContent();
            var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            var afterEnterText;
            // selection support
            if (range.isEmpty()) {
                afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            else {
                var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);
                afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
            }
            var lineNumber = range.startLineNumber;
            var oneLineAboveText = '';
            if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
                // This is not the first line and the entire line belongs to this mode
                var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, lineNumber - 1);
                if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
                    // The line above ends with text belonging to the same mode
                    oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
                }
            }
            var enterResult = null;
            try {
                enterResult = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!enterResult) {
                return null;
            }
            else {
                // Here we add `\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.
                if (!enterResult.appendText) {
                    if ((enterResult.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                        (enterResult.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                        enterResult.appendText = '\t';
                    }
                    else {
                        enterResult.appendText = '';
                    }
                }
            }
            if (enterResult.removeText) {
                indentation = indentation.substring(0, indentation.length - enterResult.removeText);
            }
            return {
                enterAction: enterResult,
                indentation: indentation,
            };
        };
        LanguageConfigurationRegistryImpl.prototype.getIndentationAtPosition = function (model, lineNumber, column) {
            var lineText = model.getLineContent(lineNumber);
            var indentation = strings.getLeadingWhitespace(lineText);
            if (indentation.length > column - 1) {
                indentation = indentation.substring(0, column - 1);
            }
            return indentation;
        };
        LanguageConfigurationRegistryImpl.prototype.getScopedLineTokens = function (model, lineNumber, columnNumber) {
            model.forceTokenization(lineNumber);
            var lineTokens = model.getLineTokens(lineNumber);
            var column = isNaN(columnNumber) ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;
            var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column);
            return scopedLineTokens;
        };
        // end onEnter
        LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.brackets || null;
        };
        return LanguageConfigurationRegistryImpl;
    }());
    exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;
    exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
});

define(__m[69/*vs/editor/common/viewModel/prefixSumComputer*/], __M([1/*require*/,0/*exports*/,107/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var PrefixSumIndexOfResult = (function () {
        function PrefixSumIndexOfResult(index, remainder) {
            this.index = index;
            this.remainder = remainder;
        }
        return PrefixSumIndexOfResult;
    }());
    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
    var PrefixSumComputer = (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = new Uint32Array(values.length);
            this.prefixSumValidIndex = new Int32Array(1);
            this.prefixSumValidIndex[0] = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {
            insertIndex = uint_1.toUint32(insertIndex);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            var insertValuesLen = insertValues.length;
            if (insertValuesLen === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length + insertValuesLen);
            this.values.set(oldValues.subarray(0, insertIndex), 0);
            this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
            this.values.set(insertValues, insertIndex);
            if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = insertIndex - 1;
            }
            this.prefixSum = new Uint32Array(this.values.length);
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            index = uint_1.toUint32(index);
            value = uint_1.toUint32(value);
            if (this.values[index] === value) {
                return false;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = index - 1;
            }
            return true;
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            startIndex = uint_1.toUint32(startIndex);
            cnt = uint_1.toUint32(cnt);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            if (startIndex >= oldValues.length) {
                return false;
            }
            var maxCnt = oldValues.length - startIndex;
            if (cnt >= maxCnt) {
                cnt = maxCnt;
            }
            if (cnt === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length - cnt);
            this.values.set(oldValues.subarray(0, startIndex), 0);
            this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
            this.prefixSum = new Uint32Array(this.values.length);
            if (startIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = startIndex - 1;
            }
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this._getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            if (index < 0) {
                return 0;
            }
            index = uint_1.toUint32(index);
            return this._getAccumulatedValue(index);
        };
        PrefixSumComputer.prototype._getAccumulatedValue = function (index) {
            if (index <= this.prefixSumValidIndex[0]) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex[0] + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            // Compute all sums (to get a fully valid prefixSum)
            this.getTotalValue();
            var low = 0;
            var high = this.values.length - 1;
            var mid;
            var midStop;
            var midStart;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.prefixSum[mid];
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
    var PrefixSumComputerWithCache = (function () {
        function PrefixSumComputerWithCache(values) {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
            this._actual = new PrefixSumComputer(values);
            this._bustCache();
        }
        PrefixSumComputerWithCache.prototype._bustCache = function () {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
        };
        PrefixSumComputerWithCache.prototype.getCount = function () {
            return this._actual.getCount();
        };
        PrefixSumComputerWithCache.prototype.insertValues = function (insertIndex, insertValues) {
            if (this._actual.insertValues(insertIndex, insertValues)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.changeValue = function (index, value) {
            if (this._actual.changeValue(index, value)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.removeValues = function (startIndex, cnt) {
            if (this._actual.removeValues(startIndex, cnt)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.getTotalValue = function () {
            return this._actual.getTotalValue();
        };
        PrefixSumComputerWithCache.prototype.getAccumulatedValue = function (index) {
            return this._actual.getAccumulatedValue(index);
        };
        PrefixSumComputerWithCache.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            if (this._cache !== null) {
                var cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;
                if (cacheIndex >= 0 && cacheIndex < this._cache.length) {
                    // Cache hit!
                    return this._cache[cacheIndex];
                }
            }
            // Cache miss!
            return this._actual.getIndexOf(accumulatedValue);
        };
        /**
         * Gives a hint that a lot of requests are about to come in for these accumulated values.
         */
        PrefixSumComputerWithCache.prototype.warmUpCache = function (accumulatedValueStart, accumulatedValueEnd) {
            var newCache = [];
            for (var accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {
                newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);
            }
            this._cache = newCache;
            this._cacheAccumulatedValueStart = accumulatedValueStart;
        };
        return PrefixSumComputerWithCache;
    }());
    exports.PrefixSumComputerWithCache = PrefixSumComputerWithCache;
});

define(__m[70/*vs/editor/common/model/mirrorModel*/], __M([1/*require*/,0/*exports*/,69/*vs/editor/common/viewModel/prefixSumComputer*/]), function (require, exports, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MirrorModel = (function () {
        function MirrorModel(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
        }
        MirrorModel.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorModel.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorModel.prototype.onEvents = function (e) {
            if (e.eol && e.eol !== this._eol) {
                this._eol = e.eol;
                this._lineStarts = null;
            }
            // Update my lines
            var changes = e.changes;
            for (var i = 0, len = changes.length; i < len; i++) {
                var change = changes[i];
                this._acceptDeleteRange(change.range);
                this._acceptInsertText({
                    lineNumber: change.range.startLineNumber,
                    column: change.range.startColumn
                }, change.text);
            }
            this._versionId = e.versionId;
        };
        MirrorModel.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var eolLength = this._eol.length;
                var linesLength = this._lines.length;
                var lineStartValues = new Uint32Array(linesLength);
                for (var i = 0; i < linesLength; i++) {
                    lineStartValues[i] = this._lines[i].length + eolLength;
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorModel.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorModel.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorModel.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Uint32Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorModel;
    }());
    exports.MirrorModel = MirrorModel;
});

define(__m[71/*vs/nls!vs/base/common/processes*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/processes", data); });










define(__m[74/*vs/base/common/processes*/], __M([1/*require*/,0/*exports*/,71/*vs/nls!vs/base/common/processes*/,11/*vs/base/common/objects*/,9/*vs/base/common/platform*/,14/*vs/base/common/types*/,92/*vs/base/common/parsers*/]), function (require, exports, NLS, Objects, Platform, Types, parsers_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Source;
    (function (Source) {
        Source[Source["stdout"] = 0] = "stdout";
        Source[Source["stderr"] = 1] = "stderr";
    })(Source = exports.Source || (exports.Source = {}));
    var TerminateResponseCode;
    (function (TerminateResponseCode) {
        TerminateResponseCode[TerminateResponseCode["Success"] = 0] = "Success";
        TerminateResponseCode[TerminateResponseCode["Unknown"] = 1] = "Unknown";
        TerminateResponseCode[TerminateResponseCode["AccessDenied"] = 2] = "AccessDenied";
        TerminateResponseCode[TerminateResponseCode["ProcessNotFound"] = 3] = "ProcessNotFound";
    })(TerminateResponseCode = exports.TerminateResponseCode || (exports.TerminateResponseCode = {}));
    var ExecutableParser = (function (_super) {
        __extends(ExecutableParser, _super);
        function ExecutableParser(logger) {
            return _super.call(this, logger) || this;
        }
        ExecutableParser.prototype.parse = function (json, parserOptions) {
            if (parserOptions === void 0) { parserOptions = { globals: null, emptyCommand: false, noDefaults: false }; }
            var result = this.parseExecutable(json, parserOptions.globals);
            if (this.problemReporter.status.isFatal()) {
                return result;
            }
            var osExecutable;
            if (json.windows && Platform.platform === Platform.Platform.Windows) {
                osExecutable = this.parseExecutable(json.windows);
            }
            else if (json.osx && Platform.platform === Platform.Platform.Mac) {
                osExecutable = this.parseExecutable(json.osx);
            }
            else if (json.linux && Platform.platform === Platform.Platform.Linux) {
                osExecutable = this.parseExecutable(json.linux);
            }
            if (osExecutable) {
                result = ExecutableParser.mergeExecutable(result, osExecutable);
            }
            if ((!result || !result.command) && !parserOptions.emptyCommand) {
                this.fatal(NLS.localize(0, null));
                return null;
            }
            if (!parserOptions.noDefaults) {
                parsers_1.Parser.merge(result, {
                    command: undefined,
                    isShellCommand: false,
                    args: [],
                    options: {}
                }, false);
            }
            return result;
        };
        ExecutableParser.prototype.parseExecutable = function (json, globals) {
            var command = undefined;
            var isShellCommand = undefined;
            var args = undefined;
            var options = undefined;
            if (this.is(json.command, Types.isString)) {
                command = json.command;
            }
            if (this.is(json.isShellCommand, Types.isBoolean, parsers_1.ValidationState.Warning, NLS.localize(1, null, json.isShellCommand))) {
                isShellCommand = json.isShellCommand;
            }
            if (this.is(json.args, Types.isStringArray, parsers_1.ValidationState.Warning, NLS.localize(2, null, json.isShellCommand))) {
                args = json.args.slice(0);
            }
            if (this.is(json.options, Types.isObject)) {
                options = this.parseCommandOptions(json.options);
            }
            return { command: command, isShellCommand: isShellCommand, args: args, options: options };
        };
        ExecutableParser.prototype.parseCommandOptions = function (json) {
            var result = {};
            if (!json) {
                return result;
            }
            if (this.is(json.cwd, Types.isString, parsers_1.ValidationState.Warning, NLS.localize(3, null, json.cwd))) {
                result.cwd = json.cwd;
            }
            if (!Types.isUndefined(json.env)) {
                result.env = Objects.clone(json.env);
            }
            return result;
        };
        ExecutableParser.mergeExecutable = function (executable, other) {
            if (!executable) {
                return other;
            }
            parsers_1.Parser.merge(executable, other, true);
            return executable;
        };
        return ExecutableParser;
    }(parsers_1.Parser));
    exports.ExecutableParser = ExecutableParser;
});

define(__m[75/*vs/nls!vs/base/common/severity*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
define(__m[25/*vs/base/common/severity*/], __M([1/*require*/,0/*exports*/,75/*vs/nls!vs/base/common/severity*/,8/*vs/base/common/strings*/]), function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        var _error = 'error', _warning = 'warning', _warn = 'warn', _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
        function toString(value) {
            return _displayStrings[value] || strings.empty;
        }
        Severity.toString = toString;
        function compare(a, b) {
            return b - a;
        }
        Severity.compare = compare;
    })(Severity || (Severity = {}));
    exports.default = Severity;
});

define(__m[77/*vs/nls!vs/base/node/processes*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/node/processes", data); });










define(__m[78/*vs/base/node/processes*/], __M([1/*require*/,0/*exports*/,20/*path*/,43/*child_process*/,166/*stream*/,91/*vs/base/node/stdFork*/,77/*vs/nls!vs/base/node/processes*/,2/*vs/base/common/winjs.base*/,14/*vs/base/common/types*/,6/*vs/base/common/uri*/,11/*vs/base/common/objects*/,13/*vs/base/common/paths*/,9/*vs/base/common/platform*/,127/*vs/base/node/decoder*/,74/*vs/base/common/processes*/]), function (require, exports, path, cp, stream_1, stdFork_1, nls, winjs_base_1, Types, uri_1, Objects, TPath, Platform, decoder_1, processes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var exec = cp.exec;
    var spawn = cp.spawn;
    exports.Source = processes_1.Source;
    exports.TerminateResponseCode = processes_1.TerminateResponseCode;
    function getWindowsCode(status) {
        switch (status) {
            case 0:
                return processes_1.TerminateResponseCode.Success;
            case 1:
                return processes_1.TerminateResponseCode.AccessDenied;
            case 128:
                return processes_1.TerminateResponseCode.ProcessNotFound;
            default:
                return processes_1.TerminateResponseCode.Unknown;
        }
    }
    function terminateProcess(process, cwd) {
        if (Platform.isWindows) {
            try {
                var options = {
                    stdio: ['pipe', 'pipe', 'ignore']
                };
                if (cwd) {
                    options.cwd = cwd;
                }
                cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            }
            catch (err) {
                return { success: false, error: err, code: err.status ? getWindowsCode(err.status) : processes_1.TerminateResponseCode.Unknown };
            }
        }
        else if (Platform.isLinux || Platform.isMacintosh) {
            try {
                var cmd = uri_1.default.parse(require.toUrl('vs/base/node/terminateProcess.sh')).fsPath;
                var result = cp.spawnSync(cmd, [process.pid.toString()]);
                if (result.error) {
                    return { success: false, error: result.error };
                }
            }
            catch (err) {
                return { success: false, error: err };
            }
        }
        else {
            process.kill('SIGKILL');
        }
        return { success: true };
    }
    exports.terminateProcess = terminateProcess;
    function getWindowsShell() {
        return process.env['comspec'] || 'cmd.exe';
    }
    exports.getWindowsShell = getWindowsShell;
    var AbstractProcess = (function () {
        function AbstractProcess(arg1, arg2, arg3, arg4) {
            var _this = this;
            if (arg4) {
                this.cmd = arg1;
                this.args = arg2;
                this.shell = arg3;
                this.options = arg4;
            }
            else if (arg3 && arg2) {
                this.module = arg1;
                this.args = arg2;
                this.shell = false;
                this.options = arg3;
            }
            else {
                var executable = arg1;
                this.cmd = executable.command;
                this.shell = executable.isShellCommand;
                this.args = executable.args.slice(0);
                this.options = executable.options || {};
            }
            this.childProcess = null;
            this.terminateRequested = false;
            if (this.options.env) {
                var newEnv_1 = Object.create(null);
                Object.keys(process.env).forEach(function (key) {
                    newEnv_1[key] = process.env[key];
                });
                Object.keys(this.options.env).forEach(function (key) {
                    newEnv_1[key] = _this.options.env[key];
                });
                this.options.env = newEnv_1;
            }
        }
        AbstractProcess.prototype.getSanitizedCommand = function () {
            var result = this.cmd.toLowerCase();
            var index = result.lastIndexOf(path.sep);
            if (index !== -1) {
                result = result.substring(index + 1);
            }
            if (AbstractProcess.WellKnowCommands[result]) {
                return result;
            }
            return 'other';
        };
        AbstractProcess.prototype.start = function () {
            var _this = this;
            if (Platform.isWindows && ((this.options && this.options.cwd && TPath.isUNC(this.options.cwd)) || !this.options && !this.options.cwd && TPath.isUNC(process.cwd()))) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize(0, null)));
            }
            return this.useExec().then(function (useExec) {
                var cc;
                var ee;
                var pp;
                var result = new winjs_base_1.PPromise(function (c, e, p) {
                    cc = c;
                    ee = e;
                    pp = p;
                });
                if (useExec) {
                    var cmd = _this.cmd;
                    if (_this.args) {
                        cmd = cmd + ' ' + _this.args.join(' ');
                    }
                    _this.childProcess = exec(cmd, _this.options, function (error, stdout, stderr) {
                        _this.childProcess = null;
                        var err = error;
                        // This is tricky since executing a command shell reports error back in case the executed command return an
                        // error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we
                        // always parse the output and report success unless the job got killed.
                        if (err && err.killed) {
                            ee({ killed: _this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });
                        }
                        else {
                            _this.handleExec(cc, pp, error, stdout, stderr);
                        }
                    });
                }
                else {
                    var childProcess = null;
                    var closeHandler_1 = function (data) {
                        _this.childProcess = null;
                        _this.childProcessPromise = null;
                        _this.handleClose(data, cc, pp, ee);
                        var result = {
                            terminated: _this.terminateRequested
                        };
                        if (Types.isNumber(data)) {
                            result.cmdCode = data;
                        }
                        cc(result);
                    };
                    if (_this.shell && Platform.isWindows) {
                        var options = Objects.clone(_this.options);
                        options.windowsVerbatimArguments = true;
                        options.detached = false;
                        var quotedCommand = false;
                        var quotedArg_1 = false;
                        var commandLine_1 = [];
                        var quoted_1 = _this.ensureQuotes(_this.cmd);
                        commandLine_1.push(quoted_1.value);
                        quotedCommand = quoted_1.quoted;
                        if (_this.args) {
                            _this.args.forEach(function (elem) {
                                quoted_1 = _this.ensureQuotes(elem);
                                commandLine_1.push(quoted_1.value);
                                quotedArg_1 = quotedArg_1 && quoted_1.quoted;
                            });
                        }
                        var args = [
                            '/s',
                            '/c',
                        ];
                        if (quotedCommand) {
                            if (quotedArg_1) {
                                args.push('"' + commandLine_1.join(' ') + '"');
                            }
                            else if (commandLine_1.length > 1) {
                                args.push('"' + commandLine_1[0] + '"' + ' ' + commandLine_1.slice(1).join(' '));
                            }
                            else {
                                args.push('"' + commandLine_1[0] + '"');
                            }
                        }
                        else {
                            args.push(commandLine_1.join(' '));
                        }
                        childProcess = spawn(getWindowsShell(), args, options);
                    }
                    else {
                        if (_this.cmd) {
                            childProcess = spawn(_this.cmd, _this.args, _this.options);
                        }
                        else if (_this.module) {
                            _this.childProcessPromise = new winjs_base_1.TPromise(function (c, e, p) {
                                stdFork_1.fork(_this.module, _this.args, _this.options, function (error, childProcess) {
                                    if (error) {
                                        e(error);
                                        ee({ terminated: _this.terminateRequested, error: error });
                                        return;
                                    }
                                    _this.childProcess = childProcess;
                                    _this.childProcess.on('close', closeHandler_1);
                                    _this.handleSpawn(childProcess, cc, pp, ee, false);
                                    c(childProcess);
                                });
                            });
                        }
                    }
                    if (childProcess) {
                        _this.childProcess = childProcess;
                        _this.childProcessPromise = winjs_base_1.TPromise.as(childProcess);
                        childProcess.on('error', function (error) {
                            _this.childProcess = null;
                            ee({ terminated: _this.terminateRequested, error: error });
                        });
                        if (childProcess.pid) {
                            _this.childProcess.on('close', closeHandler_1);
                            _this.handleSpawn(childProcess, cc, pp, ee, true);
                        }
                    }
                }
                return result;
            });
        };
        AbstractProcess.prototype.handleClose = function (data, cc, pp, ee) {
            // Default is to do nothing.
        };
        AbstractProcess.prototype.ensureQuotes = function (value) {
            if (AbstractProcess.regexp.test(value)) {
                return {
                    value: '"' + value + '"',
                    quoted: true
                };
            }
            else {
                return {
                    value: value,
                    quoted: value.length > 0 && value[0] === '"' && value[value.length - 1] === '"'
                };
            }
        };
        AbstractProcess.prototype.isRunning = function () {
            return this.childProcessPromise !== null;
        };
        Object.defineProperty(AbstractProcess.prototype, "pid", {
            get: function () {
                return this.childProcessPromise.then(function (childProcess) { return childProcess.pid; }, function (err) { return -1; });
            },
            enumerable: true,
            configurable: true
        });
        AbstractProcess.prototype.terminate = function () {
            var _this = this;
            if (!this.childProcessPromise) {
                return winjs_base_1.TPromise.as({ success: true });
            }
            return this.childProcessPromise.then(function (childProcess) {
                _this.terminateRequested = true;
                var result = terminateProcess(childProcess, _this.options.cwd);
                if (result.success) {
                    _this.childProcess = null;
                }
                return result;
            }, function (err) {
                return { success: true };
            });
        };
        AbstractProcess.prototype.useExec = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                if (!_this.shell || !Platform.isWindows) {
                    c(false);
                }
                var cmdShell = spawn(getWindowsShell(), ['/s', '/c']);
                cmdShell.on('error', function (error) {
                    c(true);
                });
                cmdShell.on('exit', function (data) {
                    c(false);
                });
            });
        };
        AbstractProcess.WellKnowCommands = {
            'ant': true,
            'cmake': true,
            'eslint': true,
            'gradle': true,
            'grunt': true,
            'gulp': true,
            'jake': true,
            'jenkins': true,
            'jshint': true,
            'make': true,
            'maven': true,
            'msbuild': true,
            'msc': true,
            'nmake': true,
            'npm': true,
            'rake': true,
            'tsc': true,
            'xbuild': true
        };
        AbstractProcess.regexp = /^[^"].* .*[^"]/;
        return AbstractProcess;
    }());
    exports.AbstractProcess = AbstractProcess;
    var LineProcess = (function (_super) {
        __extends(LineProcess, _super);
        function LineProcess(arg1, arg2, arg3, arg4) {
            return _super.call(this, arg1, arg2, arg3, arg4) || this;
        }
        LineProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {
            [stdout, stderr].forEach(function (buffer, index) {
                var lineDecoder = new decoder_1.LineDecoder();
                var lines = lineDecoder.write(buffer);
                lines.forEach(function (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                });
                var line = lineDecoder.end();
                if (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                }
            });
            cc({ terminated: this.terminateRequested, error: error });
        };
        LineProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {
            var _this = this;
            this.stdoutLineDecoder = new decoder_1.LineDecoder();
            this.stderrLineDecoder = new decoder_1.LineDecoder();
            childProcess.stdout.on('data', function (data) {
                var lines = _this.stdoutLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stdout }); });
            });
            childProcess.stderr.on('data', function (data) {
                var lines = _this.stderrLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: processes_1.Source.stderr }); });
            });
        };
        LineProcess.prototype.handleClose = function (data, cc, pp, ee) {
            [this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach(function (line, index) {
                if (line) {
                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });
                }
            });
        };
        return LineProcess;
    }(AbstractProcess));
    exports.LineProcess = LineProcess;
    var BufferProcess = (function (_super) {
        __extends(BufferProcess, _super);
        function BufferProcess(arg1, arg2, arg3, arg4) {
            return _super.call(this, arg1, arg2, arg3, arg4) || this;
        }
        BufferProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {
            pp({ data: stdout, source: processes_1.Source.stdout });
            pp({ data: stderr, source: processes_1.Source.stderr });
            cc({ terminated: this.terminateRequested, error: error });
        };
        BufferProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {
            childProcess.stdout.on('data', function (data) {
                pp({ data: data, source: processes_1.Source.stdout });
            });
            childProcess.stderr.on('data', function (data) {
                pp({ data: data, source: processes_1.Source.stderr });
            });
        };
        return BufferProcess;
    }(AbstractProcess));
    exports.BufferProcess = BufferProcess;
    var StreamProcess = (function (_super) {
        __extends(StreamProcess, _super);
        function StreamProcess(arg1, arg2, arg3, arg4) {
            return _super.call(this, arg1, arg2, arg3, arg4) || this;
        }
        StreamProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {
            var stdoutStream = new stream_1.PassThrough();
            stdoutStream.end(stdout);
            var stderrStream = new stream_1.PassThrough();
            stderrStream.end(stderr);
            pp({ stdin: null, stdout: stdoutStream, stderr: stderrStream });
            cc({ terminated: this.terminateRequested, error: error });
        };
        StreamProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {
            if (sync) {
                process.nextTick(function () {
                    pp({ stdin: childProcess.stdin, stdout: childProcess.stdout, stderr: childProcess.stderr });
                });
            }
            else {
                pp({ stdin: childProcess.stdin, stdout: childProcess.stdout, stderr: childProcess.stderr });
            }
        };
        return StreamProcess;
    }(AbstractProcess));
    exports.StreamProcess = StreamProcess;
    // Wrapper around process.send() that will queue any messages if the internal node.js
    // queue is filled with messages and only continue sending messages when the internal
    // queue is free again to consume messages.
    // On Windows we always wait for the send() method to return before sending the next message
    // to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)
    function createQueuedSender(childProcess) {
        var msgQueue = [];
        var useQueue = false;
        var send = function (msg) {
            if (useQueue) {
                msgQueue.push(msg); // add to the queue if the process cannot handle more messages
                return;
            }
            var result = childProcess.send(msg, function (error) {
                if (error) {
                    console.error(error); // unlikely to happen, best we can do is log this error
                }
                useQueue = false; // we are good again to send directly without queue
                // now send all the messages that we have in our queue and did not send yet
                if (msgQueue.length > 0) {
                    var msgQueueCopy = msgQueue.slice(0);
                    msgQueue = [];
                    msgQueueCopy.forEach(function (entry) { return send(entry); });
                }
            });
            if (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {
                useQueue = true;
            }
        };
        return { send: send };
    }
    exports.createQueuedSender = createQueuedSender;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[80/*vs/base/parts/ipc/node/ipc.cp*/], __M([1/*require*/,0/*exports*/,43/*child_process*/,2/*vs/base/common/winjs.base*/,10/*vs/base/common/async*/,11/*vs/base/common/objects*/,3/*vs/base/common/event*/,53/*vs/base/node/event*/,78/*vs/base/node/processes*/,35/*vs/base/parts/ipc/common/ipc*/]), function (require, exports, child_process_1, winjs_base_1, async_1, objects_1, event_1, event_2, processes_1, ipc_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Server = (function (_super) {
        __extends(Server, _super);
        function Server() {
            var _this = _super.call(this, {
                send: function (r) { try {
                    process.send(r);
                }
                catch (e) { } },
                onMessage: event_2.fromEventEmitter(process, 'message', function (msg) { return msg; })
            }) || this;
            process.once('disconnect', function () { return _this.dispose(); });
            return _this;
        }
        return Server;
    }(ipc_1.ChannelServer));
    exports.Server = Server;
    var Client = (function () {
        function Client(modulePath, options) {
            this.modulePath = modulePath;
            this.options = options;
            var timeout = options && options.timeout ? options.timeout : 60000;
            this.disposeDelayer = new async_1.Delayer(timeout);
            this.activeRequests = [];
            this.child = null;
            this._client = null;
            this.channels = Object.create(null);
        }
        Client.prototype.getChannel = function (channelName) {
            var _this = this;
            var call = function (command, arg) { return _this.request(channelName, command, arg); };
            return { call: call };
        };
        Client.prototype.request = function (channelName, name, arg) {
            var _this = this;
            if (!this.disposeDelayer) {
                return winjs_base_1.TPromise.wrapError(new Error('disposed'));
            }
            this.disposeDelayer.cancel();
            var channel = this.channels[channelName] || (this.channels[channelName] = this.client.getChannel(channelName));
            var request = channel.call(name, arg);
            // Progress doesn't propagate across 'then', we need to create a promise wrapper
            var result = new winjs_base_1.TPromise(function (c, e, p) {
                request.then(c, e, p).done(function () {
                    if (!_this.activeRequests) {
                        return;
                    }
                    _this.activeRequests.splice(_this.activeRequests.indexOf(result), 1);
                    if (_this.activeRequests.length === 0) {
                        _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });
                    }
                });
            }, function () { return request.cancel(); });
            this.activeRequests.push(result);
            return result;
        };
        Object.defineProperty(Client.prototype, "client", {
            get: function () {
                var _this = this;
                if (!this._client) {
                    var args = this.options && this.options.args ? this.options.args : [];
                    var forkOpts = Object.create(null);
                    forkOpts.env = objects_1.assign(objects_1.clone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });
                    if (this.options && this.options.env) {
                        forkOpts.env = objects_1.assign(forkOpts.env, this.options.env);
                    }
                    if (this.options && this.options.freshExecArgv) {
                        forkOpts.execArgv = [];
                    }
                    if (this.options && typeof this.options.debug === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];
                    }
                    if (this.options && typeof this.options.debugBrk === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];
                    }
                    this.child = child_process_1.fork(this.modulePath, args, forkOpts);
                    var onMessageEmitter_1 = new event_1.Emitter();
                    var onRawMessage = event_2.fromEventEmitter(this.child, 'message', function (msg) { return msg; });
                    onRawMessage(function (msg) {
                        // Handle console logs specially
                        if (msg && msg.type === '__$console') {
                            var args_1 = ['%c[IPC Library: ' + _this.options.serverName + ']', 'color: darkgreen'];
                            try {
                                var parsed_1 = JSON.parse(msg.arguments);
                                args_1 = args_1.concat(Object.getOwnPropertyNames(parsed_1).map(function (o) { return parsed_1[o]; }));
                            }
                            catch (error) {
                                args_1.push(msg.arguments);
                            }
                            console[msg.severity].apply(console, args_1);
                            return null;
                        }
                        else {
                            onMessageEmitter_1.fire(msg);
                        }
                    });
                    var sender_1 = this.options.useQueue ? processes_1.createQueuedSender(this.child) : this.child;
                    var send = function (r) { return _this.child && _this.child.connected && sender_1.send(r); };
                    var onMessage = onMessageEmitter_1.event;
                    var protocol = { send: send, onMessage: onMessage };
                    this._client = new ipc_1.ChannelClient(protocol);
                    var onExit_1 = function () { return _this.disposeClient(); };
                    process.once('exit', onExit_1);
                    this.child.on('error', function (err) { return console.warn('IPC "' + _this.options.serverName + '" errored with ' + err); });
                    this.child.on('exit', function (code, signal) {
                        process.removeListener('exit', onExit_1);
                        if (_this.activeRequests) {
                            _this.activeRequests.forEach(function (req) { return req.cancel(); });
                            _this.activeRequests = [];
                        }
                        if (code !== 0 && signal !== 'SIGTERM') {
                            console.warn('IPC "' + _this.options.serverName + '" crashed with exit code ' + code);
                            _this.disposeDelayer.cancel();
                            _this.disposeClient();
                        }
                    });
                }
                return this._client;
            },
            enumerable: true,
            configurable: true
        });
        Client.prototype.disposeClient = function () {
            if (this._client) {
                this.child.kill();
                this.child = null;
                this._client = null;
                this.channels = Object.create(null);
            }
        };
        Client.prototype.dispose = function () {
            this.disposeDelayer.cancel();
            this.disposeDelayer = null;
            this.disposeClient();
            this.activeRequests = null;
        };
        return Client;
    }());
    exports.Client = Client;
});

define(__m[81/*vs/nls!vs/editor/common/config/editorOptions*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/editor/common/config/editorOptions", data); });
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
define(__m[82/*vs/editor/common/config/editorOptions*/], __M([1/*require*/,0/*exports*/,81/*vs/nls!vs/editor/common/config/editorOptions*/,9/*vs/base/common/platform*/,126/*vs/base/common/scrollable*/,34/*vs/editor/common/model/wordHelper*/]), function (require, exports, nls, platform, scrollable_1, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RenderMinimap;
    (function (RenderMinimap) {
        RenderMinimap[RenderMinimap["None"] = 0] = "None";
        RenderMinimap[RenderMinimap["Small"] = 1] = "Small";
        RenderMinimap[RenderMinimap["Large"] = 2] = "Large";
        RenderMinimap[RenderMinimap["SmallBlocks"] = 3] = "SmallBlocks";
        RenderMinimap[RenderMinimap["LargeBlocks"] = 4] = "LargeBlocks";
    })(RenderMinimap = exports.RenderMinimap || (exports.RenderMinimap = {}));
    /**
     * Describes how to indent wrapped lines.
     */
    var WrappingIndent;
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    })(WrappingIndent = exports.WrappingIndent || (exports.WrappingIndent = {}));
    /**
     * The kind of animation in which the editor's cursor should be rendered.
     */
    var TextEditorCursorBlinkingStyle;
    (function (TextEditorCursorBlinkingStyle) {
        /**
         * Hidden
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
        /**
         * Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
        /**
         * Blinking with smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
        /**
         * Expand collapse animation on the y axis
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
        /**
         * No-Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
    })(TextEditorCursorBlinkingStyle = exports.TextEditorCursorBlinkingStyle || (exports.TextEditorCursorBlinkingStyle = {}));
    /**
     * @internal
     */
    function blinkingStyleToString(blinkingStyle) {
        if (blinkingStyle === TextEditorCursorBlinkingStyle.Blink) {
            return 'blink';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Expand) {
            return 'expand';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Phase) {
            return 'phase';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Smooth) {
            return 'smooth';
        }
        else if (blinkingStyle === TextEditorCursorBlinkingStyle.Solid) {
            return 'solid';
        }
        else {
            throw new Error('blinkingStyleToString: Unknown blinkingStyle');
        }
    }
    exports.blinkingStyleToString = blinkingStyleToString;
    /**
     * The style in which the editor's cursor should be rendered.
     */
    var TextEditorCursorStyle;
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
        /**
         * As a thin vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
        /**
         * As an outlined block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
        /**
         * As a thin horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
    })(TextEditorCursorStyle = exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else if (cursorStyle === TextEditorCursorStyle.LineThin) {
            return 'line-thin';
        }
        else if (cursorStyle === TextEditorCursorStyle.BlockOutline) {
            return 'block-outline';
        }
        else if (cursorStyle === TextEditorCursorStyle.UnderlineThin) {
            return 'underline-thin';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    function _cursorStyleFromString(cursorStyle, defaultValue) {
        if (typeof cursorStyle !== 'string') {
            return defaultValue;
        }
        if (cursorStyle === 'line') {
            return TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return TextEditorCursorStyle.Underline;
        }
        else if (cursorStyle === 'line-thin') {
            return TextEditorCursorStyle.LineThin;
        }
        else if (cursorStyle === 'block-outline') {
            return TextEditorCursorStyle.BlockOutline;
        }
        else if (cursorStyle === 'underline-thin') {
            return TextEditorCursorStyle.UnderlineThin;
        }
        return TextEditorCursorStyle.Line;
    }
    /**
     * Internal configuration options (transformed or computed) for the editor.
     */
    var InternalEditorOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorOptions(source) {
            this.canUseLayerHinting = source.canUseLayerHinting;
            this.pixelRatio = source.pixelRatio;
            this.editorClassName = source.editorClassName;
            this.lineHeight = source.lineHeight | 0;
            this.readOnly = source.readOnly;
            this.accessibilitySupport = source.accessibilitySupport;
            this.multiCursorModifier = source.multiCursorModifier;
            this.wordSeparators = source.wordSeparators;
            this.autoClosingBrackets = source.autoClosingBrackets;
            this.autoIndent = source.autoIndent;
            this.useTabStops = source.useTabStops;
            this.tabFocusMode = source.tabFocusMode;
            this.dragAndDrop = source.dragAndDrop;
            this.emptySelectionClipboard = source.emptySelectionClipboard;
            this.layoutInfo = source.layoutInfo;
            this.fontInfo = source.fontInfo;
            this.viewInfo = source.viewInfo;
            this.wrappingInfo = source.wrappingInfo;
            this.contribInfo = source.contribInfo;
        }
        /**
         * @internal
         */
        InternalEditorOptions.prototype.equals = function (other) {
            return (this.canUseLayerHinting === other.canUseLayerHinting
                && this.pixelRatio === other.pixelRatio
                && this.editorClassName === other.editorClassName
                && this.lineHeight === other.lineHeight
                && this.readOnly === other.readOnly
                && this.accessibilitySupport === other.accessibilitySupport
                && this.multiCursorModifier === other.multiCursorModifier
                && this.wordSeparators === other.wordSeparators
                && this.autoClosingBrackets === other.autoClosingBrackets
                && this.autoIndent === other.autoIndent
                && this.useTabStops === other.useTabStops
                && this.tabFocusMode === other.tabFocusMode
                && this.dragAndDrop === other.dragAndDrop
                && this.emptySelectionClipboard === other.emptySelectionClipboard
                && InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, other.layoutInfo)
                && this.fontInfo.equals(other.fontInfo)
                && InternalEditorOptions._equalsViewOptions(this.viewInfo, other.viewInfo)
                && InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, other.wrappingInfo)
                && InternalEditorOptions._equalsContribOptions(this.contribInfo, other.contribInfo));
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                canUseLayerHinting: (this.canUseLayerHinting !== newOpts.canUseLayerHinting),
                pixelRatio: (this.pixelRatio !== newOpts.pixelRatio),
                editorClassName: (this.editorClassName !== newOpts.editorClassName),
                lineHeight: (this.lineHeight !== newOpts.lineHeight),
                readOnly: (this.readOnly !== newOpts.readOnly),
                accessibilitySupport: (this.accessibilitySupport !== newOpts.accessibilitySupport),
                multiCursorModifier: (this.multiCursorModifier !== newOpts.multiCursorModifier),
                wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
                autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
                autoIndent: (this.autoIndent !== newOpts.autoIndent),
                useTabStops: (this.useTabStops !== newOpts.useTabStops),
                tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
                dragAndDrop: (this.dragAndDrop !== newOpts.dragAndDrop),
                emptySelectionClipboard: (this.emptySelectionClipboard !== newOpts.emptySelectionClipboard),
                layoutInfo: (!InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, newOpts.layoutInfo)),
                fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
                viewInfo: (!InternalEditorOptions._equalsViewOptions(this.viewInfo, newOpts.viewInfo)),
                wrappingInfo: (!InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, newOpts.wrappingInfo)),
                contribInfo: (!InternalEditorOptions._equalsContribOptions(this.contribInfo, newOpts.contribInfo))
            };
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsLayoutInfo = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.glyphMarginLeft === b.glyphMarginLeft
                && a.glyphMarginWidth === b.glyphMarginWidth
                && a.glyphMarginHeight === b.glyphMarginHeight
                && a.lineNumbersLeft === b.lineNumbersLeft
                && a.lineNumbersWidth === b.lineNumbersWidth
                && a.lineNumbersHeight === b.lineNumbersHeight
                && a.decorationsLeft === b.decorationsLeft
                && a.decorationsWidth === b.decorationsWidth
                && a.decorationsHeight === b.decorationsHeight
                && a.contentLeft === b.contentLeft
                && a.contentWidth === b.contentWidth
                && a.contentHeight === b.contentHeight
                && a.renderMinimap === b.renderMinimap
                && a.minimapWidth === b.minimapWidth
                && a.viewportColumn === b.viewportColumn
                && a.verticalScrollbarWidth === b.verticalScrollbarWidth
                && a.horizontalScrollbarHeight === b.horizontalScrollbarHeight
                && this._equalsOverviewRuler(a.overviewRuler, b.overviewRuler));
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsOverviewRuler = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.top === b.top
                && a.right === b.right);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsViewOptions = function (a, b) {
            return (a.extraEditorClassName === b.extraEditorClassName
                && a.disableMonospaceOptimizations === b.disableMonospaceOptimizations
                && this._equalsNumberArrays(a.rulers, b.rulers)
                && a.ariaLabel === b.ariaLabel
                && a.renderLineNumbers === b.renderLineNumbers
                && a.renderCustomLineNumbers === b.renderCustomLineNumbers
                && a.renderRelativeLineNumbers === b.renderRelativeLineNumbers
                && a.selectOnLineNumbers === b.selectOnLineNumbers
                && a.glyphMargin === b.glyphMargin
                && a.revealHorizontalRightPadding === b.revealHorizontalRightPadding
                && a.roundedSelection === b.roundedSelection
                && a.overviewRulerLanes === b.overviewRulerLanes
                && a.overviewRulerBorder === b.overviewRulerBorder
                && a.cursorBlinking === b.cursorBlinking
                && a.mouseWheelZoom === b.mouseWheelZoom
                && a.cursorStyle === b.cursorStyle
                && a.hideCursorInOverviewRuler === b.hideCursorInOverviewRuler
                && a.scrollBeyondLastLine === b.scrollBeyondLastLine
                && a.smoothScrolling === b.smoothScrolling
                && a.stopRenderingLineAfter === b.stopRenderingLineAfter
                && a.renderWhitespace === b.renderWhitespace
                && a.renderControlCharacters === b.renderControlCharacters
                && a.fontLigatures === b.fontLigatures
                && a.renderIndentGuides === b.renderIndentGuides
                && a.renderLineHighlight === b.renderLineHighlight
                && this._equalsScrollbarOptions(a.scrollbar, b.scrollbar)
                && this._equalsMinimapOptions(a.minimap, b.minimap)
                && a.fixedOverflowWidgets === b.fixedOverflowWidgets);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsScrollbarOptions = function (a, b) {
            return (a.arrowSize === b.arrowSize
                && a.vertical === b.vertical
                && a.horizontal === b.horizontal
                && a.useShadows === b.useShadows
                && a.verticalHasArrows === b.verticalHasArrows
                && a.horizontalHasArrows === b.horizontalHasArrows
                && a.handleMouseWheel === b.handleMouseWheel
                && a.horizontalScrollbarSize === b.horizontalScrollbarSize
                && a.horizontalSliderSize === b.horizontalSliderSize
                && a.verticalScrollbarSize === b.verticalScrollbarSize
                && a.verticalSliderSize === b.verticalSliderSize
                && a.mouseWheelScrollSensitivity === b.mouseWheelScrollSensitivity);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsMinimapOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.showSlider === b.showSlider
                && a.renderCharacters === b.renderCharacters
                && a.maxColumn === b.maxColumn);
        };
        InternalEditorOptions._equalsNumberArrays = function (a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalFindOptions = function (a, b) {
            return (a.seedSearchStringFromSelection === b.seedSearchStringFromSelection
                && a.autoFindInSelection === b.autoFindInSelection);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsWrappingInfo = function (a, b) {
            return (a.inDiffEditor === b.inDiffEditor
                && a.isDominatedByLongLines === b.isDominatedByLongLines
                && a.isWordWrapMinified === b.isWordWrapMinified
                && a.isViewportWrapping === b.isViewportWrapping
                && a.wrappingColumn === b.wrappingColumn
                && a.wrappingIndent === b.wrappingIndent
                && a.wordWrapBreakBeforeCharacters === b.wordWrapBreakBeforeCharacters
                && a.wordWrapBreakAfterCharacters === b.wordWrapBreakAfterCharacters
                && a.wordWrapBreakObtrusiveCharacters === b.wordWrapBreakObtrusiveCharacters);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsContribOptions = function (a, b) {
            return (a.selectionClipboard === b.selectionClipboard
                && a.hover === b.hover
                && a.links === b.links
                && a.contextmenu === b.contextmenu
                && InternalEditorOptions._equalsQuickSuggestions(a.quickSuggestions, b.quickSuggestions)
                && a.quickSuggestionsDelay === b.quickSuggestionsDelay
                && a.parameterHints === b.parameterHints
                && a.iconsInSuggestions === b.iconsInSuggestions
                && a.formatOnType === b.formatOnType
                && a.formatOnPaste === b.formatOnPaste
                && a.suggestOnTriggerCharacters === b.suggestOnTriggerCharacters
                && a.acceptSuggestionOnEnter === b.acceptSuggestionOnEnter
                && a.acceptSuggestionOnCommitCharacter === b.acceptSuggestionOnCommitCharacter
                && a.snippetSuggestions === b.snippetSuggestions
                && a.wordBasedSuggestions === b.wordBasedSuggestions
                && a.suggestFontSize === b.suggestFontSize
                && a.suggestLineHeight === b.suggestLineHeight
                && a.selectionHighlight === b.selectionHighlight
                && a.occurrencesHighlight === b.occurrencesHighlight
                && a.codeLens === b.codeLens
                && a.folding === b.folding
                && a.showFoldingControls === b.showFoldingControls
                && a.matchBrackets === b.matchBrackets
                && this._equalFindOptions(a.find, b.find)
                && a.colorDecorators === b.colorDecorators);
        };
        InternalEditorOptions._equalsQuickSuggestions = function (a, b) {
            if (typeof a === 'boolean') {
                if (typeof b !== 'boolean') {
                    return false;
                }
                return a === b;
            }
            if (typeof b === 'boolean') {
                return false;
            }
            return (a.comments === b.comments
                && a.other === b.other
                && a.strings === b.strings);
        };
        return InternalEditorOptions;
    }());
    exports.InternalEditorOptions = InternalEditorOptions;
    function _boolean(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        if (value === 'false') {
            // treat the string 'false' as false
            return false;
        }
        return Boolean(value);
    }
    function _string(value, defaultValue) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        return value;
    }
    function _stringSet(value, defaultValue, allowedValues) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        if (allowedValues.indexOf(value) === -1) {
            return defaultValue;
        }
        return value;
    }
    function _clampedInt(value, defaultValue, minimum, maximum) {
        var r;
        if (typeof value === 'undefined') {
            r = defaultValue;
        }
        else {
            r = parseInt(value, 10);
            if (isNaN(r)) {
                r = defaultValue;
            }
        }
        r = Math.max(minimum, r);
        r = Math.min(maximum, r);
        return r | 0;
    }
    function _float(value, defaultValue) {
        var r = parseFloat(value);
        if (isNaN(r)) {
            r = defaultValue;
        }
        return r;
    }
    function _wrappingIndentFromString(wrappingIndent, defaultValue) {
        if (typeof wrappingIndent !== 'string') {
            return defaultValue;
        }
        if (wrappingIndent === 'indent') {
            return WrappingIndent.Indent;
        }
        else if (wrappingIndent === 'same') {
            return WrappingIndent.Same;
        }
        else {
            return WrappingIndent.None;
        }
    }
    function _cursorBlinkingStyleFromString(cursorBlinkingStyle, defaultValue) {
        if (typeof cursorBlinkingStyle !== 'string') {
            return defaultValue;
        }
        switch (cursorBlinkingStyle) {
            case 'blink':
                return TextEditorCursorBlinkingStyle.Blink;
            case 'smooth':
                return TextEditorCursorBlinkingStyle.Smooth;
            case 'phase':
                return TextEditorCursorBlinkingStyle.Phase;
            case 'expand':
                return TextEditorCursorBlinkingStyle.Expand;
            case 'visible': // maintain compatibility
            case 'solid':
                return TextEditorCursorBlinkingStyle.Solid;
        }
        return TextEditorCursorBlinkingStyle.Blink;
    }
    function _scrollbarVisibilityFromString(visibility, defaultValue) {
        if (typeof visibility !== 'string') {
            return defaultValue;
        }
        switch (visibility) {
            case 'hidden':
                return scrollable_1.ScrollbarVisibility.Hidden;
            case 'visible':
                return scrollable_1.ScrollbarVisibility.Visible;
            default:
                return scrollable_1.ScrollbarVisibility.Auto;
        }
    }
    /**
     * @internal
     */
    var EditorOptionsValidator = (function () {
        function EditorOptionsValidator() {
        }
        /**
         * Validate raw editor options.
         * i.e. since they can be defined by the user, they might be invalid.
         */
        EditorOptionsValidator.validate = function (opts, defaults) {
            var wordWrap = opts.wordWrap;
            {
                // Compatibility with old true or false values
                if (wordWrap === true) {
                    wordWrap = 'on';
                }
                else if (wordWrap === false) {
                    wordWrap = 'off';
                }
                wordWrap = _stringSet(wordWrap, defaults.wordWrap, ['off', 'on', 'wordWrapColumn', 'bounded']);
            }
            var viewInfo = this._sanitizeViewInfo(opts, defaults.viewInfo);
            var contribInfo = this._sanitizeContribInfo(opts, defaults.contribInfo);
            var configuredMulticursorModifier;
            if (typeof opts.multiCursorModifier === 'string') {
                if (opts.multiCursorModifier === 'ctrlCmd') {
                    configuredMulticursorModifier = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
                }
                else {
                    configuredMulticursorModifier = 'altKey';
                }
            }
            var multiCursorModifier = _stringSet(configuredMulticursorModifier, defaults.multiCursorModifier, ['altKey', 'metaKey', 'ctrlKey']);
            return {
                inDiffEditor: _boolean(opts.inDiffEditor, defaults.inDiffEditor),
                wordSeparators: _string(opts.wordSeparators, defaults.wordSeparators),
                lineNumbersMinChars: _clampedInt(opts.lineNumbersMinChars, defaults.lineNumbersMinChars, 1, 10),
                lineDecorationsWidth: (typeof opts.lineDecorationsWidth === 'undefined' ? defaults.lineDecorationsWidth : opts.lineDecorationsWidth),
                readOnly: _boolean(opts.readOnly, defaults.readOnly),
                mouseStyle: _stringSet(opts.mouseStyle, defaults.mouseStyle, ['text', 'default', 'copy']),
                disableLayerHinting: _boolean(opts.disableLayerHinting, defaults.disableLayerHinting),
                automaticLayout: _boolean(opts.automaticLayout, defaults.automaticLayout),
                wordWrap: wordWrap,
                wordWrapColumn: _clampedInt(opts.wordWrapColumn, defaults.wordWrapColumn, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                wordWrapMinified: _boolean(opts.wordWrapMinified, defaults.wordWrapMinified),
                wrappingIndent: _wrappingIndentFromString(opts.wrappingIndent, defaults.wrappingIndent),
                wordWrapBreakBeforeCharacters: _string(opts.wordWrapBreakBeforeCharacters, defaults.wordWrapBreakBeforeCharacters),
                wordWrapBreakAfterCharacters: _string(opts.wordWrapBreakAfterCharacters, defaults.wordWrapBreakAfterCharacters),
                wordWrapBreakObtrusiveCharacters: _string(opts.wordWrapBreakObtrusiveCharacters, defaults.wordWrapBreakObtrusiveCharacters),
                autoClosingBrackets: _boolean(opts.autoClosingBrackets, defaults.autoClosingBrackets),
                autoIndent: _boolean(opts.autoIndent, defaults.autoIndent),
                dragAndDrop: _boolean(opts.dragAndDrop, defaults.dragAndDrop),
                emptySelectionClipboard: _boolean(opts.emptySelectionClipboard, defaults.emptySelectionClipboard),
                useTabStops: _boolean(opts.useTabStops, defaults.useTabStops),
                multiCursorModifier: multiCursorModifier,
                accessibilitySupport: _stringSet(opts.accessibilitySupport, defaults.accessibilitySupport, ['auto', 'on', 'off']),
                viewInfo: viewInfo,
                contribInfo: contribInfo,
            };
        };
        EditorOptionsValidator._sanitizeScrollbarOpts = function (opts, defaults, mouseWheelScrollSensitivity) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            var horizontalScrollbarSize = _clampedInt(opts.horizontalScrollbarSize, defaults.horizontalScrollbarSize, 0, 1000);
            var verticalScrollbarSize = _clampedInt(opts.verticalScrollbarSize, defaults.verticalScrollbarSize, 0, 1000);
            return {
                vertical: _scrollbarVisibilityFromString(opts.vertical, defaults.vertical),
                horizontal: _scrollbarVisibilityFromString(opts.horizontal, defaults.horizontal),
                arrowSize: _clampedInt(opts.arrowSize, defaults.arrowSize, 0, 1000),
                useShadows: _boolean(opts.useShadows, defaults.useShadows),
                verticalHasArrows: _boolean(opts.verticalHasArrows, defaults.verticalHasArrows),
                horizontalHasArrows: _boolean(opts.horizontalHasArrows, defaults.horizontalHasArrows),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: _clampedInt(opts.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: _clampedInt(opts.verticalSliderSize, verticalScrollbarSize, 0, 1000),
                handleMouseWheel: _boolean(opts.handleMouseWheel, defaults.handleMouseWheel),
                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
            };
        };
        EditorOptionsValidator._sanitizeMinimapOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                showSlider: _stringSet(opts.showSlider, defaults.showSlider, ['always', 'mouseover']),
                renderCharacters: _boolean(opts.renderCharacters, defaults.renderCharacters),
                maxColumn: _clampedInt(opts.maxColumn, defaults.maxColumn, 1, 10000),
            };
        };
        EditorOptionsValidator._santizeFindOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                seedSearchStringFromSelection: _boolean(opts.seedSearchStringFromSelection, defaults.seedSearchStringFromSelection),
                autoFindInSelection: _boolean(opts.autoFindInSelection, defaults.autoFindInSelection)
            };
        };
        EditorOptionsValidator._sanitizeViewInfo = function (opts, defaults) {
            var rulers = [];
            if (Array.isArray(opts.rulers)) {
                for (var i = 0, len = opts.rulers.length; i < len; i++) {
                    rulers.push(_clampedInt(opts.rulers[i], 0, 0, 10000));
                }
                rulers.sort();
            }
            var renderLineNumbers = defaults.renderLineNumbers;
            var renderCustomLineNumbers = defaults.renderCustomLineNumbers;
            var renderRelativeLineNumbers = defaults.renderRelativeLineNumbers;
            if (typeof opts.lineNumbers !== 'undefined') {
                var lineNumbers = opts.lineNumbers;
                // Compatibility with old true or false values
                if (lineNumbers === true) {
                    lineNumbers = 'on';
                }
                else if (lineNumbers === false) {
                    lineNumbers = 'off';
                }
                if (typeof lineNumbers === 'function') {
                    renderLineNumbers = true;
                    renderCustomLineNumbers = lineNumbers;
                    renderRelativeLineNumbers = false;
                }
                else if (lineNumbers === 'relative') {
                    renderLineNumbers = true;
                    renderCustomLineNumbers = null;
                    renderRelativeLineNumbers = true;
                }
                else if (lineNumbers === 'on') {
                    renderLineNumbers = true;
                    renderCustomLineNumbers = null;
                    renderRelativeLineNumbers = false;
                }
                else {
                    renderLineNumbers = false;
                    renderCustomLineNumbers = null;
                    renderRelativeLineNumbers = false;
                }
            }
            var fontLigatures = _boolean(opts.fontLigatures, defaults.fontLigatures);
            var disableMonospaceOptimizations = _boolean(opts.disableMonospaceOptimizations, defaults.disableMonospaceOptimizations) || fontLigatures;
            var renderWhitespace = opts.renderWhitespace;
            {
                // Compatibility with old true or false values
                if (renderWhitespace === true) {
                    renderWhitespace = 'boundary';
                }
                else if (renderWhitespace === false) {
                    renderWhitespace = 'none';
                }
                renderWhitespace = _stringSet(opts.renderWhitespace, defaults.renderWhitespace, ['none', 'boundary', 'all']);
            }
            var renderLineHighlight = opts.renderLineHighlight;
            {
                // Compatibility with old true or false values
                if (renderLineHighlight === true) {
                    renderLineHighlight = 'line';
                }
                else if (renderLineHighlight === false) {
                    renderLineHighlight = 'none';
                }
                renderLineHighlight = _stringSet(opts.renderLineHighlight, defaults.renderLineHighlight, ['none', 'gutter', 'line', 'all']);
            }
            var mouseWheelScrollSensitivity = _float(opts.mouseWheelScrollSensitivity, defaults.scrollbar.mouseWheelScrollSensitivity);
            var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, defaults.scrollbar, mouseWheelScrollSensitivity);
            var minimap = this._sanitizeMinimapOpts(opts.minimap, defaults.minimap);
            return {
                extraEditorClassName: _string(opts.extraEditorClassName, defaults.extraEditorClassName),
                disableMonospaceOptimizations: disableMonospaceOptimizations,
                rulers: rulers,
                ariaLabel: _string(opts.ariaLabel, defaults.ariaLabel),
                renderLineNumbers: renderLineNumbers,
                renderCustomLineNumbers: renderCustomLineNumbers,
                renderRelativeLineNumbers: renderRelativeLineNumbers,
                selectOnLineNumbers: _boolean(opts.selectOnLineNumbers, defaults.selectOnLineNumbers),
                glyphMargin: _boolean(opts.glyphMargin, defaults.glyphMargin),
                revealHorizontalRightPadding: _clampedInt(opts.revealHorizontalRightPadding, defaults.revealHorizontalRightPadding, 0, 1000),
                roundedSelection: _boolean(opts.roundedSelection, defaults.roundedSelection),
                overviewRulerLanes: _clampedInt(opts.overviewRulerLanes, defaults.overviewRulerLanes, 0, 3),
                overviewRulerBorder: _boolean(opts.overviewRulerBorder, defaults.overviewRulerBorder),
                cursorBlinking: _cursorBlinkingStyleFromString(opts.cursorBlinking, defaults.cursorBlinking),
                mouseWheelZoom: _boolean(opts.mouseWheelZoom, defaults.mouseWheelZoom),
                cursorStyle: _cursorStyleFromString(opts.cursorStyle, defaults.cursorStyle),
                hideCursorInOverviewRuler: _boolean(opts.hideCursorInOverviewRuler, defaults.hideCursorInOverviewRuler),
                scrollBeyondLastLine: _boolean(opts.scrollBeyondLastLine, defaults.scrollBeyondLastLine),
                smoothScrolling: _boolean(opts.smoothScrolling, defaults.smoothScrolling),
                stopRenderingLineAfter: _clampedInt(opts.stopRenderingLineAfter, defaults.stopRenderingLineAfter, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                renderWhitespace: renderWhitespace,
                renderControlCharacters: _boolean(opts.renderControlCharacters, defaults.renderControlCharacters),
                fontLigatures: fontLigatures,
                renderIndentGuides: _boolean(opts.renderIndentGuides, defaults.renderIndentGuides),
                renderLineHighlight: renderLineHighlight,
                scrollbar: scrollbar,
                minimap: minimap,
                fixedOverflowWidgets: _boolean(opts.fixedOverflowWidgets, defaults.fixedOverflowWidgets),
            };
        };
        EditorOptionsValidator._sanitizeContribInfo = function (opts, defaults) {
            var quickSuggestions;
            if (typeof opts.quickSuggestions === 'object') {
                quickSuggestions = __assign({ other: true }, opts.quickSuggestions);
            }
            else {
                quickSuggestions = _boolean(opts.quickSuggestions, defaults.quickSuggestions);
            }
            var find = this._santizeFindOpts(opts.find, defaults.find);
            return {
                selectionClipboard: _boolean(opts.selectionClipboard, defaults.selectionClipboard),
                hover: _boolean(opts.hover, defaults.hover),
                links: _boolean(opts.links, defaults.links),
                contextmenu: _boolean(opts.contextmenu, defaults.contextmenu),
                quickSuggestions: quickSuggestions,
                quickSuggestionsDelay: _clampedInt(opts.quickSuggestionsDelay, defaults.quickSuggestionsDelay, -1073741824 /* MIN_SAFE_SMALL_INTEGER */, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                parameterHints: _boolean(opts.parameterHints, defaults.parameterHints),
                iconsInSuggestions: _boolean(opts.iconsInSuggestions, defaults.iconsInSuggestions),
                formatOnType: _boolean(opts.formatOnType, defaults.formatOnType),
                formatOnPaste: _boolean(opts.formatOnPaste, defaults.formatOnPaste),
                suggestOnTriggerCharacters: _boolean(opts.suggestOnTriggerCharacters, defaults.suggestOnTriggerCharacters),
                acceptSuggestionOnEnter: _stringSet(opts.acceptSuggestionOnEnter, defaults.acceptSuggestionOnEnter, ['on', 'smart', 'off']),
                acceptSuggestionOnCommitCharacter: _boolean(opts.acceptSuggestionOnCommitCharacter, defaults.acceptSuggestionOnCommitCharacter),
                snippetSuggestions: _stringSet(opts.snippetSuggestions, defaults.snippetSuggestions, ['top', 'bottom', 'inline', 'none']),
                wordBasedSuggestions: _boolean(opts.wordBasedSuggestions, defaults.wordBasedSuggestions),
                suggestFontSize: _clampedInt(opts.suggestFontSize, defaults.suggestFontSize, 0, 1000),
                suggestLineHeight: _clampedInt(opts.suggestLineHeight, defaults.suggestLineHeight, 0, 1000),
                selectionHighlight: _boolean(opts.selectionHighlight, defaults.selectionHighlight),
                occurrencesHighlight: _boolean(opts.occurrencesHighlight, defaults.occurrencesHighlight),
                codeLens: _boolean(opts.codeLens, defaults.codeLens) && _boolean(opts.referenceInfos, true),
                folding: _boolean(opts.folding, defaults.folding),
                showFoldingControls: _stringSet(opts.showFoldingControls, defaults.showFoldingControls, ['always', 'mouseover']),
                matchBrackets: _boolean(opts.matchBrackets, defaults.matchBrackets),
                find: find,
                colorDecorators: _boolean(opts.colorDecorators, defaults.colorDecorators),
            };
        };
        return EditorOptionsValidator;
    }());
    exports.EditorOptionsValidator = EditorOptionsValidator;
    /**
     * @internal
     */
    var InternalEditorOptionsFactory = (function () {
        function InternalEditorOptionsFactory() {
        }
        InternalEditorOptionsFactory._tweakValidatedOptions = function (opts, accessibilitySupport) {
            var accessibilityIsOn = (accessibilitySupport === 2 /* Enabled */);
            var accessibilityIsOff = (accessibilitySupport === 1 /* Disabled */);
            return {
                inDiffEditor: opts.inDiffEditor,
                wordSeparators: opts.wordSeparators,
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineDecorationsWidth: opts.lineDecorationsWidth,
                readOnly: opts.readOnly,
                mouseStyle: opts.mouseStyle,
                disableLayerHinting: opts.disableLayerHinting,
                automaticLayout: opts.automaticLayout,
                wordWrap: opts.wordWrap,
                wordWrapColumn: opts.wordWrapColumn,
                wordWrapMinified: opts.wordWrapMinified,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoIndent: opts.autoIndent,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard,
                useTabStops: opts.useTabStops,
                multiCursorModifier: opts.multiCursorModifier,
                accessibilitySupport: opts.accessibilitySupport,
                viewInfo: {
                    extraEditorClassName: opts.viewInfo.extraEditorClassName,
                    disableMonospaceOptimizations: opts.viewInfo.disableMonospaceOptimizations,
                    rulers: opts.viewInfo.rulers,
                    ariaLabel: (accessibilityIsOff ? nls.localize(0, null) : opts.viewInfo.ariaLabel),
                    renderLineNumbers: opts.viewInfo.renderLineNumbers,
                    renderCustomLineNumbers: opts.viewInfo.renderCustomLineNumbers,
                    renderRelativeLineNumbers: opts.viewInfo.renderRelativeLineNumbers,
                    selectOnLineNumbers: opts.viewInfo.selectOnLineNumbers,
                    glyphMargin: opts.viewInfo.glyphMargin,
                    revealHorizontalRightPadding: opts.viewInfo.revealHorizontalRightPadding,
                    roundedSelection: (accessibilityIsOn ? false : opts.viewInfo.roundedSelection),
                    overviewRulerLanes: opts.viewInfo.overviewRulerLanes,
                    overviewRulerBorder: opts.viewInfo.overviewRulerBorder,
                    cursorBlinking: opts.viewInfo.cursorBlinking,
                    mouseWheelZoom: opts.viewInfo.mouseWheelZoom,
                    cursorStyle: opts.viewInfo.cursorStyle,
                    hideCursorInOverviewRuler: opts.viewInfo.hideCursorInOverviewRuler,
                    scrollBeyondLastLine: opts.viewInfo.scrollBeyondLastLine,
                    smoothScrolling: opts.viewInfo.smoothScrolling,
                    stopRenderingLineAfter: opts.viewInfo.stopRenderingLineAfter,
                    renderWhitespace: (accessibilityIsOn ? 'none' : opts.viewInfo.renderWhitespace),
                    renderControlCharacters: (accessibilityIsOn ? false : opts.viewInfo.renderControlCharacters),
                    fontLigatures: (accessibilityIsOn ? false : opts.viewInfo.fontLigatures),
                    renderIndentGuides: (accessibilityIsOn ? false : opts.viewInfo.renderIndentGuides),
                    renderLineHighlight: (accessibilityIsOn ? 'none' : opts.viewInfo.renderLineHighlight),
                    scrollbar: opts.viewInfo.scrollbar,
                    minimap: {
                        enabled: (accessibilityIsOn ? false : opts.viewInfo.minimap.enabled),
                        renderCharacters: opts.viewInfo.minimap.renderCharacters,
                        showSlider: opts.viewInfo.minimap.showSlider,
                        maxColumn: opts.viewInfo.minimap.maxColumn
                    },
                    fixedOverflowWidgets: opts.viewInfo.fixedOverflowWidgets
                },
                contribInfo: {
                    selectionClipboard: opts.contribInfo.selectionClipboard,
                    hover: opts.contribInfo.hover,
                    links: (accessibilityIsOn ? false : opts.contribInfo.links),
                    contextmenu: opts.contribInfo.contextmenu,
                    quickSuggestions: opts.contribInfo.quickSuggestions,
                    quickSuggestionsDelay: opts.contribInfo.quickSuggestionsDelay,
                    parameterHints: opts.contribInfo.parameterHints,
                    iconsInSuggestions: opts.contribInfo.iconsInSuggestions,
                    formatOnType: opts.contribInfo.formatOnType,
                    formatOnPaste: opts.contribInfo.formatOnPaste,
                    suggestOnTriggerCharacters: opts.contribInfo.suggestOnTriggerCharacters,
                    acceptSuggestionOnEnter: opts.contribInfo.acceptSuggestionOnEnter,
                    acceptSuggestionOnCommitCharacter: opts.contribInfo.acceptSuggestionOnCommitCharacter,
                    snippetSuggestions: opts.contribInfo.snippetSuggestions,
                    wordBasedSuggestions: opts.contribInfo.wordBasedSuggestions,
                    suggestFontSize: opts.contribInfo.suggestFontSize,
                    suggestLineHeight: opts.contribInfo.suggestLineHeight,
                    selectionHighlight: (accessibilityIsOn ? false : opts.contribInfo.selectionHighlight),
                    occurrencesHighlight: (accessibilityIsOn ? false : opts.contribInfo.occurrencesHighlight),
                    codeLens: (accessibilityIsOn ? false : opts.contribInfo.codeLens),
                    folding: (accessibilityIsOn ? false : opts.contribInfo.folding),
                    showFoldingControls: opts.contribInfo.showFoldingControls,
                    matchBrackets: (accessibilityIsOn ? false : opts.contribInfo.matchBrackets),
                    find: opts.contribInfo.find,
                    colorDecorators: opts.contribInfo.colorDecorators
                }
            };
        };
        InternalEditorOptionsFactory.createInternalEditorOptions = function (env, _opts) {
            var accessibilitySupport;
            if (_opts.accessibilitySupport === 'auto') {
                // The editor reads the `accessibilitySupport` from the environment
                accessibilitySupport = env.accessibilitySupport;
            }
            else if (_opts.accessibilitySupport === 'on') {
                accessibilitySupport = 2 /* Enabled */;
            }
            else {
                accessibilitySupport = 1 /* Disabled */;
            }
            // Disable some non critical features to get as best performance as possible
            // See https://github.com/Microsoft/vscode/issues/26730
            var opts = this._tweakValidatedOptions(_opts, accessibilitySupport);
            var lineDecorationsWidth;
            if (typeof opts.lineDecorationsWidth === 'string' && /^\d+(\.\d+)?ch$/.test(opts.lineDecorationsWidth)) {
                var multiple = parseFloat(opts.lineDecorationsWidth.substr(0, opts.lineDecorationsWidth.length - 2));
                lineDecorationsWidth = multiple * env.fontInfo.typicalHalfwidthCharacterWidth;
            }
            else {
                lineDecorationsWidth = _clampedInt(opts.lineDecorationsWidth, 0, 0, 1000);
            }
            if (opts.contribInfo.folding) {
                lineDecorationsWidth += 16;
            }
            var layoutInfo = EditorLayoutProvider.compute({
                outerWidth: env.outerWidth,
                outerHeight: env.outerHeight,
                showGlyphMargin: opts.viewInfo.glyphMargin,
                lineHeight: env.fontInfo.lineHeight,
                showLineNumbers: opts.viewInfo.renderLineNumbers,
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineNumbersDigitCount: env.lineNumbersDigitCount,
                lineDecorationsWidth: lineDecorationsWidth,
                typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
                maxDigitWidth: env.fontInfo.maxDigitWidth,
                verticalScrollbarWidth: opts.viewInfo.scrollbar.verticalScrollbarSize,
                horizontalScrollbarHeight: opts.viewInfo.scrollbar.horizontalScrollbarSize,
                scrollbarArrowSize: opts.viewInfo.scrollbar.arrowSize,
                verticalScrollbarHasArrows: opts.viewInfo.scrollbar.verticalHasArrows,
                minimap: opts.viewInfo.minimap.enabled,
                minimapRenderCharacters: opts.viewInfo.minimap.renderCharacters,
                minimapMaxColumn: opts.viewInfo.minimap.maxColumn,
                pixelRatio: env.pixelRatio
            });
            var bareWrappingInfo = null;
            {
                var wordWrap = opts.wordWrap;
                var wordWrapColumn = opts.wordWrapColumn;
                var wordWrapMinified = opts.wordWrapMinified;
                if (accessibilitySupport === 2 /* Enabled */) {
                    // See https://github.com/Microsoft/vscode/issues/27766
                    // Never enable wrapping when a screen reader is attached
                    // because arrow down etc. will not move the cursor in the way
                    // a screen reader expects.
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
                else if (wordWrapMinified && env.isDominatedByLongLines) {
                    // Force viewport width wrapping if model is dominated by long lines
                    bareWrappingInfo = {
                        isWordWrapMinified: true,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'on') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'bounded') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.min(Math.max(1, layoutInfo.viewportColumn), wordWrapColumn)
                    };
                }
                else if (wordWrap === 'wordWrapColumn') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: wordWrapColumn
                    };
                }
                else {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
            }
            var wrappingInfo = {
                inDiffEditor: opts.inDiffEditor,
                isDominatedByLongLines: env.isDominatedByLongLines,
                isWordWrapMinified: bareWrappingInfo.isWordWrapMinified,
                isViewportWrapping: bareWrappingInfo.isViewportWrapping,
                wrappingColumn: bareWrappingInfo.wrappingColumn,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
            };
            var className = 'monaco-editor';
            if (opts.viewInfo.extraEditorClassName) {
                className += ' ' + opts.viewInfo.extraEditorClassName;
            }
            if (env.extraEditorClassName) {
                className += ' ' + env.extraEditorClassName;
            }
            if (opts.viewInfo.fontLigatures) {
                className += ' enable-ligatures';
            }
            if (opts.mouseStyle === 'default') {
                className += ' mouse-default';
            }
            else if (opts.mouseStyle === 'copy') {
                className += ' mouse-copy';
            }
            return new InternalEditorOptions({
                canUseLayerHinting: opts.disableLayerHinting ? false : true,
                pixelRatio: env.pixelRatio,
                editorClassName: className,
                lineHeight: env.fontInfo.lineHeight,
                readOnly: opts.readOnly,
                accessibilitySupport: accessibilitySupport,
                multiCursorModifier: opts.multiCursorModifier,
                wordSeparators: opts.wordSeparators,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoIndent: opts.autoIndent,
                useTabStops: opts.useTabStops,
                tabFocusMode: opts.readOnly ? true : env.tabFocusMode,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard && env.emptySelectionClipboard,
                layoutInfo: layoutInfo,
                fontInfo: env.fontInfo,
                viewInfo: opts.viewInfo,
                wrappingInfo: wrappingInfo,
                contribInfo: opts.contribInfo
            });
        };
        return InternalEditorOptionsFactory;
    }());
    exports.InternalEditorOptionsFactory = InternalEditorOptionsFactory;
    /**
     * @internal
     */
    var EditorLayoutProvider = (function () {
        function EditorLayoutProvider() {
        }
        EditorLayoutProvider.compute = function (_opts) {
            var outerWidth = _opts.outerWidth | 0;
            var outerHeight = _opts.outerHeight | 0;
            var showGlyphMargin = _opts.showGlyphMargin;
            var lineHeight = _opts.lineHeight | 0;
            var showLineNumbers = _opts.showLineNumbers;
            var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
            var lineNumbersDigitCount = _opts.lineNumbersDigitCount | 0;
            var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
            var typicalHalfwidthCharacterWidth = _opts.typicalHalfwidthCharacterWidth;
            var maxDigitWidth = _opts.maxDigitWidth;
            var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
            var verticalScrollbarHasArrows = _opts.verticalScrollbarHasArrows;
            var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
            var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
            var minimap = _opts.minimap;
            var minimapRenderCharacters = _opts.minimapRenderCharacters;
            var minimapMaxColumn = _opts.minimapMaxColumn | 0;
            var pixelRatio = _opts.pixelRatio;
            var lineNumbersWidth = 0;
            if (showLineNumbers) {
                var digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            var glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight;
            }
            var glyphMarginLeft = 0;
            var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            var contentLeft = decorationsLeft + lineDecorationsWidth;
            var remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            var renderMinimap;
            var minimapWidth;
            var contentWidth;
            if (!minimap) {
                minimapWidth = 0;
                renderMinimap = RenderMinimap.None;
                contentWidth = remainingWidth;
            }
            else {
                var minimapCharWidth = void 0;
                if (pixelRatio >= 2) {
                    renderMinimap = minimapRenderCharacters ? RenderMinimap.Large : RenderMinimap.LargeBlocks;
                    minimapCharWidth = 2 / pixelRatio;
                }
                else {
                    renderMinimap = minimapRenderCharacters ? RenderMinimap.Small : RenderMinimap.SmallBlocks;
                    minimapCharWidth = 1 / pixelRatio;
                }
                // Given:
                // viewportColumn = (contentWidth - verticalScrollbarWidth) / typicalHalfwidthCharacterWidth
                // minimapWidth = viewportColumn * minimapCharWidth
                // contentWidth = remainingWidth - minimapWidth
                // What are good values for contentWidth and minimapWidth ?
                // minimapWidth = ((contentWidth - verticalScrollbarWidth) / typicalHalfwidthCharacterWidth) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth) * minimapCharWidth
                // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth) * minimapCharWidth
                // minimapWidth = ((remainingWidth - verticalScrollbarWidth) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)
                minimapWidth = Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)));
                var minimapColumns = minimapWidth / minimapCharWidth;
                if (minimapColumns > minimapMaxColumn) {
                    minimapWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
                }
                contentWidth = remainingWidth - minimapWidth;
            }
            var viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth) / typicalHalfwidthCharacterWidth));
            var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            return {
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginHeight: outerHeight,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                lineNumbersHeight: outerHeight,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                decorationsHeight: outerHeight,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                contentHeight: outerHeight,
                renderMinimap: renderMinimap,
                minimapWidth: minimapWidth,
                viewportColumn: viewportColumn,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: {
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                }
            };
        };
        return EditorLayoutProvider;
    }());
    exports.EditorLayoutProvider = EditorLayoutProvider;
    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'Courier New\', monospace, \'Droid Sans Fallback\'';
    /**
     * @internal
     */
    exports.EDITOR_FONT_DEFAULTS = {
        fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
        fontWeight: 'normal',
        fontSize: (platform.isMacintosh ? 12 : 14),
        lineHeight: 0,
        letterSpacing: 0,
    };
    /**
     * @internal
     */
    exports.EDITOR_MODEL_DEFAULTS = {
        tabSize: 4,
        insertSpaces: true,
        detectIndentation: true,
        trimAutoWhitespace: true
    };
    /**
     * @internal
     */
    exports.EDITOR_DEFAULTS = {
        inDiffEditor: false,
        wordSeparators: wordHelper_1.USUAL_WORD_SEPARATORS,
        lineNumbersMinChars: 5,
        lineDecorationsWidth: 10,
        readOnly: false,
        mouseStyle: 'text',
        disableLayerHinting: false,
        automaticLayout: false,
        wordWrap: 'off',
        wordWrapColumn: 80,
        wordWrapMinified: true,
        wrappingIndent: WrappingIndent.Same,
        wordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',
        wordWrapBreakAfterCharacters: ' \t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣',
        wordWrapBreakObtrusiveCharacters: '.',
        autoClosingBrackets: true,
        autoIndent: true,
        dragAndDrop: true,
        emptySelectionClipboard: true,
        useTabStops: true,
        multiCursorModifier: 'altKey',
        accessibilitySupport: 'auto',
        viewInfo: {
            extraEditorClassName: '',
            disableMonospaceOptimizations: false,
            rulers: [],
            ariaLabel: nls.localize(1, null),
            renderLineNumbers: true,
            renderCustomLineNumbers: null,
            renderRelativeLineNumbers: false,
            selectOnLineNumbers: true,
            glyphMargin: true,
            revealHorizontalRightPadding: 30,
            roundedSelection: true,
            overviewRulerLanes: 2,
            overviewRulerBorder: true,
            cursorBlinking: TextEditorCursorBlinkingStyle.Blink,
            mouseWheelZoom: false,
            cursorStyle: TextEditorCursorStyle.Line,
            hideCursorInOverviewRuler: false,
            scrollBeyondLastLine: true,
            smoothScrolling: false,
            stopRenderingLineAfter: 10000,
            renderWhitespace: 'none',
            renderControlCharacters: false,
            fontLigatures: false,
            renderIndentGuides: true,
            renderLineHighlight: 'line',
            scrollbar: {
                vertical: scrollable_1.ScrollbarVisibility.Auto,
                horizontal: scrollable_1.ScrollbarVisibility.Auto,
                arrowSize: 11,
                useShadows: true,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                horizontalScrollbarSize: 10,
                horizontalSliderSize: 10,
                verticalScrollbarSize: 14,
                verticalSliderSize: 14,
                handleMouseWheel: true,
                mouseWheelScrollSensitivity: 1,
            },
            minimap: {
                // {{SQL CARBON EDIT}}
                enabled: false,
                showSlider: 'mouseover',
                renderCharacters: true,
                maxColumn: 120
            },
            fixedOverflowWidgets: false,
        },
        contribInfo: {
            selectionClipboard: true,
            hover: true,
            links: true,
            contextmenu: true,
            quickSuggestions: { other: true, comments: false, strings: false },
            quickSuggestionsDelay: 10,
            parameterHints: true,
            iconsInSuggestions: true,
            formatOnType: false,
            formatOnPaste: false,
            suggestOnTriggerCharacters: true,
            acceptSuggestionOnEnter: 'on',
            acceptSuggestionOnCommitCharacter: true,
            snippetSuggestions: 'inline',
            wordBasedSuggestions: true,
            suggestFontSize: 0,
            suggestLineHeight: 0,
            selectionHighlight: true,
            occurrencesHighlight: true,
            codeLens: true,
            folding: true,
            showFoldingControls: 'mouseover',
            matchBrackets: true,
            find: {
                seedSearchStringFromSelection: true,
                autoFindInSelection: false
            },
            colorDecorators: true
        },
    };
});

define(__m[83/*vs/nls!vs/editor/common/modes/modesRegistry*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/editor/common/modes/modesRegistry", data); });
define(__m[84/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostDiagnostics", data); });
define(__m[85/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostExtensionActivator", data); });
define(__m[62/*vs/nls!vs/workbench/api/node/extHostTask*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTask", data); });
define(__m[87/*vs/nls!vs/workbench/api/node/extHostTreeViews*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTreeViews", data); });
define(__m[88/*vs/nls!vs/workbench/node/extensionHostMain*/], __M([18/*vs/nls*/,19/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/node/extensionHostMain", data); });
define(__m[7/*vs/platform/instantiation/common/instantiation*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

define(__m[45/*vs/editor/common/services/modeService*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IModeService = instantiation_1.createDecorator('modeService');
});

define(__m[36/*vs/editor/common/services/modelService*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IModelService = instantiation_1.createDecorator('modelService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[26/*vs/platform/configuration/common/configuration*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/arrays*/,14/*vs/base/common/types*/,11/*vs/base/common/objects*/,6/*vs/base/common/uri*/,21/*vs/base/common/map*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, arrays, types, objects, uri_1, map_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    var ConfigurationSource;
    (function (ConfigurationSource) {
        ConfigurationSource[ConfigurationSource["Default"] = 1] = "Default";
        ConfigurationSource[ConfigurationSource["User"] = 2] = "User";
        ConfigurationSource[ConfigurationSource["Workspace"] = 3] = "Workspace";
    })(ConfigurationSource = exports.ConfigurationSource || (exports.ConfigurationSource = {}));
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                current = current[path[i]];
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    var ConfigurationModel = (function () {
        function ConfigurationModel(_contents, _keys, _overrides) {
            if (_contents === void 0) { _contents = {}; }
            if (_keys === void 0) { _keys = []; }
            if (_overrides === void 0) { _overrides = []; }
            this._contents = _contents;
            this._keys = _keys;
            this._overrides = _overrides;
        }
        Object.defineProperty(ConfigurationModel.prototype, "contents", {
            get: function () {
                return this._contents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "overrides", {
            get: function () {
                return this._overrides;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "keys", {
            get: function () {
                return this._keys;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModel.prototype.getContentsFor = function (section) {
            return objects.clone(this.contents[section]);
        };
        ConfigurationModel.prototype.override = function (identifier) {
            var result = new ConfigurationModel();
            var contents = objects.clone(this.contents);
            if (this._overrides) {
                for (var _i = 0, _a = this._overrides; _i < _a.length; _i++) {
                    var override = _a[_i];
                    if (override.identifiers.indexOf(identifier) !== -1) {
                        merge(contents, override.contents, true);
                    }
                }
            }
            result._contents = contents;
            return result;
        };
        ConfigurationModel.prototype.merge = function (other, overwrite) {
            if (overwrite === void 0) { overwrite = true; }
            var mergedModel = new ConfigurationModel();
            this.doMerge(mergedModel, this, overwrite);
            this.doMerge(mergedModel, other, overwrite);
            return mergedModel;
        };
        ConfigurationModel.prototype.doMerge = function (source, target, overwrite) {
            if (overwrite === void 0) { overwrite = true; }
            merge(source.contents, objects.clone(target.contents), overwrite);
            var overrides = objects.clone(source._overrides);
            var _loop_1 = function (override) {
                var sourceOverride = overrides.filter(function (o) { return arrays.equals(o.identifiers, override.identifiers); })[0];
                if (sourceOverride) {
                    merge(sourceOverride.contents, override.contents, overwrite);
                }
                else {
                    overrides.push(override);
                }
            };
            for (var _i = 0, _a = target._overrides; _i < _a.length; _i++) {
                var override = _a[_i];
                _loop_1(override);
            }
            source._overrides = overrides;
        };
        return ConfigurationModel;
    }());
    exports.ConfigurationModel = ConfigurationModel;
    var Configuration = (function () {
        function Configuration(_defaults, _user, _workspaceConfiguration, folders, _workspace) {
            if (_workspaceConfiguration === void 0) { _workspaceConfiguration = new ConfigurationModel(); }
            if (folders === void 0) { folders = new map_1.StrictResourceMap(); }
            this._defaults = _defaults;
            this._user = _user;
            this._workspaceConfiguration = _workspaceConfiguration;
            this.folders = folders;
            this._workspace = _workspace;
            this.merge();
        }
        Object.defineProperty(Configuration.prototype, "defaults", {
            get: function () {
                return this._defaults;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "user", {
            get: function () {
                return this._user;
            },
            enumerable: true,
            configurable: true
        });
        Configuration.prototype.merge = function () {
            this._globalConfiguration = new ConfigurationModel().merge(this._defaults).merge(this._user);
            this._workspaceConsolidatedConfiguration = new ConfigurationModel().merge(this._globalConfiguration).merge(this._workspaceConfiguration);
            this._legacyWorkspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations = new map_1.StrictResourceMap();
            for (var _i = 0, _a = this.folders.keys(); _i < _a.length; _i++) {
                var folder = _a[_i];
                this.mergeFolder(folder);
            }
        };
        Configuration.prototype.mergeFolder = function (folder) {
            this._foldersConsolidatedConfigurations.set(folder, new ConfigurationModel().merge(this._workspaceConsolidatedConfiguration).merge(this.folders.get(folder)));
        };
        Configuration.prototype.getValue = function (section, overrides) {
            if (section === void 0) { section = ''; }
            if (overrides === void 0) { overrides = {}; }
            var configModel = this.getConsolidateConfigurationModel(overrides);
            return section ? configModel.getContentsFor(section) : configModel.contents;
        };
        Configuration.prototype.lookup = function (key, overrides) {
            if (overrides === void 0) { overrides = {}; }
            // make sure to clone the configuration so that the receiver does not tamper with the values
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides);
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource);
            return {
                default: objects.clone(getConfigurationValue(overrides.overrideIdentifier ? this._defaults.override(overrides.overrideIdentifier).contents : this._defaults.contents, key)),
                user: objects.clone(getConfigurationValue(overrides.overrideIdentifier ? this._user.override(overrides.overrideIdentifier).contents : this._user.contents, key)),
                workspace: objects.clone(this._workspace ? getConfigurationValue(overrides.overrideIdentifier ? this._workspaceConfiguration.override(overrides.overrideIdentifier).contents : this._workspaceConfiguration.contents, key) : void 0),
                folder: objects.clone(folderConfigurationModel ? getConfigurationValue(overrides.overrideIdentifier ? folderConfigurationModel.override(overrides.overrideIdentifier).contents : folderConfigurationModel.contents, key) : void 0),
                value: objects.clone(getConfigurationValue(consolidateConfigurationModel.contents, key))
            };
        };
        Configuration.prototype.lookupLegacy = function (key) {
            if (!this._legacyWorkspaceConsolidatedConfiguration) {
                this._legacyWorkspaceConsolidatedConfiguration = this._workspace ? new ConfigurationModel().merge(this._workspaceConfiguration).merge(this.folders.get(this._workspace.roots[0])) : null;
            }
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel({});
            return {
                default: objects.clone(getConfigurationValue(this._defaults.contents, key)),
                user: objects.clone(getConfigurationValue(this._user.contents, key)),
                workspace: objects.clone(this._legacyWorkspaceConsolidatedConfiguration ? getConfigurationValue(this._legacyWorkspaceConsolidatedConfiguration.contents, key) : void 0),
                folder: void 0,
                value: objects.clone(getConfigurationValue(consolidateConfigurationModel.contents, key))
            };
        };
        Configuration.prototype.keys = function (overrides) {
            if (overrides === void 0) { overrides = {}; }
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource);
            return {
                default: this._defaults.keys,
                user: this._user.keys,
                workspace: this._workspaceConfiguration.keys,
                folder: folderConfigurationModel ? folderConfigurationModel.keys : []
            };
        };
        Configuration.prototype.values = function () {
            var result = Object.create(null);
            var keyset = this.keys();
            var keys = keyset.workspace.concat(keyset.user, keyset.default).sort();
            var lastKey;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                if (key !== lastKey) {
                    lastKey = key;
                    result[key] = this.lookup(key);
                }
            }
            return result;
        };
        Configuration.prototype.values2 = function () {
            var result = new Map();
            var keyset = this.keys();
            var keys = keyset.workspace.concat(keyset.user, keyset.default).sort();
            var lastKey;
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                if (key !== lastKey) {
                    lastKey = key;
                    result.set(key, this.lookup(key));
                }
            }
            return result;
        };
        Configuration.prototype.getConsolidateConfigurationModel = function (overrides) {
            var configurationModel = this.getConsolidatedConfigurationModelForResource(overrides);
            return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
        };
        Configuration.prototype.getConsolidatedConfigurationModelForResource = function (_a) {
            var resource = _a.resource;
            if (!this._workspace) {
                return this._globalConfiguration;
            }
            if (!resource) {
                return this._workspaceConsolidatedConfiguration;
            }
            var root = this._workspace.getRoot(resource);
            if (!root) {
                return this._workspaceConsolidatedConfiguration;
            }
            return this._foldersConsolidatedConfigurations.get(root) || this._workspaceConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConfigurationModelForResource = function (resource) {
            if (!this._workspace || !resource) {
                return null;
            }
            var root = this._workspace.getRoot(resource);
            return root ? this.folders.get(root) : null;
        };
        Configuration.prototype.toData = function () {
            var _this = this;
            return {
                defaults: {
                    contents: this._defaults.contents,
                    overrides: this._defaults.overrides,
                    keys: this._defaults.keys
                },
                user: {
                    contents: this._user.contents,
                    overrides: this._user.overrides,
                    keys: this._user.keys
                },
                workspace: {
                    contents: this._workspaceConfiguration.contents,
                    overrides: this._workspaceConfiguration.overrides,
                    keys: this._workspaceConfiguration.keys
                },
                folders: this.folders.keys().reduce(function (result, folder) {
                    var _a = _this.folders.get(folder), contents = _a.contents, overrides = _a.overrides, keys = _a.keys;
                    result[folder.toString()] = { contents: contents, overrides: overrides, keys: keys };
                    return result;
                }, Object.create({}))
            };
        };
        Configuration.parse = function (data, workspace) {
            var defaultConfiguration = Configuration.parseConfigurationModel(data.defaults);
            var userConfiguration = Configuration.parseConfigurationModel(data.user);
            var workspaceConfiguration = Configuration.parseConfigurationModel(data.workspace);
            var folders = Object.keys(data.folders).reduce(function (result, key) {
                result.set(uri_1.default.parse(key), Configuration.parseConfigurationModel(data.folders[key]));
                return result;
            }, new map_1.StrictResourceMap());
            return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, folders, workspace);
        };
        Configuration.parseConfigurationModel = function (model) {
            return new ConfigurationModel(model.contents, model.keys, model.overrides);
        };
        return Configuration;
    }());
    exports.Configuration = Configuration;
});











define(__m[93/*vs/platform/contextkey/common/contextkey*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContextKeyExprType;
    (function (ContextKeyExprType) {
        ContextKeyExprType[ContextKeyExprType["Defined"] = 1] = "Defined";
        ContextKeyExprType[ContextKeyExprType["Not"] = 2] = "Not";
        ContextKeyExprType[ContextKeyExprType["Equals"] = 3] = "Equals";
        ContextKeyExprType[ContextKeyExprType["NotEquals"] = 4] = "NotEquals";
        ContextKeyExprType[ContextKeyExprType["And"] = 5] = "And";
    })(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));
    var ContextKeyExpr = (function () {
        function ContextKeyExpr() {
        }
        ContextKeyExpr.has = function (key) {
            return new ContextKeyDefinedExpr(key);
        };
        ContextKeyExpr.equals = function (key, value) {
            return new ContextKeyEqualsExpr(key, value);
        };
        ContextKeyExpr.notEquals = function (key, value) {
            return new ContextKeyNotEqualsExpr(key, value);
        };
        ContextKeyExpr.not = function (key) {
            return new ContextKeyNotExpr(key);
        };
        ContextKeyExpr.and = function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            return new ContextKeyAndExpr(expr);
        };
        ContextKeyExpr.deserialize = function (serialized) {
            var _this = this;
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p); }));
            return result.normalize();
        };
        ContextKeyExpr._deserializeOne = function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (/^\!\s*/.test(serializedOne)) {
                return new ContextKeyNotExpr(serializedOne.substr(1).trim());
            }
            return new ContextKeyDefinedExpr(serializedOne);
        };
        ContextKeyExpr._deserializeValue = function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        };
        return ContextKeyExpr;
    }());
    exports.ContextKeyExpr = ContextKeyExpr;
    function cmp(a, b) {
        var aType = a.getType();
        var bType = b.getType();
        if (aType !== bType) {
            return aType - bType;
        }
        switch (aType) {
            case ContextKeyExprType.Defined:
                return a.cmp(b);
            case ContextKeyExprType.Not:
                return a.cmp(b);
            case ContextKeyExprType.Equals:
                return a.cmp(b);
            case ContextKeyExprType.NotEquals:
                return a.cmp(b);
            default:
                throw new Error('Unknown ContextKeyExpr!');
        }
    }
    var ContextKeyDefinedExpr = (function () {
        function ContextKeyDefinedExpr(key) {
            this.key = key;
        }
        ContextKeyDefinedExpr.prototype.getType = function () {
            return ContextKeyExprType.Defined;
        };
        ContextKeyDefinedExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyDefinedExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyDefinedExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyDefinedExpr.prototype.evaluate = function (context) {
            return (!!context.getValue(this.key));
        };
        ContextKeyDefinedExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyDefinedExpr.prototype.serialize = function () {
            return this.key;
        };
        ContextKeyDefinedExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyDefinedExpr;
    }());
    exports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;
    var ContextKeyEqualsExpr = (function () {
        function ContextKeyEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.Equals;
        };
        ContextKeyEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context.getValue(this.key) == this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyDefinedExpr(this.key);
                }
                return new ContextKeyNotExpr(this.key);
            }
            return this;
        };
        ContextKeyEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        ContextKeyEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyEqualsExpr;
    }());
    exports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;
    var ContextKeyNotEqualsExpr = (function () {
        function ContextKeyNotEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyNotEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.NotEquals;
        };
        ContextKeyNotEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context.getValue(this.key) != this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyNotEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyNotExpr(this.key);
                }
                return new ContextKeyDefinedExpr(this.key);
            }
            return this;
        };
        ContextKeyNotEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        ContextKeyNotEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotEqualsExpr;
    }());
    exports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;
    var ContextKeyNotExpr = (function () {
        function ContextKeyNotExpr(key) {
            this.key = key;
        }
        ContextKeyNotExpr.prototype.getType = function () {
            return ContextKeyExprType.Not;
        };
        ContextKeyNotExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyNotExpr.prototype.evaluate = function (context) {
            return (!context.getValue(this.key));
        };
        ContextKeyNotExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyNotExpr.prototype.serialize = function () {
            return '!' + this.key;
        };
        ContextKeyNotExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotExpr;
    }());
    exports.ContextKeyNotExpr = ContextKeyNotExpr;
    var ContextKeyAndExpr = (function () {
        function ContextKeyAndExpr(expr) {
            this.expr = ContextKeyAndExpr._normalizeArr(expr);
        }
        ContextKeyAndExpr.prototype.getType = function () {
            return ContextKeyExprType.And;
        };
        ContextKeyAndExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyAndExpr) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (var i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        ContextKeyAndExpr.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        ContextKeyAndExpr._normalizeArr = function (arr) {
            var expr = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var e = arr[i];
                    if (!e) {
                        continue;
                    }
                    e = e.normalize();
                    if (!e) {
                        continue;
                    }
                    if (e instanceof ContextKeyAndExpr) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                expr.sort(cmp);
            }
            return expr;
        };
        ContextKeyAndExpr.prototype.normalize = function () {
            if (this.expr.length === 0) {
                return null;
            }
            if (this.expr.length === 1) {
                return this.expr[0];
            }
            return this;
        };
        ContextKeyAndExpr.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                return this.normalize().serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        ContextKeyAndExpr.prototype.keys = function () {
            var result = [];
            for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {
                var expr = _a[_i];
                result.push.apply(result, expr.keys());
            }
            return result;
        };
        return ContextKeyAndExpr;
    }());
    exports.ContextKeyAndExpr = ContextKeyAndExpr;
    var RawContextKey = (function (_super) {
        __extends(RawContextKey, _super);
        function RawContextKey(key, defaultValue) {
            var _this = _super.call(this, key) || this;
            _this._defaultValue = defaultValue;
            return _this;
        }
        RawContextKey.prototype.bindTo = function (target) {
            return target.createKey(this.key, this._defaultValue);
        };
        RawContextKey.prototype.getValue = function (target) {
            return target.getContextKeyValue(this.key);
        };
        RawContextKey.prototype.toNegated = function () {
            return ContextKeyExpr.not(this.key);
        };
        RawContextKey.prototype.isEqualTo = function (value) {
            return ContextKeyExpr.equals(this.key, value);
        };
        return RawContextKey;
    }(ContextKeyDefinedExpr));
    exports.RawContextKey = RawContextKey;
    exports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});

define(__m[48/*vs/platform/editor/common/editor*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    /**
     * Possible locations for opening an editor.
     */
    var Position;
    (function (Position) {
        /** Opens the editor in the first position replacing the input currently showing */
        Position[Position["ONE"] = 0] = "ONE";
        /** Opens the editor in the second position replacing the input currently showing */
        Position[Position["TWO"] = 1] = "TWO";
        /** Opens the editor in the third most position replacing the input currently showing */
        Position[Position["THREE"] = 2] = "THREE";
    })(Position = exports.Position || (exports.Position = {}));
    exports.POSITIONS = [Position.ONE, Position.TWO, Position.THREE];
    var Direction;
    (function (Direction) {
        Direction[Direction["LEFT"] = 0] = "LEFT";
        Direction[Direction["RIGHT"] = 1] = "RIGHT";
    })(Direction = exports.Direction || (exports.Direction = {}));
    var Verbosity;
    (function (Verbosity) {
        Verbosity[Verbosity["SHORT"] = 0] = "SHORT";
        Verbosity[Verbosity["MEDIUM"] = 1] = "MEDIUM";
        Verbosity[Verbosity["LONG"] = 2] = "LONG";
    })(Verbosity = exports.Verbosity || (exports.Verbosity = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[49/*vs/platform/environment/common/environment*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEnvironmentService = instantiation_1.createDecorator('environmentService');
});











define(__m[96/*vs/platform/files/common/files*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/paths*/,104/*vs/base/common/events*/,9/*vs/base/common/platform*/,7/*vs/platform/instantiation/common/instantiation*/,8/*vs/base/common/strings*/]), function (require, exports, paths, events, platform_1, instantiation_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IFileService = instantiation_1.createDecorator('fileService');
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
        FileOperation[FileOperation["IMPORT"] = 4] = "IMPORT";
    })(FileOperation = exports.FileOperation || (exports.FileOperation = {}));
    var FileOperationEvent = (function () {
        function FileOperationEvent(_resource, _operation, _target) {
            this._resource = _resource;
            this._operation = _operation;
            this._target = _target;
        }
        Object.defineProperty(FileOperationEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "operation", {
            get: function () {
                return this._operation;
            },
            enumerable: true,
            configurable: true
        });
        return FileOperationEvent;
    }());
    exports.FileOperationEvent = FileOperationEvent;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangesEvent = (function (_super) {
        __extends(FileChangesEvent, _super);
        function FileChangesEvent(changes) {
            var _this = _super.call(this) || this;
            _this._changes = changes;
            return _this;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            return this._changes.some(function (change) {
                if (change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (type === FileChangeType.DELETED) {
                    return paths.isEqualOrParent(resource.fsPath, change.resource.fsPath, !platform_1.isLinux /* ignorecase */);
                }
                return paths.isEqual(resource.fsPath, change.resource.fsPath, !platform_1.isLinux /* ignorecase */);
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(FileChangeType.ADDED);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(FileChangeType.ADDED);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(FileChangeType.DELETED);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(FileChangeType.DELETED);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(FileChangeType.UPDATED);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(FileChangeType.UPDATED);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }(events.Event));
    exports.FileChangesEvent = FileChangesEvent;
    function isParent(path, candidate, ignoreCase) {
        if (!path || !candidate || path === candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (candidate.charAt(candidate.length - 1) !== paths.nativeSep) {
            candidate += paths.nativeSep;
        }
        if (ignoreCase) {
            return strings_1.beginsWithIgnoreCase(path, candidate);
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isParent = isParent;
    function indexOf(path, candidate, ignoreCase) {
        if (candidate.length > path.length) {
            return -1;
        }
        if (path === candidate) {
            return 0;
        }
        if (ignoreCase) {
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        return path.indexOf(candidate);
    }
    exports.indexOf = indexOf;
    var FileOperationError = (function (_super) {
        __extends(FileOperationError, _super);
        function FileOperationError(message, fileOperationResult) {
            var _this = _super.call(this, message) || this;
            _this.fileOperationResult = fileOperationResult;
            return _this;
        }
        return FileOperationError;
    }(Error));
    exports.FileOperationError = FileOperationError;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 8] = "FILE_INVALID_PATH";
    })(FileOperationResult = exports.FileOperationResult || (exports.FileOperationResult = {}));
    // See https://github.com/Microsoft/vscode/issues/30180
    var WIN32_MAX_FILE_SIZE = 300 * 1024 * 1024; // 300 MB
    var GENERAL_MAX_FILE_SIZE = 16 * 1024 * 1024 * 1024; // 16 GB
    exports.MAX_FILE_SIZE = (typeof process === 'object' ? (process.arch === 'ia32' ? WIN32_MAX_FILE_SIZE : GENERAL_MAX_FILE_SIZE) : WIN32_MAX_FILE_SIZE);
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.HotExitConfiguration = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        cp852: {
            labelLong: 'Central European (CP 852)',
            labelShort: 'CP 852',
            order: 18
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 19
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 20
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 21
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 22
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 23
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 24
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 25
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 26
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 27
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 28
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 29
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 30
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 31
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 32
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 33
        },
        gbk: {
            labelLong: 'Chinese (GBK)',
            labelShort: 'GBK',
            order: 34
        },
        gb18030: {
            labelLong: 'Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 35
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 36
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 37
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 38
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 39
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 40
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 41
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 42
        },
        koi8ru: {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 43
        },
        koi8t: {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 44
        },
        gb2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 45
        }
    };
    var FileKind;
    (function (FileKind) {
        FileKind[FileKind["FILE"] = 0] = "FILE";
        FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
        FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind = exports.FileKind || (exports.FileKind = {}));
});

define(__m[97/*vs/platform/keybinding/common/keybinding*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingSource;
    (function (KeybindingSource) {
        KeybindingSource[KeybindingSource["Default"] = 1] = "Default";
        KeybindingSource[KeybindingSource["User"] = 2] = "User";
    })(KeybindingSource = exports.KeybindingSource || (exports.KeybindingSource = {}));
    exports.IKeybindingService = instantiation_1.createDecorator('keybindingService');
});

define(__m[98/*vs/platform/lifecycle/common/lifecycle*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, winjs_base_1, event_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');
    var ShutdownReason;
    (function (ShutdownReason) {
        /** Window is closed */
        ShutdownReason[ShutdownReason["CLOSE"] = 1] = "CLOSE";
        /** Application is quit */
        ShutdownReason[ShutdownReason["QUIT"] = 2] = "QUIT";
        /** Window is reloaded */
        ShutdownReason[ShutdownReason["RELOAD"] = 3] = "RELOAD";
        /** Other configuration loaded into window */
        ShutdownReason[ShutdownReason["LOAD"] = 4] = "LOAD";
    })(ShutdownReason = exports.ShutdownReason || (exports.ShutdownReason = {}));
    var StartupKind;
    (function (StartupKind) {
        StartupKind[StartupKind["NewWindow"] = 1] = "NewWindow";
        StartupKind[StartupKind["ReloadedWindow"] = 3] = "ReloadedWindow";
        StartupKind[StartupKind["ReopenedWindow"] = 4] = "ReopenedWindow";
    })(StartupKind = exports.StartupKind || (exports.StartupKind = {}));
    var LifecyclePhase;
    (function (LifecyclePhase) {
        LifecyclePhase[LifecyclePhase["Starting"] = 1] = "Starting";
        LifecyclePhase[LifecyclePhase["Running"] = 2] = "Running";
        LifecyclePhase[LifecyclePhase["ShuttingDown"] = 3] = "ShuttingDown";
    })(LifecyclePhase = exports.LifecyclePhase || (exports.LifecyclePhase = {}));
    exports.NullLifecycleService = {
        _serviceBrand: null,
        phase: LifecyclePhase.Running,
        startupKind: StartupKind.NewWindow,
        onDidChangePhase: event_1.default.None,
        onWillShutdown: event_1.default.None,
        onShutdown: event_1.default.None
    };
    // Shared veto handling across main and renderer
    function handleVetos(vetos, onError) {
        if (vetos.length === 0) {
            return winjs_base_1.TPromise.as(false);
        }
        var promises = [];
        var lazyValue = false;
        for (var _i = 0, vetos_1 = vetos; _i < vetos_1.length; _i++) {
            var valueOrPromise = vetos_1[_i];
            // veto, done
            if (valueOrPromise === true) {
                return winjs_base_1.TPromise.as(true);
            }
            if (winjs_base_1.TPromise.is(valueOrPromise)) {
                promises.push(valueOrPromise.then(function (value) {
                    if (value) {
                        lazyValue = true; // veto, done
                    }
                }, function (err) {
                    onError(err); // error, treated like a veto, done
                    lazyValue = true;
                }));
            }
        }
        return winjs_base_1.TPromise.join(promises).then(function () { return lazyValue; });
    }
    exports.handleVetos = handleVetos;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[99/*vs/platform/node/package*/], __M([1/*require*/,0/*exports*/,20/*path*/,6/*vs/base/common/uri*/]), function (require, exports, path, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(uri_1.default.parse(require.toUrl('')).fsPath);
    var packageJsonPath = path.join(rootPath, 'package.json');
    exports.default = require.__$__nodeRequire(packageJsonPath);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[100/*vs/platform/node/product*/], __M([1/*require*/,0/*exports*/,20/*path*/,6/*vs/base/common/uri*/]), function (require, exports, path, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(uri_1.default.parse(require.toUrl('')).fsPath);
    var productJsonPath = path.join(rootPath, 'product.json');
    var product = require.__$__nodeRequire(productJsonPath);
    if (process.env['VSCODE_DEV']) {
        product.nameShort += ' Dev';
        product.nameLong += ' Dev';
        product.dataFolderName += '-dev';
    }
    exports.default = product;
});

define(__m[50/*vs/platform/progress/common/progress*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IProgressService = instantiation_1.createDecorator('progressService');
    exports.emptyProgress = Object.freeze({ report: function () { } });
    var Progress = (function () {
        function Progress(callback) {
            this._callback = callback;
        }
        Object.defineProperty(Progress.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Progress.prototype.report = function (item) {
            this._value = item;
            this._callback(this._value);
        };
        return Progress;
    }());
    exports.Progress = Progress;
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["Scm"] = 1] = "Scm";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    exports.IProgressService2 = instantiation_1.createDecorator('progressService2');
});

define(__m[102/*vs/platform/registry/common/platform*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/,30/*vs/base/common/assert*/]), function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RegistryImpl = (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
    /**
     * A base class for registries that leverage the instantiation service to create instances.
     */
    var BaseRegistry = (function () {
        function BaseRegistry() {
            this.toBeInstantiated = [];
            this.instances = [];
        }
        BaseRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            while (this.toBeInstantiated.length > 0) {
                var entry = this.toBeInstantiated.shift();
                this.instantiate(entry);
            }
        };
        BaseRegistry.prototype.instantiate = function (ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.instances.push(instance);
        };
        BaseRegistry.prototype._register = function (ctor) {
            if (this.instantiationService) {
                this.instantiate(ctor);
            }
            else {
                this.toBeInstantiated.push(ctor);
            }
        };
        BaseRegistry.prototype._getInstances = function () {
            return this.instances.slice(0);
        };
        BaseRegistry.prototype._setInstances = function (instances) {
            this.instances = instances;
        };
        return BaseRegistry;
    }());
    exports.BaseRegistry = BaseRegistry;
});

define(__m[39/*vs/editor/common/modes/modesRegistry*/], __M([1/*require*/,0/*exports*/,83/*vs/nls!vs/editor/common/modes/modesRegistry*/,3/*vs/base/common/event*/,102/*vs/platform/registry/common/platform*/,68/*vs/editor/common/modes/languageConfigurationRegistry*/,38/*vs/editor/common/modes*/]), function (require, exports, nls, event_1, platform_1, languageConfigurationRegistry_1, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Define extension point ids
    exports.Extensions = {
        ModesRegistry: 'editor.modesRegistry'
    };
    var EditorModesRegistry = (function () {
        function EditorModesRegistry() {
            this._onDidAddLanguages = new event_1.Emitter();
            this.onDidAddLanguages = this._onDidAddLanguages.event;
            this._languages = [];
        }
        // --- languages
        EditorModesRegistry.prototype.registerLanguage = function (def) {
            this._languages.push(def);
            this._onDidAddLanguages.fire([def]);
        };
        EditorModesRegistry.prototype.registerLanguages = function (def) {
            this._languages = this._languages.concat(def);
            this._onDidAddLanguages.fire(def);
        };
        EditorModesRegistry.prototype.getLanguages = function () {
            return this._languages.slice(0);
        };
        return EditorModesRegistry;
    }());
    exports.EditorModesRegistry = EditorModesRegistry;
    exports.ModesRegistry = new EditorModesRegistry();
    platform_1.Registry.add(exports.Extensions.ModesRegistry, exports.ModesRegistry);
    exports.PLAINTEXT_MODE_ID = 'plaintext';
    exports.PLAINTEXT_LANGUAGE_IDENTIFIER = new modes_1.LanguageIdentifier(exports.PLAINTEXT_MODE_ID, 1 /* PlainText */);
    exports.ModesRegistry.registerLanguage({
        id: exports.PLAINTEXT_MODE_ID,
        extensions: ['.txt', '.gitignore'],
        aliases: [nls.localize(0, null), 'text'],
        mimetypes: ['text/plain']
    });
    languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(exports.PLAINTEXT_LANGUAGE_IDENTIFIER, {
        brackets: [
            ['(', ')'],
            ['[', ']'],
            ['{', '}'],
        ]
    });
});

define(__m[52/*vs/platform/search/common/search*/], __M([1/*require*/,0/*exports*/,11/*vs/base/common/objects*/,13/*vs/base/common/paths*/,28/*vs/base/common/glob*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, objects, paths, glob, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ID = 'searchService';
    exports.ISearchService = instantiation_1.createDecorator(exports.ID);
    var QueryType;
    (function (QueryType) {
        QueryType[QueryType["File"] = 1] = "File";
        QueryType[QueryType["Text"] = 2] = "Text";
    })(QueryType = exports.QueryType || (exports.QueryType = {}));
    // ---- very simple implementation of the search model --------------------
    var FileMatch = (function () {
        function FileMatch(resource) {
            this.resource = resource;
            this.lineMatches = [];
            // empty
        }
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var LineMatch = (function () {
        function LineMatch(preview, lineNumber, offsetAndLengths) {
            this.preview = preview;
            this.lineNumber = lineNumber;
            this.offsetAndLengths = offsetAndLengths;
            // empty
        }
        return LineMatch;
    }());
    exports.LineMatch = LineMatch;
    function getExcludes(configuration) {
        var fileExcludes = configuration && configuration.files && configuration.files.exclude;
        var searchExcludes = configuration && configuration.search && configuration.search.exclude;
        if (!fileExcludes && !searchExcludes) {
            return undefined;
        }
        if (!fileExcludes || !searchExcludes) {
            return fileExcludes || searchExcludes;
        }
        var allExcludes = Object.create(null);
        allExcludes = objects.mixin(allExcludes, fileExcludes);
        allExcludes = objects.mixin(allExcludes, searchExcludes, true);
        return allExcludes;
    }
    exports.getExcludes = getExcludes;
    function pathIncludedInQuery(query, fsPath) {
        if (query.excludePattern && glob.match(query.excludePattern, fsPath)) {
            return false;
        }
        if (query.includePattern && !glob.match(query.includePattern, fsPath)) {
            return false;
        }
        // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present
        if (query.usingSearchPaths) {
            return query.folderQueries.every(function (fq) {
                var searchPath = fq.folder.fsPath;
                if (paths.isEqualOrParent(fsPath, searchPath)) {
                    return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);
                }
                else {
                    return false;
                }
            });
        }
        return true;
    }
    exports.pathIncludedInQuery = pathIncludedInQuery;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[105/*vs/platform/statusbar/common/statusbar*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStatusbarService = instantiation_1.createDecorator('statusbarService');
    var StatusbarAlignment;
    (function (StatusbarAlignment) {
        StatusbarAlignment[StatusbarAlignment["LEFT"] = 0] = "LEFT";
        StatusbarAlignment[StatusbarAlignment["RIGHT"] = 1] = "RIGHT";
    })(StatusbarAlignment = exports.StatusbarAlignment || (exports.StatusbarAlignment = {}));
});

define(__m[106/*vs/platform/telemetry/common/telemetryUtils*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,54/*vs/base/common/mime*/,13/*vs/base/common/paths*/,26/*vs/platform/configuration/common/configuration*/,97/*vs/platform/keybinding/common/keybinding*/,98/*vs/platform/lifecycle/common/lifecycle*/]), function (require, exports, winjs_base_1, mime_1, paths, configuration_1, keybinding_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullTelemetryService = {
        _serviceBrand: undefined,
        publicLog: function (eventName, data) {
            return winjs_base_1.TPromise.as(null);
        },
        isOptedIn: true,
        getTelemetryInfo: function () {
            return winjs_base_1.TPromise.as({
                instanceId: 'someValue.instanceId',
                sessionId: 'someValue.sessionId',
                machineId: 'someValue.machineId'
            });
        }
    };
    function combinedAppender() {
        var appenders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            appenders[_i] = arguments[_i];
        }
        return { log: function (e, d) { return appenders.forEach(function (a) { return a.log(e, d); }); } };
    }
    exports.combinedAppender = combinedAppender;
    exports.NullAppender = { log: function () { return null; } };
    // --- util
    function anonymize(input) {
        if (!input) {
            return input;
        }
        var r = '';
        for (var i = 0; i < input.length; i++) {
            var ch = input[i];
            if (ch >= '0' && ch <= '9') {
                r += '0';
                continue;
            }
            if (ch >= 'a' && ch <= 'z') {
                r += 'a';
                continue;
            }
            if (ch >= 'A' && ch <= 'Z') {
                r += 'A';
                continue;
            }
            r += ch;
        }
        return r;
    }
    exports.anonymize = anonymize;
    function telemetryURIDescriptor(uri) {
        var fsPath = uri && uri.fsPath;
        return fsPath ? { mimeType: mime_1.guessMimeTypes(fsPath).join(', '), ext: paths.extname(fsPath), path: anonymize(fsPath) } : {};
    }
    exports.telemetryURIDescriptor = telemetryURIDescriptor;
    /**
     * Only add settings that cannot contain any personal/private information of users (PII).
     */
    var configurationValueWhitelist = [
        'editor.tabCompletion',
        'editor.fontFamily',
        'editor.fontWeight',
        'editor.fontSize',
        'editor.lineHeight',
        'editor.letterSpacing',
        'editor.lineNumbers',
        'editor.rulers',
        'editor.wordSeparators',
        'editor.tabSize',
        'editor.insertSpaces',
        'editor.detectIndentation',
        'editor.roundedSelection',
        'editor.scrollBeyondLastLine',
        'editor.minimap.enabled',
        'editor.minimap.renderCharacters',
        'editor.minimap.maxColumn',
        'editor.find.seedSearchStringFromSelection',
        'editor.find.autoFindInSelection',
        'editor.wordWrap',
        'editor.wordWrapColumn',
        'editor.wrappingIndent',
        'editor.mouseWheelScrollSensitivity',
        'editor.multiCursorModifier',
        'editor.quickSuggestions',
        'editor.quickSuggestionsDelay',
        'editor.parameterHints',
        'editor.autoClosingBrackets',
        'editor.autoIndent',
        'editor.formatOnType',
        'editor.formatOnPaste',
        'editor.suggestOnTriggerCharacters',
        'editor.acceptSuggestionOnEnter',
        'editor.acceptSuggestionOnCommitCharacter',
        'editor.snippetSuggestions',
        'editor.emptySelectionClipboard',
        'editor.wordBasedSuggestions',
        'editor.suggestFontSize',
        'editor.suggestLineHeight',
        'editor.selectionHighlight',
        'editor.occurrencesHighlight',
        'editor.overviewRulerLanes',
        'editor.overviewRulerBorder',
        'editor.cursorBlinking',
        'editor.cursorStyle',
        'editor.mouseWheelZoom',
        'editor.fontLigatures',
        'editor.hideCursorInOverviewRuler',
        'editor.renderWhitespace',
        'editor.renderControlCharacters',
        'editor.renderIndentGuides',
        'editor.renderLineHighlight',
        'editor.codeLens',
        'editor.folding',
        'editor.showFoldingControls',
        'editor.matchBrackets',
        'editor.glyphMargin',
        'editor.useTabStops',
        'editor.trimAutoWhitespace',
        'editor.stablePeek',
        'editor.dragAndDrop',
        'editor.formatOnSave',
        'editor.colorDecorators',
        'window.zoomLevel',
        'files.autoSave',
        'files.hotExit',
        'files.associations',
        'workbench.statusBar.visible',
        'files.trimTrailingWhitespace',
        'git.confirmSync',
        'workbench.sideBar.location',
        'window.openFilesInNewWindow',
        'javascript.validate.enable',
        'window.reopenFolders',
        'window.restoreWindows',
        'extensions.autoUpdate',
        'files.eol',
        'explorer.openEditors.visible',
        'workbench.editor.enablePreview',
        'files.autoSaveDelay',
        'workbench.editor.showTabs',
        'files.encoding',
        'files.autoGuessEncoding',
        'git.enabled',
        'http.proxyStrictSSL',
        'terminal.integrated.fontFamily',
        'workbench.editor.enablePreviewFromQuickOpen',
        'workbench.editor.swipeToNavigate',
        'php.builtInCompletions.enable',
        'php.validate.enable',
        'php.validate.run',
        'workbench.welcome.enabled',
        'workbench.startupEditor',
    ];
    function configurationTelemetry(telemetryService, configurationService) {
        return configurationService.onDidUpdateConfiguration(function (event) {
            if (event.source !== configuration_1.ConfigurationSource.Default) {
                telemetryService.publicLog('updateConfiguration', {
                    configurationSource: configuration_1.ConfigurationSource[event.source],
                    configurationKeys: flattenKeys(event.sourceConfig)
                });
                telemetryService.publicLog('updateConfigurationValues', {
                    configurationSource: configuration_1.ConfigurationSource[event.source],
                    configurationValues: flattenValues(event.sourceConfig, configurationValueWhitelist)
                });
            }
        });
    }
    exports.configurationTelemetry = configurationTelemetry;
    function lifecycleTelemetry(telemetryService, lifecycleService) {
        return lifecycleService.onShutdown(function (event) {
            telemetryService.publicLog('shutdown', { reason: lifecycle_1.ShutdownReason[event] });
        });
    }
    exports.lifecycleTelemetry = lifecycleTelemetry;
    function keybindingsTelemetry(telemetryService, keybindingService) {
        return keybindingService.onDidUpdateKeybindings(function (event) {
            if (event.source === keybinding_1.KeybindingSource.User && event.keybindings) {
                telemetryService.publicLog('updateKeybindings', {
                    bindings: event.keybindings.map(function (binding) { return ({
                        key: binding.key,
                        command: binding.command,
                        when: binding.when,
                        args: binding.args ? true : undefined
                    }); })
                });
            }
        });
    }
    exports.keybindingsTelemetry = keybindingsTelemetry;
    function flattenKeys(value) {
        if (!value) {
            return [];
        }
        var result = [];
        flatKeys(result, '', value);
        return result;
    }
    function flatKeys(result, prefix, value) {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            Object.keys(value)
                .forEach(function (key) { return flatKeys(result, prefix ? prefix + "." + key : key, value[key]); });
        }
        else {
            result.push(prefix);
        }
    }
    function flattenValues(value, keys) {
        if (!value) {
            return [];
        }
        return keys.reduce(function (array, key) {
            var v = key.split('.')
                .reduce(function (tmp, k) { return tmp && typeof tmp === 'object' ? tmp[k] : undefined; }, value);
            if (typeof v !== 'undefined') {
                array.push((_a = {}, _a[key] = v, _a));
            }
            return array;
            var _a;
        }, []);
    }
});

define(__m[31/*vs/platform/workspace/common/workspace*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,7/*vs/platform/instantiation/common/instantiation*/,13/*vs/base/common/paths*/,21/*vs/base/common/map*/,9/*vs/base/common/platform*/,15/*vs/base/common/arrays*/]), function (require, exports, uri_1, instantiation_1, paths, map_1, platform_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var LegacyWorkspace = (function () {
        function LegacyWorkspace(_resource, _ctime) {
            this._resource = _resource;
            this._ctime = _ctime;
            this._name = paths.basename(this._resource.fsPath) || this._resource.fsPath;
        }
        Object.defineProperty(LegacyWorkspace.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LegacyWorkspace.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LegacyWorkspace.prototype, "ctime", {
            get: function () {
                return this._ctime;
            },
            enumerable: true,
            configurable: true
        });
        LegacyWorkspace.prototype.toResource = function (workspaceRelativePath, root) {
            if (typeof workspaceRelativePath === 'string') {
                return uri_1.default.file(paths.join(root ? root.fsPath : this._resource.fsPath, workspaceRelativePath));
            }
            return null;
        };
        return LegacyWorkspace;
    }());
    exports.LegacyWorkspace = LegacyWorkspace;
    var Workspace = (function () {
        function Workspace(id, _name, roots, _configuration) {
            if (_configuration === void 0) { _configuration = null; }
            this.id = id;
            this._name = _name;
            this._configuration = _configuration;
            this._rootsMap = new map_1.TrieMap();
            this.roots = roots;
        }
        Workspace.prototype.ensureUnique = function (roots) {
            return arrays_1.distinct(roots, function (root) { return platform_1.isLinux ? root.fsPath : root.fsPath.toLowerCase(); });
        };
        Object.defineProperty(Workspace.prototype, "roots", {
            get: function () {
                return this._roots;
            },
            set: function (roots) {
                this._roots = this.ensureUnique(roots);
                this.updateRootsMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "configuration", {
            get: function () {
                return this._configuration;
            },
            set: function (configuration) {
                this._configuration = configuration;
            },
            enumerable: true,
            configurable: true
        });
        Workspace.prototype.getRoot = function (resource) {
            if (!resource) {
                return null;
            }
            return this._rootsMap.findSubstr(resource.fsPath);
        };
        Workspace.prototype.updateRootsMap = function () {
            this._rootsMap = new map_1.TrieMap();
            for (var _i = 0, _a = this.roots; _i < _a.length; _i++) {
                var root = _a[_i];
                this._rootsMap.insert(root.fsPath, root);
            }
        };
        Workspace.prototype.toJSON = function () {
            return { id: this.id, roots: this.roots, name: this.name };
        };
        return Workspace;
    }());
    exports.Workspace = Workspace;
});











define(__m[108/*vs/workbench/api/node/extHostExtensionActivator*/], __M([1/*require*/,0/*exports*/,85/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/,25/*vs/base/common/severity*/,2/*vs/base/common/winjs.base*/]), function (require, exports, nls, severity_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var NO_OP_VOID_PROMISE = winjs_base_1.TPromise.as(void 0);
    var ExtensionActivationTimes = (function () {
        function ExtensionActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
        }
        ExtensionActivationTimes.NONE = new ExtensionActivationTimes(false, -1, -1, -1);
        return ExtensionActivationTimes;
    }());
    exports.ExtensionActivationTimes = ExtensionActivationTimes;
    var ExtensionActivationTimesBuilder = (function () {
        function ExtensionActivationTimesBuilder(startup) {
            this._startup = startup;
            this._codeLoadingStart = -1;
            this._codeLoadingStop = -1;
            this._activateCallStart = -1;
            this._activateCallStop = -1;
            this._activateResolveStart = -1;
            this._activateResolveStop = -1;
        }
        ExtensionActivationTimesBuilder.prototype._delta = function (start, stop) {
            if (start === -1 || stop === -1) {
                return -1;
            }
            return stop - start;
        };
        ExtensionActivationTimesBuilder.prototype.build = function () {
            return new ExtensionActivationTimes(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop));
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStart = function () {
            this._codeLoadingStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStop = function () {
            this._codeLoadingStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStart = function () {
            this._activateCallStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStop = function () {
            this._activateCallStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStart = function () {
            this._activateResolveStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStop = function () {
            this._activateResolveStop = Date.now();
        };
        return ExtensionActivationTimesBuilder;
    }());
    exports.ExtensionActivationTimesBuilder = ExtensionActivationTimesBuilder;
    var ActivatedExtension = (function () {
        function ActivatedExtension(activationFailed, activationTimes, module, exports, subscriptions) {
            this.activationFailed = activationFailed;
            this.activationTimes = activationTimes;
            this.module = module;
            this.exports = exports;
            this.subscriptions = subscriptions;
        }
        return ActivatedExtension;
    }());
    exports.ActivatedExtension = ActivatedExtension;
    var EmptyExtension = (function (_super) {
        __extends(EmptyExtension, _super);
        function EmptyExtension(activationTimes) {
            return _super.call(this, false, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return EmptyExtension;
    }(ActivatedExtension));
    exports.EmptyExtension = EmptyExtension;
    var FailedExtension = (function (_super) {
        __extends(FailedExtension, _super);
        function FailedExtension(activationTimes) {
            return _super.call(this, true, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return FailedExtension;
    }(ActivatedExtension));
    exports.FailedExtension = FailedExtension;
    var ExtensionsActivator = (function () {
        function ExtensionsActivator(registry, host) {
            this._registry = registry;
            this._host = host;
            this._activatingExtensions = {};
            this._activatedExtensions = {};
            this._alreadyActivatedEvents = Object.create(null);
        }
        ExtensionsActivator.prototype.isActivated = function (extensionId) {
            return hasOwnProperty.call(this._activatedExtensions, extensionId);
        };
        ExtensionsActivator.prototype.getActivatedExtension = function (extensionId) {
            if (!hasOwnProperty.call(this._activatedExtensions, extensionId)) {
                throw new Error('Extension `' + extensionId + '` is not known or not activated');
            }
            return this._activatedExtensions[extensionId];
        };
        ExtensionsActivator.prototype.activateByEvent = function (activationEvent, startup) {
            var _this = this;
            if (this._alreadyActivatedEvents[activationEvent]) {
                return NO_OP_VOID_PROMISE;
            }
            var activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
            return this._activateExtensions(activateExtensions, startup, 0).then(function () {
                _this._alreadyActivatedEvents[activationEvent] = true;
            });
        };
        ExtensionsActivator.prototype.activateById = function (extensionId, startup) {
            var desc = this._registry.getExtensionDescription(extensionId);
            if (!desc) {
                throw new Error('Extension `' + extensionId + '` is not known');
            }
            return this._activateExtensions([desc], startup, 0);
        };
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * semantics: `redExtensions` must wait for `greenExtensions`.
         */
        ExtensionsActivator.prototype._handleActivateRequest = function (currentExtension, greenExtensions, redExtensions) {
            var depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            var currentExtensionGetsGreenLight = true;
            for (var j = 0, lenJ = depIds.length; j < lenJ; j++) {
                var depId = depIds[j];
                var depDesc = this._registry.getExtensionDescription(depId);
                if (!depDesc) {
                    // Error condition 1: unknown dependency
                    this._host.showMessage(severity_1.default.Error, nls.localize(0, null, depId, currentExtension.id));
                    this._activatedExtensions[currentExtension.id] = new FailedExtension(ExtensionActivationTimes.NONE);
                    return;
                }
                if (hasOwnProperty.call(this._activatedExtensions, depId)) {
                    var dep = this._activatedExtensions[depId];
                    if (dep.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        this._host.showMessage(severity_1.default.Error, nls.localize(1, null, depId, currentExtension.id));
                        this._activatedExtensions[currentExtension.id] = new FailedExtension(ExtensionActivationTimes.NONE);
                        return;
                    }
                }
                else {
                    // must first wait for the dependency to activate
                    currentExtensionGetsGreenLight = false;
                    greenExtensions[depId] = depDesc;
                }
            }
            if (currentExtensionGetsGreenLight) {
                greenExtensions[currentExtension.id] = currentExtension;
            }
            else {
                redExtensions.push(currentExtension);
            }
        };
        ExtensionsActivator.prototype._activateExtensions = function (extensionDescriptions, startup, recursionLevel) {
            var _this = this;
            // console.log(recursionLevel, '_activateExtensions: ', extensionDescriptions.map(p => p.id));
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            extensionDescriptions = extensionDescriptions.filter(function (p) { return !hasOwnProperty.call(_this._activatedExtensions, p.id); });
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (recursionLevel > 10) {
                // More than 10 dependencies deep => most likely a dependency loop
                for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                    // Error condition 3: dependency loop
                    this._host.showMessage(severity_1.default.Error, nls.localize(2, null, extensionDescriptions[i].id));
                    this._activatedExtensions[extensionDescriptions[i].id] = new FailedExtension(ExtensionActivationTimes.NONE);
                }
                return winjs_base_1.TPromise.as(void 0);
            }
            var greenMap = Object.create(null), red = [];
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                this._handleActivateRequest(extensionDescriptions[i], greenMap, red);
            }
            // Make sure no red is also green
            for (var i = 0, len = red.length; i < len; i++) {
                if (greenMap[red[i].id]) {
                    delete greenMap[red[i].id];
                }
            }
            var green = Object.keys(greenMap).map(function (id) { return greenMap[id]; });
            // console.log('greenExtensions: ', green.map(p => p.id));
            // console.log('redExtensions: ', red.map(p => p.id));
            if (red.length === 0) {
                // Finally reached only leafs!
                return winjs_base_1.TPromise.join(green.map(function (p) { return _this._activateExtension(p, startup); })).then(function (_) { return void 0; });
            }
            return this._activateExtensions(green, startup, recursionLevel + 1).then(function (_) {
                return _this._activateExtensions(red, startup, recursionLevel + 1);
            });
        };
        ExtensionsActivator.prototype._activateExtension = function (extensionDescription, startup) {
            var _this = this;
            if (hasOwnProperty.call(this._activatedExtensions, extensionDescription.id)) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (hasOwnProperty.call(this._activatingExtensions, extensionDescription.id)) {
                return this._activatingExtensions[extensionDescription.id];
            }
            this._activatingExtensions[extensionDescription.id] = this._host.actualActivateExtension(extensionDescription, startup).then(null, function (err) {
                _this._host.showMessage(severity_1.default.Error, nls.localize(3, null, extensionDescription.id, err.message));
                console.error('Activating extension `' + extensionDescription.id + '` failed: ', err.message);
                console.log('Here is the error stack: ', err.stack);
                // Treat the extension as being empty
                return new FailedExtension(ExtensionActivationTimes.NONE);
            }).then(function (x) {
                _this._activatedExtensions[extensionDescription.id] = x;
                delete _this._activatingExtensions[extensionDescription.id];
            });
            return this._activatingExtensions[extensionDescription.id];
        };
        return ExtensionsActivator;
    }());
    exports.ExtensionsActivator = ExtensionsActivator;
});

define(__m[109/*vs/workbench/api/node/extHostHeapService*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostHeapService = (function () {
        function ExtHostHeapService() {
            this._data = new Map();
        }
        ExtHostHeapService.prototype.keep = function (obj) {
            var id = ExtHostHeapService._idPool++;
            this._data.set(id, obj);
            return id;
        };
        ExtHostHeapService.prototype.delete = function (id) {
            return this._data.delete(id);
        };
        ExtHostHeapService.prototype.get = function (id) {
            return this._data.get(id);
        };
        ExtHostHeapService.prototype.$onGarbageCollection = function (ids) {
            for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                var id = ids_1[_i];
                this.delete(id);
            }
        };
        ExtHostHeapService._idPool = 0;
        return ExtHostHeapService;
    }());
    exports.ExtHostHeapService = ExtHostHeapService;
});











define(__m[5/*vs/workbench/api/node/extHostTypes*/], __M([1/*require*/,0/*exports*/,165/*crypto*/,6/*vs/base/common/uri*/,90/*vs/base/common/color*/,12/*vs/base/common/errors*/,27/*vs/base/common/htmlContent*/]), function (require, exports, crypto, uri_1, color_1, errors_1, htmlContent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Disposable = (function () {
        function Disposable(callOnDispose) {
            this._callOnDispose = callOnDispose;
        }
        Disposable.from = function () {
            var disposables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                disposables[_i] = arguments[_i];
            }
            return new Disposable(function () {
                if (disposables) {
                    for (var _i = 0, disposables_1 = disposables; _i < disposables_1.length; _i++) {
                        var disposable = disposables_1[_i];
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            });
        };
        Disposable.prototype.dispose = function () {
            if (typeof this._callOnDispose === 'function') {
                this._callOnDispose();
                this._callOnDispose = undefined;
            }
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Position = (function () {
        function Position(line, character) {
            if (line < 0) {
                throw errors_1.illegalArgument('line must be positive');
            }
            if (character < 0) {
                throw errors_1.illegalArgument('character must be positive');
            }
            this._line = line;
            this._character = character;
        }
        Position.Min = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_1 = positions; _a < positions_1.length; _a++) {
                var p = positions_1[_a];
                if (p.isBefore(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.Max = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {
                var p = positions_2[_a];
                if (p.isAfter(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.isPosition = function (other) {
            if (!other) {
                return false;
            }
            if (other instanceof Position) {
                return true;
            }
            var _a = other, line = _a.line, character = _a.character;
            if (typeof line === 'number' && typeof character === 'number') {
                return true;
            }
            return false;
        };
        Object.defineProperty(Position.prototype, "line", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Position.prototype, "character", {
            get: function () {
                return this._character;
            },
            enumerable: true,
            configurable: true
        });
        Position.prototype.isBefore = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character < other._character;
        };
        Position.prototype.isBeforeOrEqual = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character <= other._character;
        };
        Position.prototype.isAfter = function (other) {
            return !this.isBeforeOrEqual(other);
        };
        Position.prototype.isAfterOrEqual = function (other) {
            return !this.isBefore(other);
        };
        Position.prototype.isEqual = function (other) {
            return this._line === other._line && this._character === other._character;
        };
        Position.prototype.compareTo = function (other) {
            if (this._line < other._line) {
                return -1;
            }
            else if (this._line > other.line) {
                return 1;
            }
            else {
                // equal line
                if (this._character < other._character) {
                    return -1;
                }
                else if (this._character > other._character) {
                    return 1;
                }
                else {
                    // equal line and character
                    return 0;
                }
            }
        };
        Position.prototype.translate = function (lineDeltaOrChange, characterDelta) {
            if (characterDelta === void 0) { characterDelta = 0; }
            if (lineDeltaOrChange === null || characterDelta === null) {
                throw errors_1.illegalArgument();
            }
            var lineDelta;
            if (typeof lineDeltaOrChange === 'undefined') {
                lineDelta = 0;
            }
            else if (typeof lineDeltaOrChange === 'number') {
                lineDelta = lineDeltaOrChange;
            }
            else {
                lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
                characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
            }
            if (lineDelta === 0 && characterDelta === 0) {
                return this;
            }
            return new Position(this.line + lineDelta, this.character + characterDelta);
        };
        Position.prototype.with = function (lineOrChange, character) {
            if (character === void 0) { character = this.character; }
            if (lineOrChange === null || character === null) {
                throw errors_1.illegalArgument();
            }
            var line;
            if (typeof lineOrChange === 'undefined') {
                line = this.line;
            }
            else if (typeof lineOrChange === 'number') {
                line = lineOrChange;
            }
            else {
                line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
                character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
            }
            if (line === this.line && character === this.character) {
                return this;
            }
            return new Position(line, character);
        };
        Position.prototype.toJSON = function () {
            return { line: this.line, character: this.character };
        };
        return Position;
    }());
    exports.Position = Position;
    var Range = (function () {
        function Range(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
            var start;
            var end;
            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
                start = new Position(startLineOrStart, startColumnOrEnd);
                end = new Position(endLine, endColumn);
            }
            else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {
                start = startLineOrStart;
                end = startColumnOrEnd;
            }
            if (!start || !end) {
                throw new Error('Invalid arguments');
            }
            if (start.isBefore(end)) {
                this._start = start;
                this._end = end;
            }
            else {
                this._start = end;
                this._end = start;
            }
        }
        Range.isRange = function (thing) {
            if (thing instanceof Range) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Position.isPosition(thing.start)
                && Position.isPosition(thing.end);
        };
        Object.defineProperty(Range.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.contains = function (positionOrRange) {
            if (positionOrRange instanceof Range) {
                return this.contains(positionOrRange._start)
                    && this.contains(positionOrRange._end);
            }
            else if (positionOrRange instanceof Position) {
                if (positionOrRange.isBefore(this._start)) {
                    return false;
                }
                if (this._end.isBefore(positionOrRange)) {
                    return false;
                }
                return true;
            }
            return false;
        };
        Range.prototype.isEqual = function (other) {
            return this._start.isEqual(other._start) && this._end.isEqual(other._end);
        };
        Range.prototype.intersection = function (other) {
            var start = Position.Max(other.start, this._start);
            var end = Position.Min(other.end, this._end);
            if (start.isAfter(end)) {
                // this happens when there is no overlap:
                // |-----|
                //          |----|
                return undefined;
            }
            return new Range(start, end);
        };
        Range.prototype.union = function (other) {
            if (this.contains(other)) {
                return this;
            }
            else if (other.contains(this)) {
                return other;
            }
            var start = Position.Min(other.start, this._start);
            var end = Position.Max(other.end, this.end);
            return new Range(start, end);
        };
        Object.defineProperty(Range.prototype, "isEmpty", {
            get: function () {
                return this._start.isEqual(this._end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "isSingleLine", {
            get: function () {
                return this._start.line === this._end.line;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.with = function (startOrChange, end) {
            if (end === void 0) { end = this.end; }
            if (startOrChange === null || end === null) {
                throw errors_1.illegalArgument();
            }
            var start;
            if (!startOrChange) {
                start = this.start;
            }
            else if (Position.isPosition(startOrChange)) {
                start = startOrChange;
            }
            else {
                start = startOrChange.start || this.start;
                end = startOrChange.end || this.end;
            }
            if (start.isEqual(this._start) && end.isEqual(this.end)) {
                return this;
            }
            return new Range(start, end);
        };
        Range.prototype.toJSON = function () {
            return [this.start, this.end];
        };
        return Range;
    }());
    exports.Range = Range;
    var Selection = (function (_super) {
        __extends(Selection, _super);
        function Selection(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
            var _this = this;
            var anchor;
            var active;
            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
                anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
                active = new Position(activeLine, activeColumn);
            }
            else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {
                anchor = anchorLineOrAnchor;
                active = anchorColumnOrActive;
            }
            if (!anchor || !active) {
                throw new Error('Invalid arguments');
            }
            _this = _super.call(this, anchor, active) || this;
            _this._anchor = anchor;
            _this._active = active;
            return _this;
        }
        Selection.isSelection = function (thing) {
            if (thing instanceof Selection) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && Position.isPosition(thing.anchor)
                && Position.isPosition(thing.active)
                && typeof thing.isReversed === 'boolean';
        };
        Object.defineProperty(Selection.prototype, "anchor", {
            get: function () {
                return this._anchor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "active", {
            get: function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "isReversed", {
            get: function () {
                return this._anchor === this._end;
            },
            enumerable: true,
            configurable: true
        });
        Selection.prototype.toJSON = function () {
            return {
                start: this.start,
                end: this.end,
                active: this.active,
                anchor: this.anchor
            };
        };
        return Selection;
    }(Range));
    exports.Selection = Selection;
    var EndOfLine;
    (function (EndOfLine) {
        EndOfLine[EndOfLine["LF"] = 1] = "LF";
        EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var TextEdit = (function () {
        function TextEdit(range, newText) {
            this.range = range;
            this.newText = newText;
        }
        TextEdit.isTextEdit = function (thing) {
            if (thing instanceof TextEdit) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && typeof thing.newText === 'string';
        };
        TextEdit.replace = function (range, newText) {
            return new TextEdit(range, newText);
        };
        TextEdit.insert = function (position, newText) {
            return TextEdit.replace(new Range(position, position), newText);
        };
        TextEdit.delete = function (range) {
            return TextEdit.replace(range, '');
        };
        TextEdit.setEndOfLine = function (eol) {
            var ret = new TextEdit(undefined, undefined);
            ret.newEol = eol;
            return ret;
        };
        Object.defineProperty(TextEdit.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                if (value && !Range.isRange(value)) {
                    throw errors_1.illegalArgument('range');
                }
                this._range = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newText", {
            get: function () {
                return this._newText || '';
            },
            set: function (value) {
                if (value && typeof value !== 'string') {
                    throw errors_1.illegalArgument('newText');
                }
                this._newText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newEol", {
            get: function () {
                return this._newEol;
            },
            set: function (value) {
                if (value && typeof value !== 'number') {
                    throw errors_1.illegalArgument('newEol');
                }
                this._newEol = value;
            },
            enumerable: true,
            configurable: true
        });
        TextEdit.prototype.toJSON = function () {
            return {
                range: this.range,
                newText: this.newText,
                newEol: this._newEol
            };
        };
        return TextEdit;
    }());
    exports.TextEdit = TextEdit;
    var WorkspaceEdit = (function () {
        function WorkspaceEdit() {
            this._values = [];
            this._index = new Map();
        }
        WorkspaceEdit.prototype.replace = function (uri, range, newText) {
            var edit = new TextEdit(range, newText);
            var array = this.get(uri);
            if (array) {
                array.push(edit);
            }
            else {
                this.set(uri, [edit]);
            }
        };
        WorkspaceEdit.prototype.insert = function (resource, position, newText) {
            this.replace(resource, new Range(position, position), newText);
        };
        WorkspaceEdit.prototype.delete = function (resource, range) {
            this.replace(resource, range, '');
        };
        WorkspaceEdit.prototype.has = function (uri) {
            return this._index.has(uri.toString());
        };
        WorkspaceEdit.prototype.set = function (uri, edits) {
            var idx = this._index.get(uri.toString());
            if (typeof idx === 'undefined') {
                var newLen = this._values.push([uri, edits]);
                this._index.set(uri.toString(), newLen - 1);
            }
            else {
                this._values[idx][1] = edits;
            }
        };
        WorkspaceEdit.prototype.get = function (uri) {
            var idx = this._index.get(uri.toString());
            return typeof idx !== 'undefined' && this._values[idx][1];
        };
        WorkspaceEdit.prototype.entries = function () {
            return this._values;
        };
        Object.defineProperty(WorkspaceEdit.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceEdit.prototype.toJSON = function () {
            return this._values;
        };
        return WorkspaceEdit;
    }());
    exports.WorkspaceEdit = WorkspaceEdit;
    var SnippetString = (function () {
        function SnippetString(value) {
            this._tabstop = 1;
            this.value = value || '';
        }
        SnippetString.isSnippetString = function (thing) {
            if (thing instanceof SnippetString) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.value === 'string';
        };
        SnippetString._escape = function (value) {
            return value.replace(/\$|}|\\/g, '\\$&');
        };
        SnippetString.prototype.appendText = function (string) {
            this.value += SnippetString._escape(string);
            return this;
        };
        SnippetString.prototype.appendTabstop = function (number) {
            if (number === void 0) { number = this._tabstop++; }
            this.value += '$';
            this.value += number;
            return this;
        };
        SnippetString.prototype.appendPlaceholder = function (value, number) {
            if (number === void 0) { number = this._tabstop++; }
            if (typeof value === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                value(nested);
                this._tabstop = nested._tabstop;
                value = nested.value;
            }
            else {
                value = SnippetString._escape(value);
            }
            this.value += '${';
            this.value += number;
            this.value += ':';
            this.value += value;
            this.value += '}';
            return this;
        };
        SnippetString.prototype.appendVariable = function (name, defaultValue) {
            if (typeof defaultValue === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                defaultValue(nested);
                this._tabstop = nested._tabstop;
                defaultValue = nested.value;
            }
            else if (typeof defaultValue === 'string') {
                defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
            }
            this.value += '${';
            this.value += name;
            if (defaultValue) {
                this.value += ':';
                this.value += defaultValue;
            }
            this.value += '}';
            return this;
        };
        return SnippetString;
    }());
    exports.SnippetString = SnippetString;
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
        DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
        DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
        DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var Location = (function () {
        function Location(uri, rangeOrPosition) {
            this.uri = uri;
            if (!rangeOrPosition) {
                //that's OK
            }
            else if (rangeOrPosition instanceof Range) {
                this.range = rangeOrPosition;
            }
            else if (rangeOrPosition instanceof Position) {
                this.range = new Range(rangeOrPosition, rangeOrPosition);
            }
            else {
                throw new Error('Illegal argument');
            }
        }
        Location.isLocation = function (thing) {
            if (thing instanceof Location) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing.range)
                && uri_1.default.isUri(thing.uri);
        };
        Location.prototype.toJSON = function () {
            return {
                uri: this.uri,
                range: this.range
            };
        };
        return Location;
    }());
    exports.Location = Location;
    var Diagnostic = (function () {
        function Diagnostic(range, message, severity) {
            if (severity === void 0) { severity = DiagnosticSeverity.Error; }
            this.range = range;
            this.message = message;
            this.severity = severity;
        }
        Diagnostic.prototype.toJSON = function () {
            return {
                severity: DiagnosticSeverity[this.severity],
                message: this.message,
                range: this.range,
                source: this.source,
                code: this.code,
            };
        };
        return Diagnostic;
    }());
    exports.Diagnostic = Diagnostic;
    var Hover = (function () {
        function Hover(contents, range) {
            if (!contents) {
                throw new Error('Illegal argument, contents must be defined');
            }
            if (Array.isArray(contents)) {
                this.contents = contents;
            }
            else if (htmlContent_1.isMarkdownString(contents)) {
                this.contents = [contents];
            }
            else {
                this.contents = [contents];
            }
            this.range = range;
        }
        return Hover;
    }());
    exports.Hover = Hover;
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    var DocumentHighlight = (function () {
        function DocumentHighlight(range, kind) {
            if (kind === void 0) { kind = DocumentHighlightKind.Text; }
            this.range = range;
            this.kind = kind;
        }
        DocumentHighlight.prototype.toJSON = function () {
            return {
                range: this.range,
                kind: DocumentHighlightKind[this.kind]
            };
        };
        return DocumentHighlight;
    }());
    exports.DocumentHighlight = DocumentHighlight;
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolInformation = (function () {
        function SymbolInformation(name, kind, rangeOrContainer, locationOrUri, containerName) {
            this.name = name;
            this.kind = kind;
            this.containerName = containerName;
            if (typeof rangeOrContainer === 'string') {
                this.containerName = rangeOrContainer;
            }
            if (locationOrUri instanceof Location) {
                this.location = locationOrUri;
            }
            else if (rangeOrContainer instanceof Range) {
                this.location = new Location(locationOrUri, rangeOrContainer);
            }
        }
        SymbolInformation.prototype.toJSON = function () {
            return {
                name: this.name,
                kind: SymbolKind[this.kind],
                location: this.location,
                containerName: this.containerName
            };
        };
        return SymbolInformation;
    }());
    exports.SymbolInformation = SymbolInformation;
    var CodeLens = (function () {
        function CodeLens(range, command) {
            this.range = range;
            this.command = command;
        }
        Object.defineProperty(CodeLens.prototype, "isResolved", {
            get: function () {
                return !!this.command;
            },
            enumerable: true,
            configurable: true
        });
        return CodeLens;
    }());
    exports.CodeLens = CodeLens;
    var ParameterInformation = (function () {
        function ParameterInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
        }
        return ParameterInformation;
    }());
    exports.ParameterInformation = ParameterInformation;
    var SignatureInformation = (function () {
        function SignatureInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
            this.parameters = [];
        }
        return SignatureInformation;
    }());
    exports.SignatureInformation = SignatureInformation;
    var SignatureHelp = (function () {
        function SignatureHelp() {
            this.signatures = [];
        }
        return SignatureHelp;
    }());
    exports.SignatureHelp = SignatureHelp;
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
        CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
        CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
        CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
        CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
        CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
        CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
        CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItem = (function () {
        function CompletionItem(label, kind) {
            this.label = label;
            this.kind = kind;
        }
        CompletionItem.prototype.toJSON = function () {
            return {
                label: this.label,
                kind: CompletionItemKind[this.kind],
                detail: this.detail,
                documentation: this.documentation,
                sortText: this.sortText,
                filterText: this.filterText,
                insertText: this.insertText,
                textEdit: this.textEdit
            };
        };
        return CompletionItem;
    }());
    exports.CompletionItem = CompletionItem;
    var CompletionList = (function () {
        function CompletionList(items, isIncomplete) {
            if (items === void 0) { items = []; }
            if (isIncomplete === void 0) { isIncomplete = false; }
            this.items = items;
            this.isIncomplete = isIncomplete;
        }
        return CompletionList;
    }());
    exports.CompletionList = CompletionList;
    var ViewColumn;
    (function (ViewColumn) {
        ViewColumn[ViewColumn["One"] = 1] = "One";
        ViewColumn[ViewColumn["Two"] = 2] = "Two";
        ViewColumn[ViewColumn["Three"] = 3] = "Three";
    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
    var StatusBarAlignment;
    (function (StatusBarAlignment) {
        StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
        StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
    })(StatusBarAlignment = exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));
    var TextEditorLineNumbersStyle;
    (function (TextEditorLineNumbersStyle) {
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
    })(TextEditorLineNumbersStyle = exports.TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
        TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
        TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var TextEditorSelectionChangeKind;
    (function (TextEditorSelectionChangeKind) {
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    /**
     * These values match very carefully the values of `TrackedRangeStickiness`
     */
    var DecorationRangeBehavior;
    (function (DecorationRangeBehavior) {
        /**
         * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
        /**
         * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
    })(DecorationRangeBehavior = exports.DecorationRangeBehavior || (exports.DecorationRangeBehavior = {}));
    (function (TextEditorSelectionChangeKind) {
        function fromValue(s) {
            switch (s) {
                case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
                case 'mouse': return TextEditorSelectionChangeKind.Mouse;
                case 'api': return TextEditorSelectionChangeKind.Command;
            }
            return undefined;
        }
        TextEditorSelectionChangeKind.fromValue = fromValue;
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    var DocumentLink = (function () {
        function DocumentLink(range, target) {
            if (target && !(target instanceof uri_1.default)) {
                throw errors_1.illegalArgument('target');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.target = target;
        }
        return DocumentLink;
    }());
    exports.DocumentLink = DocumentLink;
    var Color = (function () {
        function Color(red, green, blue, alpha) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;
        }
        Color.fromHSLA = function (hue, saturation, luminance, alpha) {
            var color = new color_1.Color(new color_1.HSLA(hue, saturation, luminance, alpha)).rgba;
            return new Color(color.r, color.g, color.b, color.a);
        };
        Color.fromHex = function (hex) {
            var baseColor = color_1.Color.Format.CSS.parseHex(hex);
            if (baseColor) {
                var rgba = baseColor.rgba;
                return new Color(rgba.r, rgba.g, rgba.b, rgba.a);
            }
            return null;
        };
        return Color;
    }());
    exports.Color = Color;
    var ColorRange = (function () {
        function ColorRange(range, color, availableFormats) {
            if (color && !(color instanceof Color)) {
                throw errors_1.illegalArgument('color');
            }
            if (availableFormats && !Array.isArray(availableFormats)) {
                throw errors_1.illegalArgument('availableFormats');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.color = color;
            this.availableFormats = availableFormats;
        }
        return ColorRange;
    }());
    exports.ColorRange = ColorRange;
    var TaskRevealKind;
    (function (TaskRevealKind) {
        TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
        TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
        TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
    })(TaskRevealKind = exports.TaskRevealKind || (exports.TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
        TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
        TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
    })(TaskPanelKind = exports.TaskPanelKind || (exports.TaskPanelKind = {}));
    var TaskGroup = (function () {
        function TaskGroup(id, label) {
            if (typeof id !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            if (typeof label !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            this._id = id;
            this._label = label;
        }
        Object.defineProperty(TaskGroup.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        TaskGroup.Clean = new TaskGroup('clean', 'Clean');
        TaskGroup.Build = new TaskGroup('build', 'Build');
        TaskGroup.Rebuild = new TaskGroup('rebuild', 'Rebuild');
        TaskGroup.Test = new TaskGroup('test', 'Test');
        return TaskGroup;
    }());
    exports.TaskGroup = TaskGroup;
    var ProcessExecution = (function () {
        function ProcessExecution(process, varg1, varg2) {
            if (typeof process !== 'string') {
                throw errors_1.illegalArgument('process');
            }
            this._process = process;
            if (varg1 !== void 0) {
                if (Array.isArray(varg1)) {
                    this._args = varg1;
                    this._options = varg2;
                }
                else {
                    this._options = varg1;
                }
            }
            if (this._args === void 0) {
                this._args = [];
            }
        }
        Object.defineProperty(ProcessExecution.prototype, "process", {
            get: function () {
                return this._process;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('process');
                }
                this._process = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "args", {
            get: function () {
                return this._args;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    value = [];
                }
                this._args = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        return ProcessExecution;
    }());
    exports.ProcessExecution = ProcessExecution;
    var ShellExecution = (function () {
        function ShellExecution(commandLine, options) {
            if (typeof commandLine !== 'string') {
                throw errors_1.illegalArgument('commandLine');
            }
            this._commandLine = commandLine;
            this._options = options;
        }
        Object.defineProperty(ShellExecution.prototype, "commandLine", {
            get: function () {
                return this._commandLine;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('commandLine');
                }
                this._commandLine = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        return ShellExecution;
    }());
    exports.ShellExecution = ShellExecution;
    var Task = (function () {
        function Task(definition, name, source, execution, problemMatchers) {
            this.definition = definition;
            this.name = name;
            this.source = source;
            this.execution = execution;
            if (typeof problemMatchers === 'string') {
                this._problemMatchers = [problemMatchers];
                this._hasDefinedMatchers = true;
            }
            else if (Array.isArray(problemMatchers)) {
                this._problemMatchers = problemMatchers;
                this._hasDefinedMatchers = true;
            }
            else {
                this._problemMatchers = [];
                this._hasDefinedMatchers = false;
            }
            this._isBackground = false;
        }
        Object.defineProperty(Task.prototype, "definition", {
            get: function () {
                return this._definition;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    throw errors_1.illegalArgument('Kind can\'t be undefined or null');
                }
                this._definitionKey = undefined;
                this._definition = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "definitionKey", {
            get: function () {
                if (!this._definitionKey) {
                    var hash = crypto.createHash('md5');
                    hash.update(JSON.stringify(this._definition));
                    this._definitionKey = hash.digest('hex');
                }
                return this._definitionKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('name');
                }
                this._name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "execution", {
            get: function () {
                return this._execution;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this._execution = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "problemMatchers", {
            get: function () {
                return this._problemMatchers;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    this._problemMatchers = [];
                    this._hasDefinedMatchers = false;
                    return;
                }
                this._problemMatchers = value;
                this._hasDefinedMatchers = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "hasDefinedMatchers", {
            get: function () {
                return this._hasDefinedMatchers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "isBackground", {
            get: function () {
                return this._isBackground;
            },
            set: function (value) {
                if (value !== true && value !== false) {
                    value = false;
                }
                this._isBackground = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (typeof value !== 'string' || value.length === 0) {
                    throw errors_1.illegalArgument('source must be a string of length > 0');
                }
                this._source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "group", {
            get: function () {
                return this._group;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    this._group = undefined;
                    return;
                }
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "presentationOptions", {
            get: function () {
                return this._presentationOptions;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this._presentationOptions = value;
            },
            enumerable: true,
            configurable: true
        });
        return Task;
    }());
    exports.Task = Task;
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    var TreeItem = (function () {
        function TreeItem(label, collapsibleState) {
            if (collapsibleState === void 0) { collapsibleState = TreeItemCollapsibleState.None; }
            this.label = label;
            this.collapsibleState = collapsibleState;
        }
        return TreeItem;
    }());
    exports.TreeItem = TreeItem;
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState = exports.TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = {}));
    var ThemeColor = (function () {
        function ThemeColor(id) {
            this.id = id;
        }
        return ThemeColor;
    }());
    exports.ThemeColor = ThemeColor;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
        ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
        ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
});











define(__m[55/*vs/workbench/api/node/extHostDocumentData*/], __M([1/*require*/,0/*exports*/,30/*vs/base/common/assert*/,8/*vs/base/common/strings*/,70/*vs/editor/common/model/mirrorModel*/,5/*vs/workbench/api/node/extHostTypes*/,34/*vs/editor/common/model/wordHelper*/,2/*vs/base/common/winjs.base*/]), function (require, exports, assert_1, strings_1, mirrorModel_1, extHostTypes_1, wordHelper_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _modeId2WordDefinition = new Map();
    function setWordDefinitionFor(modeId, wordDefinition) {
        _modeId2WordDefinition.set(modeId, wordDefinition);
    }
    exports.setWordDefinitionFor = setWordDefinitionFor;
    function getWordDefinitionFor(modeId) {
        return _modeId2WordDefinition.get(modeId);
    }
    exports.getWordDefinitionFor = getWordDefinitionFor;
    var ExtHostDocumentData = (function (_super) {
        __extends(ExtHostDocumentData, _super);
        function ExtHostDocumentData(proxy, uri, lines, eol, languageId, versionId, isDirty) {
            var _this = _super.call(this, uri, lines, eol, versionId) || this;
            _this._textLines = [];
            _this._isDisposed = false;
            _this._proxy = proxy;
            _this._languageId = languageId;
            _this._isDirty = isDirty;
            return _this;
        }
        ExtHostDocumentData.prototype.dispose = function () {
            // we don't really dispose documents but let
            // extensions still read from them. some
            // operations, live saving, will now error tho
            assert_1.ok(!this._isDisposed);
            this._isDisposed = true;
            this._isDirty = false;
        };
        ExtHostDocumentData.prototype.equalLines = function (_a) {
            var lines = _a.lines;
            var len = lines.length;
            if (len !== this._lines.length) {
                return false;
            }
            for (var i = 0; i < len; i++) {
                if (lines[i] !== this._lines[i]) {
                    return false;
                }
            }
            return true;
        };
        Object.defineProperty(ExtHostDocumentData.prototype, "document", {
            get: function () {
                if (!this._document) {
                    var data_1 = this;
                    this._document = {
                        get uri() { return data_1._uri; },
                        get fileName() { return data_1._uri.fsPath; },
                        get isUntitled() { return data_1._uri.scheme !== 'file'; },
                        get languageId() { return data_1._languageId; },
                        get version() { return data_1._versionId; },
                        get isClosed() { return data_1._isDisposed; },
                        get isDirty() { return data_1._isDirty; },
                        save: function () { return data_1._save(); },
                        getText: function (range) { return range ? data_1._getTextInRange(range) : data_1.getText(); },
                        get eol() { return data_1._eol === '\n' ? extHostTypes_1.EndOfLine.LF : extHostTypes_1.EndOfLine.CRLF; },
                        get lineCount() { return data_1._lines.length; },
                        lineAt: function (lineOrPos) { return data_1._lineAt(lineOrPos); },
                        offsetAt: function (pos) { return data_1._offsetAt(pos); },
                        positionAt: function (offset) { return data_1._positionAt(offset); },
                        validateRange: function (ran) { return data_1._validateRange(ran); },
                        validatePosition: function (pos) { return data_1._validatePosition(pos); },
                        getWordRangeAtPosition: function (pos, regexp) { return data_1._getWordRangeAtPosition(pos, regexp); }
                    };
                }
                return Object.freeze(this._document);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDocumentData.prototype._acceptLanguageId = function (newLanguageId) {
            assert_1.ok(!this._isDisposed);
            this._languageId = newLanguageId;
        };
        ExtHostDocumentData.prototype._acceptIsDirty = function (isDirty) {
            assert_1.ok(!this._isDisposed);
            this._isDirty = isDirty;
        };
        ExtHostDocumentData.prototype._save = function () {
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(new Error('Document has been closed'));
            }
            return this._proxy.$trySaveDocument(this._uri);
        };
        ExtHostDocumentData.prototype._getTextInRange = function (_range) {
            var range = this._validateRange(_range);
            if (range.isEmpty) {
                return '';
            }
            if (range.isSingleLine) {
                return this._lines[range.start.line].substring(range.start.character, range.end.character);
            }
            var lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.start.character));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
            return resultLines.join(lineEnding);
        };
        ExtHostDocumentData.prototype._lineAt = function (lineOrPosition) {
            var line;
            if (lineOrPosition instanceof extHostTypes_1.Position) {
                line = lineOrPosition.line;
            }
            else if (typeof lineOrPosition === 'number') {
                line = lineOrPosition;
            }
            if (line < 0 || line >= this._lines.length) {
                throw new Error('Illegal value for `line`');
            }
            var result = this._textLines[line];
            if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {
                var text = this._lines[line];
                var firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
                var range = new extHostTypes_1.Range(line, 0, line, text.length);
                var rangeIncludingLineBreak = line < this._lines.length - 1
                    ? new extHostTypes_1.Range(line, 0, line + 1, 0)
                    : range;
                result = Object.freeze({
                    lineNumber: line,
                    range: range,
                    rangeIncludingLineBreak: rangeIncludingLineBreak,
                    text: text,
                    firstNonWhitespaceCharacterIndex: firstNonWhitespaceCharacterIndex,
                    isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
                });
                this._textLines[line] = result;
            }
            return result;
        };
        ExtHostDocumentData.prototype._offsetAt = function (position) {
            position = this._validatePosition(position);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.line - 1) + position.character;
        };
        ExtHostDocumentData.prototype._positionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].length;
            // Ensure we return a valid position
            return new extHostTypes_1.Position(out.index, Math.min(out.remainder, lineLength));
        };
        // ---- range math
        ExtHostDocumentData.prototype._validateRange = function (range) {
            if (!(range instanceof extHostTypes_1.Range)) {
                throw new Error('Invalid argument');
            }
            var start = this._validatePosition(range.start);
            var end = this._validatePosition(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new extHostTypes_1.Range(start.line, start.character, end.line, end.character);
        };
        ExtHostDocumentData.prototype._validatePosition = function (position) {
            if (!(position instanceof extHostTypes_1.Position)) {
                throw new Error('Invalid argument');
            }
            var line = position.line, character = position.character;
            var hasChanged = false;
            if (line < 0) {
                line = 0;
                character = 0;
                hasChanged = true;
            }
            else if (line >= this._lines.length) {
                line = this._lines.length - 1;
                character = this._lines[line].length;
                hasChanged = true;
            }
            else {
                var maxCharacter = this._lines[line].length;
                if (character < 0) {
                    character = 0;
                    hasChanged = true;
                }
                else if (character > maxCharacter) {
                    character = maxCharacter;
                    hasChanged = true;
                }
            }
            if (!hasChanged) {
                return position;
            }
            return new extHostTypes_1.Position(line, character);
        };
        ExtHostDocumentData.prototype._getWordRangeAtPosition = function (_position, regexp) {
            var position = this._validatePosition(_position);
            if (!regexp) {
                // use default when custom-regexp isn't provided
                regexp = getWordDefinitionFor(this._languageId);
            }
            else if (strings_1.regExpLeadsToEndlessLoop(regexp)) {
                // use default when custom-regexp is bad
                console.warn("[getWordRangeAtPosition]: ignoring custom regexp '" + regexp.source + "' because it matches the empty string.");
                regexp = getWordDefinitionFor(this._languageId);
            }
            var wordAtText = wordHelper_1.getWordAtText(position.character + 1, wordHelper_1.ensureValidWordDefinition(regexp), this._lines[position.line], 0);
            if (wordAtText) {
                return new extHostTypes_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
            }
            return undefined;
        };
        return ExtHostDocumentData;
    }(mirrorModel_1.MirrorModel));
    exports.ExtHostDocumentData = ExtHostDocumentData;
});

define(__m[113/*vs/workbench/api/node/extHostFileSystemEventService*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,5/*vs/workbench/api/node/extHostTypes*/,28/*vs/base/common/glob*/]), function (require, exports, event_1, extHostTypes_1, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileSystemWatcher = (function () {
        function FileSystemWatcher(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            var _this = this;
            this._onDidCreate = new event_1.Emitter();
            this._onDidChange = new event_1.Emitter();
            this._onDidDelete = new event_1.Emitter();
            this._config = 0;
            if (ignoreCreateEvents) {
                this._config += 1;
            }
            if (ignoreChangeEvents) {
                this._config += 2;
            }
            if (ignoreDeleteEvents) {
                this._config += 4;
            }
            var subscription = dispatcher(function (events) {
                if (!ignoreCreateEvents) {
                    for (var _i = 0, _a = events.created; _i < _a.length; _i++) {
                        var created = _a[_i];
                        if (glob_1.match(globPattern, created.fsPath)) {
                            _this._onDidCreate.fire(created);
                        }
                    }
                }
                if (!ignoreChangeEvents) {
                    for (var _b = 0, _c = events.changed; _b < _c.length; _b++) {
                        var changed = _c[_b];
                        if (glob_1.match(globPattern, changed.fsPath)) {
                            _this._onDidChange.fire(changed);
                        }
                    }
                }
                if (!ignoreDeleteEvents) {
                    for (var _d = 0, _e = events.deleted; _d < _e.length; _d++) {
                        var deleted = _e[_d];
                        if (glob_1.match(globPattern, deleted.fsPath)) {
                            _this._onDidDelete.fire(deleted);
                        }
                    }
                }
            });
            this._disposable = extHostTypes_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
        }
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreCreateEvents", {
            get: function () {
                return Boolean(this._config & 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreChangeEvents", {
            get: function () {
                return Boolean(this._config & 2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreDeleteEvents", {
            get: function () {
                return Boolean(this._config & 4);
            },
            enumerable: true,
            configurable: true
        });
        FileSystemWatcher.prototype.dispose = function () {
            this._disposable.dispose();
        };
        Object.defineProperty(FileSystemWatcher.prototype, "onDidCreate", {
            get: function () {
                return this._onDidCreate.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidDelete", {
            get: function () {
                return this._onDidDelete.event;
            },
            enumerable: true,
            configurable: true
        });
        return FileSystemWatcher;
    }());
    var ExtHostFileSystemEventService = (function () {
        function ExtHostFileSystemEventService() {
            this._emitter = new event_1.Emitter();
        }
        ExtHostFileSystemEventService.prototype.createFileSystemWatcher = function (globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            return new FileSystemWatcher(this._emitter.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        };
        ExtHostFileSystemEventService.prototype.$onFileEvent = function (events) {
            this._emitter.fire(events);
        };
        return ExtHostFileSystemEventService;
    }());
    exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;
});











define(__m[114/*vs/workbench/api/node/extHostTreeViews*/], __M([1/*require*/,0/*exports*/,87/*vs/nls!vs/workbench/api/node/extHostTreeViews*/,6/*vs/base/common/uri*/,15/*vs/base/common/arrays*/,3/*vs/base/common/event*/,2/*vs/base/common/winjs.base*/,17/*vs/base/common/lifecycle*/,5/*vs/workbench/api/node/extHostTypes*/,10/*vs/base/common/async*/]), function (require, exports, nls_1, uri_1, arrays_1, event_1, winjs_base_1, lifecycle_1, extHostTypes_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostTreeViews = (function () {
        function ExtHostTreeViews(_proxy, commands) {
            var _this = this;
            this._proxy = _proxy;
            this.commands = commands;
            this.treeViews = new Map();
            commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$treeViewId && arg.$treeItemHandle) {
                        return _this.convertArgument(arg);
                    }
                    return arg;
                }
            });
        }
        ExtHostTreeViews.prototype.registerTreeDataProvider = function (id, treeDataProvider) {
            var _this = this;
            var treeView = new ExtHostTreeView(id, treeDataProvider, this._proxy, this.commands.converter);
            this.treeViews.set(id, treeView);
            return {
                dispose: function () {
                    _this.treeViews.delete(id);
                    treeView.dispose();
                }
            };
        };
        ExtHostTreeViews.prototype.$getElements = function (treeViewId) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(0, null, treeViewId)));
            }
            return treeView.getTreeItems();
        };
        ExtHostTreeViews.prototype.$getChildren = function (treeViewId, treeItemHandle) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(1, null, treeViewId)));
            }
            return treeView.getChildren(treeItemHandle);
        };
        ExtHostTreeViews.prototype.convertArgument = function (arg) {
            var treeView = this.treeViews.get(arg.$treeViewId);
            return treeView ? treeView.getExtensionElement(arg.$treeItemHandle) : null;
        };
        return ExtHostTreeViews;
    }());
    exports.ExtHostTreeViews = ExtHostTreeViews;
    var ExtHostTreeView = (function (_super) {
        __extends(ExtHostTreeView, _super);
        function ExtHostTreeView(viewId, dataProvider, proxy, commands) {
            var _this = _super.call(this) || this;
            _this.viewId = viewId;
            _this.dataProvider = dataProvider;
            _this.proxy = proxy;
            _this.commands = commands;
            _this._itemHandlePool = 0;
            _this.extElementsMap = new Map();
            _this.itemHandlesMap = new Map();
            _this.extChildrenElementsMap = new Map();
            _this.proxy.$registerView(viewId);
            if (dataProvider.onDidChangeTreeData) {
                _this._register(event_1.debounceEvent(dataProvider.onDidChangeTreeData, function (last, current) { return last ? last.concat([current]) : [current]; }, 200)(function (elements) { return _this._refresh(elements); }));
            }
            return _this;
        }
        ExtHostTreeView.prototype.getTreeItems = function () {
            var _this = this;
            this.extChildrenElementsMap.clear();
            this.extElementsMap.clear();
            this.itemHandlesMap.clear();
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getChildren(); })
                .then(function (elements) { return _this.processAndMapElements(elements); });
        };
        ExtHostTreeView.prototype.getChildren = function (treeItemHandle) {
            var _this = this;
            var extElement = this.getExtensionElement(treeItemHandle);
            if (extElement) {
                this.clearChildren(extElement);
            }
            else {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(2, null, treeItemHandle)));
            }
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getChildren(extElement); })
                .then(function (childrenElements) { return _this.processAndMapElements(childrenElements); });
        };
        ExtHostTreeView.prototype.getExtensionElement = function (treeItemHandle) {
            return this.extElementsMap.get(treeItemHandle);
        };
        ExtHostTreeView.prototype._refresh = function (elements) {
            var _this = this;
            var hasRoot = elements.some(function (element) { return !element; });
            if (hasRoot) {
                this.proxy.$refresh(this.viewId, []);
            }
            else {
                var itemHandles = arrays_1.distinct(elements.map(function (element) { return _this.itemHandlesMap.get(element); })
                    .filter(function (itemHandle) { return !!itemHandle; }));
                if (itemHandles.length) {
                    this.proxy.$refresh(this.viewId, itemHandles);
                }
            }
        };
        ExtHostTreeView.prototype.processAndMapElements = function (elements) {
            var _this = this;
            if (elements && elements.length) {
                return winjs_base_1.TPromise.join(elements.filter(function (element) { return !!element; })
                    .map(function (element) {
                    if (_this.extChildrenElementsMap.has(element)) {
                        return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize(3, null, element)));
                    }
                    return _this.resolveElement(element);
                }))
                    .then(function (treeItems) { return treeItems.filter(function (treeItem) { return !!treeItem; }); });
            }
            return winjs_base_1.TPromise.as([]);
        };
        ExtHostTreeView.prototype.resolveElement = function (element) {
            var _this = this;
            return async_1.asWinJsPromise(function () { return _this.dataProvider.getTreeItem(element); })
                .then(function (extTreeItem) {
                var treeItem = _this.massageTreeItem(extTreeItem);
                if (treeItem) {
                    _this.itemHandlesMap.set(element, treeItem.handle);
                    _this.extElementsMap.set(treeItem.handle, element);
                    if (treeItem.collapsibleState === extHostTypes_1.TreeItemCollapsibleState.Expanded) {
                        return _this.getChildren(treeItem.handle).then(function (children) {
                            treeItem.children = children;
                            return treeItem;
                        });
                    }
                    else {
                        return treeItem;
                    }
                }
                return null;
            });
        };
        ExtHostTreeView.prototype.massageTreeItem = function (extensionTreeItem) {
            if (!extensionTreeItem) {
                return null;
            }
            var icon = this.getLightIconPath(extensionTreeItem);
            return {
                handle: ++this._itemHandlePool,
                label: extensionTreeItem.label,
                command: extensionTreeItem.command ? this.commands.toInternal(extensionTreeItem.command) : void 0,
                contextValue: extensionTreeItem.contextValue,
                icon: icon,
                iconDark: this.getDarkIconPath(extensionTreeItem) || icon,
                collapsibleState: extensionTreeItem.collapsibleState,
            };
        };
        ExtHostTreeView.prototype.getLightIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath) {
                if (typeof extensionTreeItem.iconPath === 'string' || extensionTreeItem.iconPath instanceof uri_1.default) {
                    return this.getIconPath(extensionTreeItem.iconPath);
                }
                return this.getIconPath(extensionTreeItem.iconPath['light']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getDarkIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath && extensionTreeItem.iconPath['dark']) {
                return this.getIconPath(extensionTreeItem.iconPath['dark']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getIconPath = function (iconPath) {
            if (iconPath instanceof uri_1.default) {
                return iconPath.toString();
            }
            return uri_1.default.file(iconPath).toString();
        };
        ExtHostTreeView.prototype.clearChildren = function (extElement) {
            var children = this.extChildrenElementsMap.get(extElement);
            if (children) {
                for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                    var child = children_1[_i];
                    this.clearElement(child);
                }
                this.extChildrenElementsMap.delete(extElement);
            }
        };
        ExtHostTreeView.prototype.clearElement = function (extElement) {
            this.clearChildren(extElement);
            var treeItemhandle = this.itemHandlesMap.get(extElement);
            this.itemHandlesMap.delete(extElement);
            if (treeItemhandle) {
                this.extElementsMap.delete(treeItemhandle);
            }
        };
        ExtHostTreeView.prototype.dispose = function () {
            this.extElementsMap.clear();
            this.itemHandlesMap.clear();
            this.extChildrenElementsMap.clear();
        };
        return ExtHostTreeView;
    }(lifecycle_1.Disposable));
});











define(__m[56/*vs/workbench/common/editor*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,11/*vs/base/common/objects*/,14/*vs/base/common/types*/,6/*vs/base/common/uri*/,17/*vs/base/common/lifecycle*/,93/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, winjs_base_1, event_1, objects, types, uri_1, lifecycle_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextCompareEditorVisible = new contextkey_1.RawContextKey('textCompareEditorVisible', false);
    var ConfirmResult;
    (function (ConfirmResult) {
        ConfirmResult[ConfirmResult["SAVE"] = 0] = "SAVE";
        ConfirmResult[ConfirmResult["DONT_SAVE"] = 1] = "DONT_SAVE";
        ConfirmResult[ConfirmResult["CANCEL"] = 2] = "CANCEL";
    })(ConfirmResult = exports.ConfirmResult || (exports.ConfirmResult = {}));
    exports.Extensions = {
        Editors: 'workbench.contributions.editors'
    };
    /**
     * Text diff editor id.
     */
    exports.TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';
    /**
     * Binary diff editor id.
     */
    exports.BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';
    /**
     * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
     * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
     */
    var EditorInput = (function () {
        function EditorInput() {
            this._onDidChangeDirty = new event_1.Emitter();
            this._onDidChangeLabel = new event_1.Emitter();
            this._onDispose = new event_1.Emitter();
            this.disposed = false;
        }
        Object.defineProperty(EditorInput.prototype, "onDidChangeDirty", {
            /**
             * Fired when the dirty state of this input changes.
             */
            get: function () {
                return this._onDidChangeDirty.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDidChangeLabel", {
            /**
             * Fired when the label this input changes.
             */
            get: function () {
                return this._onDidChangeLabel.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDispose", {
            /**
             * Fired when the model gets disposed.
             */
            get: function () {
                return this._onDispose.event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the name of this input that can be shown to the user. Examples include showing the name of the input
         * above the editor area when the input is shown.
         */
        EditorInput.prototype.getName = function () {
            return null;
        };
        /**
         * Returns the description of this input that can be shown to the user. Examples include showing the description of
         * the input above the editor area to the side of the name of the input.
         */
        EditorInput.prototype.getDescription = function () {
            return null;
        };
        EditorInput.prototype.getTitle = function (verbosity) {
            return this.getName();
        };
        /**
         * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered
         * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.
         */
        EditorInput.prototype.getPreferredEditorId = function (candidates) {
            if (candidates && candidates.length > 0) {
                return candidates[0];
            }
            return null;
        };
        /**
         * Returns a descriptor suitable for telemetry events or null if none is available.
         *
         * Subclasses should extend if they can contribute.
         */
        EditorInput.prototype.getTelemetryDescriptor = function () {
            return { typeId: this.getTypeId() };
        };
        /**
         * An editor that is dirty will be asked to be saved once it closes.
         */
        EditorInput.prototype.isDirty = function () {
            return false;
        };
        /**
         * Subclasses should bring up a proper dialog for the user if the editor is dirty and return the result.
         */
        EditorInput.prototype.confirmSave = function () {
            return ConfirmResult.DONT_SAVE;
        };
        /**
         * Saves the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.save = function () {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Reverts the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.revert = function () {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Called when this input is no longer opened in any editor. Subclasses can free resources as needed.
         */
        EditorInput.prototype.close = function () {
            this.dispose();
        };
        /**
         * Subclasses can set this to false if it does not make sense to split the editor input.
         */
        EditorInput.prototype.supportsSplitEditor = function () {
            // {{SQL CARBON EDIT}}
            return false; // TODO reenable when multiple Angular components of the same type can be open simultaneously
        };
        /**
         * Returns true if this input is identical to the otherInput.
         */
        EditorInput.prototype.matches = function (otherInput) {
            return this === otherInput;
        };
        /**
         * Called when an editor input is no longer needed. Allows to free up any resources taken by
         * resolving the editor input.
         */
        EditorInput.prototype.dispose = function () {
            this.disposed = true;
            this._onDispose.fire();
            this._onDidChangeDirty.dispose();
            this._onDidChangeLabel.dispose();
            this._onDispose.dispose();
        };
        /**
         * Returns whether this input was disposed or not.
         */
        EditorInput.prototype.isDisposed = function () {
            return this.disposed;
        };
        return EditorInput;
    }());
    exports.EditorInput = EditorInput;
    var EncodingMode;
    (function (EncodingMode) {
        /**
         * Instructs the encoding support to encode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Encode"] = 0] = "Encode";
        /**
         * Instructs the encoding support to decode the current input with the provided encoding
         */
        EncodingMode[EncodingMode["Decode"] = 1] = "Decode";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    /**
     * Side by side editor inputs that have a master and details side.
     */
    var SideBySideEditorInput = (function (_super) {
        __extends(SideBySideEditorInput, _super);
        function SideBySideEditorInput(name, description, _details, _master) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.description = description;
            _this._details = _details;
            _this._master = _master;
            _this._toUnbind = [];
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(SideBySideEditorInput.prototype, "master", {
            get: function () {
                return this._master;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditorInput.prototype, "details", {
            get: function () {
                return this._details;
            },
            enumerable: true,
            configurable: true
        });
        SideBySideEditorInput.prototype.isDirty = function () {
            return this.master.isDirty();
        };
        SideBySideEditorInput.prototype.confirmSave = function () {
            return this.master.confirmSave();
        };
        SideBySideEditorInput.prototype.save = function () {
            return this.master.save();
        };
        SideBySideEditorInput.prototype.revert = function () {
            return this.master.revert();
        };
        SideBySideEditorInput.prototype.getTelemetryDescriptor = function () {
            var descriptor = this.master.getTelemetryDescriptor();
            return objects.assign(descriptor, _super.prototype.getTelemetryDescriptor.call(this));
        };
        SideBySideEditorInput.prototype.registerListeners = function () {
            var _this = this;
            // When the details or master input gets disposed, dispose this diff editor input
            var onceDetailsDisposed = event_1.once(this.details.onDispose);
            this._toUnbind.push(onceDetailsDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            var onceMasterDisposed = event_1.once(this.master.onDispose);
            this._toUnbind.push(onceMasterDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            // Reemit some events from the master side to the outside
            this._toUnbind.push(this.master.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this._toUnbind.push(this.master.onDidChangeLabel(function () { return _this._onDidChangeLabel.fire(); }));
        };
        Object.defineProperty(SideBySideEditorInput.prototype, "toUnbind", {
            get: function () {
                return this._toUnbind;
            },
            enumerable: true,
            configurable: true
        });
        SideBySideEditorInput.prototype.resolve = function (refresh) {
            return winjs_base_1.TPromise.as(null);
        };
        SideBySideEditorInput.prototype.getTypeId = function () {
            return SideBySideEditorInput.ID;
        };
        SideBySideEditorInput.prototype.getName = function () {
            return this.name;
        };
        SideBySideEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        SideBySideEditorInput.prototype.supportsSplitEditor = function () {
            return false;
        };
        SideBySideEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput) {
                if (!(otherInput instanceof SideBySideEditorInput)) {
                    return false;
                }
                var otherDiffInput = otherInput;
                return this.details.matches(otherDiffInput.details) && this.master.matches(otherDiffInput.master);
            }
            return false;
        };
        SideBySideEditorInput.prototype.dispose = function () {
            this._toUnbind = lifecycle_1.dispose(this._toUnbind);
            _super.prototype.dispose.call(this);
        };
        SideBySideEditorInput.ID = 'workbench.editorinputs.sidebysideEditorInput';
        return SideBySideEditorInput;
    }(EditorInput));
    exports.SideBySideEditorInput = SideBySideEditorInput;
    /**
     * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it
     * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models
     * are typically cached for some while because they are expensive to construct.
     */
    var EditorModel = (function (_super) {
        __extends(EditorModel, _super);
        function EditorModel() {
            var _this = _super.call(this) || this;
            _this._onDispose = new event_1.Emitter();
            return _this;
        }
        Object.defineProperty(EditorModel.prototype, "onDispose", {
            /**
             * Fired when the model gets disposed.
             */
            get: function () {
                return this._onDispose.event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Causes this model to load returning a promise when loading is completed.
         */
        EditorModel.prototype.load = function () {
            return winjs_base_1.TPromise.as(this);
        };
        /**
         * Returns whether this model was loaded or not.
         */
        EditorModel.prototype.isResolved = function () {
            return true;
        };
        /**
         * Subclasses should implement to free resources that have been claimed through loading.
         */
        EditorModel.prototype.dispose = function () {
            this._onDispose.fire();
            this._onDispose.dispose();
            _super.prototype.dispose.call(this);
        };
        return EditorModel;
    }(lifecycle_1.Disposable));
    exports.EditorModel = EditorModel;
    /**
     * The editor options is the base class of options that can be passed in when opening an editor.
     */
    var EditorOptions = (function () {
        function EditorOptions() {
        }
        /**
         * Helper to create EditorOptions inline.
         */
        EditorOptions.create = function (settings) {
            var options = new EditorOptions();
            options.preserveFocus = settings.preserveFocus;
            options.forceOpen = settings.forceOpen;
            options.revealIfVisible = settings.revealIfVisible;
            options.revealIfOpened = settings.revealIfOpened;
            options.pinned = settings.pinned;
            options.index = settings.index;
            options.inactive = settings.inactive;
            return options;
        };
        return EditorOptions;
    }());
    exports.EditorOptions = EditorOptions;
    /**
     * Base Text Editor Options.
     */
    var TextEditorOptions = (function (_super) {
        __extends(TextEditorOptions, _super);
        function TextEditorOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextEditorOptions.from = function (input) {
            if (!input || !input.options) {
                return null;
            }
            return TextEditorOptions.create(input.options);
        };
        /**
         * Helper to convert options bag to real class
         */
        TextEditorOptions.create = function (options) {
            if (options === void 0) { options = Object.create(null); }
            var textEditorOptions = new TextEditorOptions();
            if (options.selection) {
                var selection = options.selection;
                textEditorOptions.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);
            }
            if (options.viewState) {
                textEditorOptions.editorViewState = options.viewState;
            }
            if (options.forceOpen) {
                textEditorOptions.forceOpen = true;
            }
            if (options.revealIfVisible) {
                textEditorOptions.revealIfVisible = true;
            }
            if (options.revealIfOpened) {
                textEditorOptions.revealIfOpened = true;
            }
            if (options.preserveFocus) {
                textEditorOptions.preserveFocus = true;
            }
            if (options.revealInCenterIfOutsideViewport) {
                textEditorOptions.revealInCenterIfOutsideViewport = true;
            }
            if (options.pinned) {
                textEditorOptions.pinned = true;
            }
            if (options.inactive) {
                textEditorOptions.inactive = true;
            }
            if (typeof options.index === 'number') {
                textEditorOptions.index = options.index;
            }
            return textEditorOptions;
        };
        /**
         * Returns if this options object has objects defined for the editor.
         */
        TextEditorOptions.prototype.hasOptionsDefined = function () {
            return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));
        };
        /**
         * Tells the editor to set show the given selection when the editor is being opened.
         */
        TextEditorOptions.prototype.selection = function (startLineNumber, startColumn, endLineNumber, endColumn) {
            if (endLineNumber === void 0) { endLineNumber = startLineNumber; }
            if (endColumn === void 0) { endColumn = startColumn; }
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
            return this;
        };
        /**
         * Create a TextEditorOptions inline to be used when the editor is opening.
         */
        TextEditorOptions.fromEditor = function (editor, settings) {
            var options = TextEditorOptions.create(settings);
            // View state
            options.editorViewState = editor.saveViewState();
            return options;
        };
        /**
         * Apply the view state or selection to the given editor.
         *
         * @return if something was applied
         */
        TextEditorOptions.prototype.apply = function (editor, scrollType) {
            // View state
            return this.applyViewState(editor, scrollType);
        };
        TextEditorOptions.prototype.applyViewState = function (editor, scrollType) {
            var gotApplied = false;
            // First try viewstate
            if (this.editorViewState) {
                editor.restoreViewState(this.editorViewState);
                gotApplied = true;
            }
            else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {
                // Select
                if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {
                    var range = {
                        startLineNumber: this.startLineNumber,
                        startColumn: this.startColumn,
                        endLineNumber: this.endLineNumber,
                        endColumn: this.endColumn
                    };
                    editor.setSelection(range);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealRangeInCenterIfOutsideViewport(range, scrollType);
                    }
                    else {
                        editor.revealRangeInCenter(range, scrollType);
                    }
                }
                else {
                    var pos = {
                        lineNumber: this.startLineNumber,
                        column: this.startColumn
                    };
                    editor.setPosition(pos);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealPositionInCenterIfOutsideViewport(pos, scrollType);
                    }
                    else {
                        editor.revealPositionInCenter(pos, scrollType);
                    }
                }
                gotApplied = true;
            }
            return gotApplied;
        };
        return TextEditorOptions;
    }(EditorOptions));
    exports.TextEditorOptions = TextEditorOptions;
    exports.EditorOpenPositioning = {
        LEFT: 'left',
        RIGHT: 'right',
        FIRST: 'first',
        LAST: 'last'
    };
    exports.ActiveEditorMovePositioning = {
        FIRST: 'first',
        LAST: 'last',
        LEFT: 'left',
        RIGHT: 'right',
        CENTER: 'center',
        POSITION: 'position',
    };
    exports.ActiveEditorMovePositioningBy = {
        TAB: 'tab',
        GROUP: 'group'
    };
    exports.EditorCommands = {
        MoveActiveEditor: 'moveActiveEditor'
    };
    function hasResource(editor, options) {
        return !!toResource(editor, options);
    }
    exports.hasResource = hasResource;
    function toResource(editor, options) {
        if (!editor) {
            return null;
        }
        // Check for side by side if we are asked to
        if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {
            editor = editor.master;
        }
        var resource = doGetEditorResource(editor);
        if (!options || !options.filter) {
            return resource; // return early if no filter is specified
        }
        if (!resource) {
            return null;
        }
        var includeFiles;
        var includeUntitled;
        if (Array.isArray(options.filter)) {
            includeFiles = (options.filter.indexOf('file') >= 0);
            includeUntitled = (options.filter.indexOf('untitled') >= 0);
        }
        else {
            includeFiles = (options.filter === 'file');
            includeUntitled = (options.filter === 'untitled');
        }
        if (includeFiles && resource.scheme === 'file') {
            return resource;
        }
        if (includeUntitled && resource.scheme === 'untitled') {
            return resource;
        }
        return null;
    }
    exports.toResource = toResource;
    // TODO@Ben every editor should have an associated resource
    function doGetEditorResource(editor) {
        if (editor instanceof EditorInput && typeof editor.getResource === 'function') {
            var candidate = editor.getResource();
            if (candidate instanceof uri_1.default) {
                return candidate;
            }
        }
        return null;
    }
});











var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[116/*vs/workbench/common/editor/textEditorModel*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,23/*vs/editor/common/editorCommon*/,56/*vs/workbench/common/editor*/,45/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/]), function (require, exports, winjs_base_1, editorCommon_1, editor_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base text editor model leverages the code editor model. This class is only intended to be subclassed and not instantiated.
     */
    var BaseTextEditorModel = (function (_super) {
        __extends(BaseTextEditorModel, _super);
        function BaseTextEditorModel(modelService, modeService, textEditorModelHandle) {
            var _this = _super.call(this) || this;
            _this.modelService = modelService;
            _this.modeService = modeService;
            if (textEditorModelHandle) {
                _this.handleExistingModel(textEditorModelHandle);
            }
            return _this;
        }
        BaseTextEditorModel.prototype.handleExistingModel = function (textEditorModelHandle) {
            // We need the resource to point to an existing model
            var model = this.modelService.getModel(textEditorModelHandle);
            if (!model) {
                throw new Error("Document with resource " + textEditorModelHandle.toString() + " does not exist");
            }
            this.textEditorModelHandle = textEditorModelHandle;
            // Make sure we clean up when this model gets disposed
            this.registerModelDisposeListener(model);
        };
        BaseTextEditorModel.prototype.registerModelDisposeListener = function (model) {
            var _this = this;
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose();
            }
            this.modelDisposeListener = model.onWillDispose(function () {
                _this.textEditorModelHandle = null; // make sure we do not dispose code editor model again
                _this.dispose();
            });
        };
        Object.defineProperty(BaseTextEditorModel.prototype, "textEditorModel", {
            get: function () {
                return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the text editor model with the provided value, modeId (can be comma separated for multiple values) and optional resource URL.
         */
        BaseTextEditorModel.prototype.createTextEditorModel = function (value, resource, modeId) {
            var _this = this;
            var firstLineText = this.getFirstLineText(value);
            var mode = this.getOrCreateMode(this.modeService, modeId, firstLineText);
            // To avoid flickering, give the mode at most 50ms to load. If the mode doesn't load in 50ms, proceed creating the model with a mode promise
            return winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(50), mode]).then(function () {
                return _this.doCreateTextEditorModel(value, mode, resource);
            });
        };
        BaseTextEditorModel.prototype.doCreateTextEditorModel = function (value, mode, resource) {
            var model = resource && this.modelService.getModel(resource);
            if (!model) {
                model = this.modelService.createModel(value, mode, resource);
                this.createdEditorModel = true;
                // Make sure we clean up when this model gets disposed
                this.registerModelDisposeListener(model);
            }
            else {
                this.modelService.updateModel(model, value);
                this.modelService.setMode(model, mode);
            }
            this.textEditorModelHandle = model.uri;
            return this;
        };
        BaseTextEditorModel.prototype.getFirstLineText = function (value) {
            if (typeof value === 'string') {
                var firstLineText = value.substr(0, 100);
                var crIndex = firstLineText.indexOf('\r');
                if (crIndex < 0) {
                    crIndex = firstLineText.length;
                }
                var lfIndex = firstLineText.indexOf('\n');
                if (lfIndex < 0) {
                    lfIndex = firstLineText.length;
                }
                return firstLineText.substr(0, Math.min(crIndex, lfIndex));
            }
            else {
                return value.lines[0].substr(0, 100);
            }
        };
        /**
         * Gets the mode for the given identifier. Subclasses can override to provide their own implementation of this lookup.
         *
         * @param firstLineText optional first line of the text buffer to set the mode on. This can be used to guess a mode from content.
         */
        BaseTextEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            return modeService.getOrCreateMode(modeId);
        };
        /**
         * Updates the text editor model with the provided value. If the value is the same as the model has, this is a no-op.
         */
        BaseTextEditorModel.prototype.updateTextEditorModel = function (newValue) {
            if (!this.textEditorModel) {
                return;
            }
            this.modelService.updateModel(this.textEditorModel, newValue);
        };
        /**
         * Returns the textual value of this editor model or null if it has not yet been created.
         */
        BaseTextEditorModel.prototype.getValue = function () {
            var model = this.textEditorModel;
            if (model) {
                return model.getValue(editorCommon_1.EndOfLinePreference.TextDefined, true /* Preserve BOM */);
            }
            return null;
        };
        BaseTextEditorModel.prototype.isResolved = function () {
            return !!this.textEditorModelHandle;
        };
        BaseTextEditorModel.prototype.dispose = function () {
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose(); // dispose this first because it will trigger another dispose() otherwise
                this.modelDisposeListener = null;
            }
            if (this.textEditorModelHandle && this.createdEditorModel) {
                this.modelService.destroyModel(this.textEditorModelHandle);
            }
            this.textEditorModelHandle = null;
            this.createdEditorModel = false;
            _super.prototype.dispose.call(this);
        };
        BaseTextEditorModel = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, modeService_1.IModeService)
        ], BaseTextEditorModel);
        return BaseTextEditorModel;
    }(editor_1.EditorModel));
    exports.BaseTextEditorModel = BaseTextEditorModel;
});

define(__m[117/*vs/workbench/parts/tasks/common/tasks*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/]), function (require, exports, Types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ShellConfiguration;
    (function (ShellConfiguration) {
        function is(value) {
            var candidate = value;
            return candidate && Types.isString(candidate.executable) && (candidate.args === void 0 || Types.isStringArray(candidate.args));
        }
        ShellConfiguration.is = is;
    })(ShellConfiguration = exports.ShellConfiguration || (exports.ShellConfiguration = {}));
    var RevealKind;
    (function (RevealKind) {
        /**
         * Always brings the terminal to front if the task is executed.
         */
        RevealKind[RevealKind["Always"] = 1] = "Always";
        /**
         * Only brings the terminal to front if a problem is detected executing the task
         * (e.g. the task couldn't be started because).
         */
        RevealKind[RevealKind["Silent"] = 2] = "Silent";
        /**
         * The terminal never comes to front when the task is executed.
         */
        RevealKind[RevealKind["Never"] = 3] = "Never";
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    (function (RevealKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'always':
                    return RevealKind.Always;
                case 'silent':
                    return RevealKind.Silent;
                case 'never':
                    return RevealKind.Never;
                default:
                    return RevealKind.Always;
            }
        }
        RevealKind.fromString = fromString;
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    var PanelKind;
    (function (PanelKind) {
        /**
         * Shares a panel with other tasks. This is the default.
         */
        PanelKind[PanelKind["Shared"] = 1] = "Shared";
        /**
         * Uses a dedicated panel for this tasks. The panel is not
         * shared with other tasks.
         */
        PanelKind[PanelKind["Dedicated"] = 2] = "Dedicated";
        /**
         * Creates a new panel whenever this task is executed.
         */
        PanelKind[PanelKind["New"] = 3] = "New";
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    (function (PanelKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shared':
                    return PanelKind.Shared;
                case 'dedicated':
                    return PanelKind.Dedicated;
                case 'new':
                    return PanelKind.New;
                default:
                    return PanelKind.Shared;
            }
        }
        PanelKind.fromString = fromString;
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    var RuntimeType;
    (function (RuntimeType) {
        RuntimeType[RuntimeType["Shell"] = 1] = "Shell";
        RuntimeType[RuntimeType["Process"] = 2] = "Process";
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    (function (RuntimeType) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shell':
                    return RuntimeType.Shell;
                case 'process':
                    return RuntimeType.Process;
                default:
                    return RuntimeType.Process;
            }
        }
        RuntimeType.fromString = fromString;
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    var TaskGroup;
    (function (TaskGroup) {
        TaskGroup.Clean = 'clean';
        TaskGroup.Build = 'build';
        TaskGroup.Rebuild = 'rebuild';
        TaskGroup.Test = 'test';
        function is(value) {
            return value === TaskGroup.Clean || value === TaskGroup.Build || value === TaskGroup.Rebuild || value === TaskGroup.Test;
        }
        TaskGroup.is = is;
    })(TaskGroup = exports.TaskGroup || (exports.TaskGroup = {}));
    var TaskSourceKind;
    (function (TaskSourceKind) {
        TaskSourceKind.Workspace = 'workspace';
        TaskSourceKind.Extension = 'extension';
        TaskSourceKind.Composite = 'composite';
    })(TaskSourceKind = exports.TaskSourceKind || (exports.TaskSourceKind = {}));
    var CustomTask;
    (function (CustomTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.type === 'custom';
        }
        CustomTask.is = is;
    })(CustomTask = exports.CustomTask || (exports.CustomTask = {}));
    var ConfiguringTask;
    (function (ConfiguringTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.configures && Types.isString(candidate.configures.type) && value.command === void 0;
        }
        ConfiguringTask.is = is;
    })(ConfiguringTask = exports.ConfiguringTask || (exports.ConfiguringTask = {}));
    var ContributedTask;
    (function (ContributedTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.defines && Types.isString(candidate.defines.type) && candidate.command !== void 0;
        }
        ContributedTask.is = is;
    })(ContributedTask = exports.ContributedTask || (exports.ContributedTask = {}));
    var CompositeTask;
    (function (CompositeTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate._source && candidate._source.kind === TaskSourceKind.Composite;
        }
        CompositeTask.is = is;
    })(CompositeTask = exports.CompositeTask || (exports.CompositeTask = {}));
    var Task;
    (function (Task) {
        function getKey(task) {
            if (CustomTask.is(task) || CompositeTask.is(task)) {
                return task.identifier;
            }
            else {
                return task.defines._key;
            }
        }
        Task.getKey = getKey;
        function getTelemetryKind(task) {
            if (ContributedTask.is(task)) {
                return 'extension';
            }
            else if (CustomTask.is(task)) {
                if (task._source.customizes) {
                    return 'workspace>extension';
                }
                else {
                    return 'workspace';
                }
            }
            else if (CompositeTask.is(task)) {
                return 'composite';
            }
            else {
                return 'unknown';
            }
        }
        Task.getTelemetryKind = getTelemetryKind;
    })(Task = exports.Task || (exports.Task = {}));
    var ExecutionEngine;
    (function (ExecutionEngine) {
        ExecutionEngine[ExecutionEngine["Process"] = 1] = "Process";
        ExecutionEngine[ExecutionEngine["Terminal"] = 2] = "Terminal";
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    (function (ExecutionEngine) {
        ExecutionEngine._default = ExecutionEngine.Terminal;
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    var JsonSchemaVersion;
    (function (JsonSchemaVersion) {
        JsonSchemaVersion[JsonSchemaVersion["V0_1_0"] = 1] = "V0_1_0";
        JsonSchemaVersion[JsonSchemaVersion["V2_0_0"] = 2] = "V2_0_0";
    })(JsonSchemaVersion = exports.JsonSchemaVersion || (exports.JsonSchemaVersion = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[118/*vs/workbench/services/backup/common/backup*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBackupFileService = instantiation_1.createDecorator('backupFileService');
    exports.BACKUP_FILE_RESOLVE_OPTIONS = { acceptTextOnly: true, encoding: 'utf-8' };
    exports.BACKUP_FILE_UPDATE_OPTIONS = { encoding: 'utf-8' };
});











define(__m[119/*vs/workbench/services/configuration/common/configurationEditing*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IConfigurationEditingService = instantiation_1.createDecorator('configurationEditingService');
    var ConfigurationEditingErrorCode;
    (function (ConfigurationEditingErrorCode) {
        /**
         * Error when trying to write a configuration key that is not registered.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_UNKNOWN_KEY"] = 0] = "ERROR_UNKNOWN_KEY";
        /**
         * Error when trying to write an invalid folder configuration key to folder settings.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_INVALID_FOLDER_CONFIGURATION"] = 1] = "ERROR_INVALID_FOLDER_CONFIGURATION";
        /**
         * Error when trying to write to user target but not supported for provided key.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_INVALID_USER_TARGET"] = 2] = "ERROR_INVALID_USER_TARGET";
        /**
         * Error when trying to write a configuration key to folder target
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_INVALID_FOLDER_TARGET"] = 3] = "ERROR_INVALID_FOLDER_TARGET";
        /**
         * Error when trying to write to the workspace configuration without having a workspace opened.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_NO_WORKSPACE_OPENED"] = 4] = "ERROR_NO_WORKSPACE_OPENED";
        /**
         * Error when trying to write and save to the configuration file while it is dirty in the editor.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_CONFIGURATION_FILE_DIRTY"] = 5] = "ERROR_CONFIGURATION_FILE_DIRTY";
        /**
         * Error when trying to write to a configuration file that contains JSON errors.
         */
        ConfigurationEditingErrorCode[ConfigurationEditingErrorCode["ERROR_INVALID_CONFIGURATION"] = 6] = "ERROR_INVALID_CONFIGURATION";
    })(ConfigurationEditingErrorCode = exports.ConfigurationEditingErrorCode || (exports.ConfigurationEditingErrorCode = {}));
    var ConfigurationEditingError = (function (_super) {
        __extends(ConfigurationEditingError, _super);
        function ConfigurationEditingError(message, code) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            return _this;
        }
        return ConfigurationEditingError;
    }(Error));
    exports.ConfigurationEditingError = ConfigurationEditingError;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        /**
         * Targets the user configuration file for writing.
         */
        ConfigurationTarget[ConfigurationTarget["USER"] = 0] = "USER";
        /**
         * Targets the workspace configuration file for writing. This only works if a workspace is opened.
         */
        ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 1] = "WORKSPACE";
        /**
         * Targets the folder configuration file for writing. This only works if a workspace is opened.
         */
        ConfigurationTarget[ConfigurationTarget["FOLDER"] = 2] = "FOLDER";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
});

define(__m[120/*vs/workbench/api/node/extHostConfiguration*/], __M([1/*require*/,0/*exports*/,11/*vs/base/common/objects*/,3/*vs/base/common/event*/,5/*vs/workbench/api/node/extHostTypes*/,26/*vs/platform/configuration/common/configuration*/,119/*vs/workbench/services/configuration/common/configurationEditing*/]), function (require, exports, objects_1, event_1, extHostTypes_1, configuration_1, configurationEditing_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function lookUp(tree, key) {
        if (key) {
            var parts = key.split('.');
            var node = tree;
            for (var i = 0; node && i < parts.length; i++) {
                node = node[parts[i]];
            }
            return node;
        }
    }
    var ExtHostConfiguration = (function () {
        function ExtHostConfiguration(proxy, extHostWorkspace, data) {
            this._onDidChangeConfiguration = new event_1.Emitter();
            this._proxy = proxy;
            this._extHostWorkspace = extHostWorkspace;
            this._configuration = configuration_1.Configuration.parse(data, extHostWorkspace.workspace);
        }
        Object.defineProperty(ExtHostConfiguration.prototype, "onDidChangeConfiguration", {
            get: function () {
                return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostConfiguration.prototype.$acceptConfigurationChanged = function (data) {
            this._configuration = configuration_1.Configuration.parse(data, this._extHostWorkspace.workspace);
            this._onDidChangeConfiguration.fire(undefined);
        };
        ExtHostConfiguration.prototype.getConfiguration = function (section, resource) {
            var _this = this;
            var config = section
                ? lookUp(this._configuration.getValue(null, { resource: resource }), section)
                : this._configuration.getValue(null, { resource: resource });
            function parseConfigurationTarget(arg) {
                if (arg === void 0 || arg === null) {
                    return null;
                }
                if (typeof arg === 'boolean') {
                    return arg ? configurationEditing_1.ConfigurationTarget.USER : configurationEditing_1.ConfigurationTarget.WORKSPACE;
                }
                switch (arg) {
                    case extHostTypes_1.ConfigurationTarget.Global: return configurationEditing_1.ConfigurationTarget.USER;
                    case extHostTypes_1.ConfigurationTarget.Workspace: return configurationEditing_1.ConfigurationTarget.WORKSPACE;
                    case extHostTypes_1.ConfigurationTarget.WorkspaceFolder: return configurationEditing_1.ConfigurationTarget.FOLDER;
                }
            }
            var result = {
                has: function (key) {
                    return typeof lookUp(config, key) !== 'undefined';
                },
                get: function (key, defaultValue) {
                    var result = lookUp(config, key);
                    if (typeof result === 'undefined') {
                        result = defaultValue;
                    }
                    return result;
                },
                update: function (key, value, arg) {
                    key = section ? section + "." + key : key;
                    var target = parseConfigurationTarget(arg);
                    if (value !== void 0) {
                        return _this._proxy.$updateConfigurationOption(target, key, value, resource);
                    }
                    else {
                        return _this._proxy.$removeConfigurationOption(target, key, resource);
                    }
                },
                inspect: function (key) {
                    key = section ? section + "." + key : key;
                    var config = _this._configuration.lookup(key, { resource: resource });
                    if (config) {
                        return {
                            key: key,
                            defaultValue: config.default,
                            globalValue: config.user,
                            workspaceValue: config.workspace,
                            workspaceFolderValue: config.folder
                        };
                    }
                    return undefined;
                }
            };
            if (typeof config === 'object') {
                objects_1.mixin(result, config, false);
            }
            return Object.freeze(result);
        };
        return ExtHostConfiguration;
    }());
    exports.ExtHostConfiguration = ExtHostConfiguration;
});

define(__m[121/*vs/workbench/services/extensions/node/barrier*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A barrier that is initially closed and then becomes opened permanently.
     */
    var Barrier = (function () {
        function Barrier() {
            var _this = this;
            this._isOpen = false;
            this._promise = new winjs_base_1.TPromise(function (c, e, p) {
                _this._completePromise = c;
            }, function () {
                console.warn('You should really not try to cancel this ready promise!');
            });
        }
        Barrier.prototype.isOpen = function () {
            return this._isOpen;
        };
        Barrier.prototype.open = function () {
            this._isOpen = true;
            this._completePromise(true);
        };
        Barrier.prototype.wait = function () {
            return this._promise;
        };
        return Barrier;
    }());
    exports.Barrier = Barrier;
});

define(__m[122/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var ExtensionDescriptionRegistry = (function () {
        function ExtensionDescriptionRegistry(extensionDescriptions) {
            this._extensionsMap = {};
            this._extensionsArr = [];
            this._activationMap = {};
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                var extensionDescription = extensionDescriptions[i];
                if (hasOwnProperty.call(this._extensionsMap, extensionDescription.id)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.id + '` is already registered');
                    continue;
                }
                this._extensionsMap[extensionDescription.id] = extensionDescription;
                this._extensionsArr.push(extensionDescription);
                if (Array.isArray(extensionDescription.activationEvents)) {
                    for (var j = 0, lenJ = extensionDescription.activationEvents.length; j < lenJ; j++) {
                        var activationEvent = extensionDescription.activationEvents[j];
                        this._activationMap[activationEvent] = this._activationMap[activationEvent] || [];
                        this._activationMap[activationEvent].push(extensionDescription);
                    }
                }
            }
        }
        ExtensionDescriptionRegistry.prototype.containsActivationEvent = function (activationEvent) {
            return hasOwnProperty.call(this._activationMap, activationEvent);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescriptionsForActivationEvent = function (activationEvent) {
            if (!hasOwnProperty.call(this._activationMap, activationEvent)) {
                return [];
            }
            return this._activationMap[activationEvent].slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getAllExtensionDescriptions = function () {
            return this._extensionsArr.slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescription = function (extensionId) {
            if (!hasOwnProperty.call(this._extensionsMap, extensionId)) {
                return null;
            }
            return this._extensionsMap[extensionId];
        };
        return ExtensionDescriptionRegistry;
    }());
    exports.ExtensionDescriptionRegistry = ExtensionDescriptionRegistry;
});

define(__m[123/*vs/workbench/services/extensions/node/lazyPromise*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LazyPromise = (function () {
        function LazyPromise(onCancel) {
            this._onCancel = onCancel;
            this._actual = null;
            this._actualOk = null;
            this._actualErr = null;
            this._hasValue = false;
            this._value = null;
            this._hasErr = false;
            this._err = null;
            this._isCanceled = false;
        }
        LazyPromise.prototype._ensureActual = function () {
            var _this = this;
            if (!this._actual) {
                this._actual = new winjs_base_1.TPromise(function (c, e) {
                    _this._actualOk = c;
                    _this._actualErr = e;
                }, this._onCancel);
                if (this._hasValue) {
                    this._actualOk(this._value);
                }
                if (this._hasErr) {
                    this._actualErr(this._err);
                }
            }
            return this._actual;
        };
        LazyPromise.prototype.resolveOk = function (value) {
            if (this._isCanceled || this._hasErr) {
                return;
            }
            this._hasValue = true;
            this._value = value;
            if (this._actual) {
                this._actualOk(value);
            }
        };
        LazyPromise.prototype.resolveErr = function (err) {
            if (this._isCanceled || this._hasValue) {
                return;
            }
            this._hasErr = true;
            this._err = err;
            if (this._actual) {
                this._actualErr(err);
            }
        };
        LazyPromise.prototype.then = function (success, error) {
            if (this._isCanceled) {
                return;
            }
            return this._ensureActual().then(success, error);
        };
        LazyPromise.prototype.done = function (success, error) {
            if (this._isCanceled) {
                return;
            }
            this._ensureActual().done(success, error);
        };
        LazyPromise.prototype.cancel = function () {
            if (this._hasValue || this._hasErr) {
                return;
            }
            this._isCanceled = true;
            if (this._actual) {
                this._actual.cancel();
            }
            else {
                this._onCancel();
            }
        };
        return LazyPromise;
    }());
    exports.LazyPromise = LazyPromise;
});

define(__m[124/*vs/workbench/services/extensions/node/rpcProtocol*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,61/*vs/base/common/marshalling*/,12/*vs/base/common/errors*/,123/*vs/workbench/services/extensions/node/lazyPromise*/]), function (require, exports, winjs_base_1, marshalling, errors, lazyPromise_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RPCProtocol = (function () {
        function RPCProtocol(protocol) {
            var _this = this;
            this._isDisposed = false;
            this._bigHandler = null;
            this._lastMessageId = 0;
            this._invokedHandlers = Object.create(null);
            this._pendingRPCReplies = {};
            this._multiplexor = new RPCMultiplexer(protocol, function (msg) { return _this._receiveOneMessage(msg); });
        }
        RPCProtocol.prototype.dispose = function () {
            var _this = this;
            this._isDisposed = true;
            // Release all outstanding promises with a canceled error
            Object.keys(this._pendingRPCReplies).forEach(function (msgId) {
                var pending = _this._pendingRPCReplies[msgId];
                pending.resolveErr(errors.canceled());
            });
        };
        RPCProtocol.prototype._receiveOneMessage = function (rawmsg) {
            var _this = this;
            if (this._isDisposed) {
                console.warn('Received message after being shutdown: ', rawmsg);
                return;
            }
            var msg = marshalling.parse(rawmsg);
            if (msg.seq) {
                if (!this._pendingRPCReplies.hasOwnProperty(msg.seq)) {
                    console.warn('Got reply to unknown seq');
                    return;
                }
                var reply = this._pendingRPCReplies[msg.seq];
                delete this._pendingRPCReplies[msg.seq];
                if (msg.err) {
                    var err = msg.err;
                    if (msg.err.$isError) {
                        err = new Error();
                        err.name = msg.err.name;
                        err.message = msg.err.message;
                        err.stack = msg.err.stack;
                    }
                    reply.resolveErr(err);
                    return;
                }
                reply.resolveOk(msg.res);
                return;
            }
            if (msg.cancel) {
                if (this._invokedHandlers[msg.cancel]) {
                    this._invokedHandlers[msg.cancel].cancel();
                }
                return;
            }
            if (msg.err) {
                console.error(msg.err);
                return;
            }
            var rpcId = msg.rpcId;
            if (!this._bigHandler) {
                throw new Error('got message before big handler attached!');
            }
            var req = msg.req;
            this._invokedHandlers[req] = this._invokeHandler(rpcId, msg.method, msg.args);
            this._invokedHandlers[req].then(function (r) {
                delete _this._invokedHandlers[req];
                _this._multiplexor.send(MessageFactory.replyOK(req, r));
            }, function (err) {
                delete _this._invokedHandlers[req];
                _this._multiplexor.send(MessageFactory.replyErr(req, err));
            });
        };
        RPCProtocol.prototype._invokeHandler = function (proxyId, methodName, args) {
            try {
                return winjs_base_1.TPromise.as(this._bigHandler.invoke(proxyId, methodName, args));
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        RPCProtocol.prototype.callOnRemote = function (proxyId, methodName, args) {
            var _this = this;
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(errors.canceled());
            }
            var req = String(++this._lastMessageId);
            var result = new lazyPromise_1.LazyPromise(function () {
                _this._multiplexor.send(MessageFactory.cancel(req));
            });
            this._pendingRPCReplies[req] = result;
            this._multiplexor.send(MessageFactory.request(req, proxyId, methodName, args));
            return result;
        };
        RPCProtocol.prototype.setDispatcher = function (handler) {
            this._bigHandler = handler;
        };
        return RPCProtocol;
    }());
    exports.RPCProtocol = RPCProtocol;
    /**
     * Sends/Receives multiple messages in one go:
     *  - multiple messages to be sent from one stack get sent in bulk at `process.nextTick`.
     *  - each incoming message is handled in a separate `process.nextTick`.
     */
    var RPCMultiplexer = (function () {
        function RPCMultiplexer(protocol, onMessage) {
            this._protocol = protocol;
            this._sendAccumulatedBound = this._sendAccumulated.bind(this);
            this._messagesToSend = [];
            this._protocol.onMessage(function (data) {
                for (var i = 0, len = data.length; i < len; i++) {
                    onMessage(data[i]);
                }
            });
        }
        RPCMultiplexer.prototype._sendAccumulated = function () {
            var tmp = this._messagesToSend;
            this._messagesToSend = [];
            this._protocol.send(tmp);
        };
        RPCMultiplexer.prototype.send = function (msg) {
            if (this._messagesToSend.length === 0) {
                process.nextTick(this._sendAccumulatedBound);
            }
            this._messagesToSend.push(msg);
        };
        return RPCMultiplexer;
    }());
    var MessageFactory = (function () {
        function MessageFactory() {
        }
        MessageFactory.cancel = function (req) {
            return "{\"cancel\":\"" + req + "\"}";
        };
        MessageFactory.request = function (req, rpcId, method, args) {
            return "{\"req\":\"" + req + "\",\"rpcId\":\"" + rpcId + "\",\"method\":\"" + method + "\",\"args\":" + marshalling.stringify(args) + "}";
        };
        MessageFactory.replyOK = function (req, res) {
            if (typeof res === 'undefined') {
                return "{\"seq\":\"" + req + "\"}";
            }
            return "{\"seq\":\"" + req + "\",\"res\":" + marshalling.stringify(res) + "}";
        };
        MessageFactory.replyErr = function (req, err) {
            if (typeof err === 'undefined') {
                return "{\"seq\":\"" + req + "\",\"err\":null}";
            }
            return "{\"seq\":\"" + req + "\",\"err\":" + marshalling.stringify(errors.transformErrorForSerialization(err)) + "}";
        };
        return MessageFactory;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[125/*vs/workbench/services/search/node/searchIpc*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchChannel = (function () {
        function SearchChannel(service) {
            this.service = service;
        }
        SearchChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'fileSearch': return this.service.fileSearch(arg);
                case 'textSearch': return this.service.textSearch(arg);
                case 'clearCache': return this.service.clearCache(arg);
            }
            return undefined;
        };
        return SearchChannel;
    }());
    exports.SearchChannel = SearchChannel;
    var SearchChannelClient = (function () {
        function SearchChannelClient(channel) {
            this.channel = channel;
        }
        SearchChannelClient.prototype.fileSearch = function (search) {
            return this.channel.call('fileSearch', search);
        };
        SearchChannelClient.prototype.textSearch = function (search) {
            return this.channel.call('textSearch', search);
        };
        SearchChannelClient.prototype.clearCache = function (cacheKey) {
            return this.channel.call('clearCache', cacheKey);
        };
        return SearchChannelClient;
    }());
    exports.SearchChannelClient = SearchChannelClient;
});

define(__m[37/*vs/workbench/services/textfile/common/textfiles*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * States the text text file editor model can be in.
     */
    var ModelState;
    (function (ModelState) {
        ModelState[ModelState["SAVED"] = 0] = "SAVED";
        ModelState[ModelState["DIRTY"] = 1] = "DIRTY";
        ModelState[ModelState["PENDING_SAVE"] = 2] = "PENDING_SAVE";
        /**
         * A model is in conflict mode when changes cannot be saved because the
         * underlying file has changed. Models in conflict mode are always dirty.
         */
        ModelState[ModelState["CONFLICT"] = 3] = "CONFLICT";
        /**
         * A model is in orphan state when the underlying file has been deleted.
         */
        ModelState[ModelState["ORPHAN"] = 4] = "ORPHAN";
        /**
         * Any error that happens during a save that is not causing the CONFLICT state.
         * Models in error mode are always diry.
         */
        ModelState[ModelState["ERROR"] = 5] = "ERROR";
    })(ModelState = exports.ModelState || (exports.ModelState = {}));
    var StateChange;
    (function (StateChange) {
        StateChange[StateChange["DIRTY"] = 0] = "DIRTY";
        StateChange[StateChange["SAVING"] = 1] = "SAVING";
        StateChange[StateChange["SAVE_ERROR"] = 2] = "SAVE_ERROR";
        StateChange[StateChange["SAVED"] = 3] = "SAVED";
        StateChange[StateChange["REVERTED"] = 4] = "REVERTED";
        StateChange[StateChange["ENCODING"] = 5] = "ENCODING";
        StateChange[StateChange["CONTENT_CHANGE"] = 6] = "CONTENT_CHANGE";
        StateChange[StateChange["ORPHANED_CHANGE"] = 7] = "ORPHANED_CHANGE";
    })(StateChange = exports.StateChange || (exports.StateChange = {}));
    var TextFileModelChangeEvent = (function () {
        function TextFileModelChangeEvent(model, kind) {
            this._resource = model.getResource();
            this._kind = kind;
        }
        Object.defineProperty(TextFileModelChangeEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileModelChangeEvent.prototype, "kind", {
            get: function () {
                return this._kind;
            },
            enumerable: true,
            configurable: true
        });
        return TextFileModelChangeEvent;
    }());
    exports.TextFileModelChangeEvent = TextFileModelChangeEvent;
    exports.TEXT_FILE_SERVICE_ID = 'textFileService';
    var AutoSaveMode;
    (function (AutoSaveMode) {
        AutoSaveMode[AutoSaveMode["OFF"] = 0] = "OFF";
        AutoSaveMode[AutoSaveMode["AFTER_SHORT_DELAY"] = 1] = "AFTER_SHORT_DELAY";
        AutoSaveMode[AutoSaveMode["AFTER_LONG_DELAY"] = 2] = "AFTER_LONG_DELAY";
        AutoSaveMode[AutoSaveMode["ON_FOCUS_CHANGE"] = 3] = "ON_FOCUS_CHANGE";
        AutoSaveMode[AutoSaveMode["ON_WINDOW_CHANGE"] = 4] = "ON_WINDOW_CHANGE";
    })(AutoSaveMode = exports.AutoSaveMode || (exports.AutoSaveMode = {}));
    var SaveReason;
    (function (SaveReason) {
        SaveReason[SaveReason["EXPLICIT"] = 1] = "EXPLICIT";
        SaveReason[SaveReason["AUTO"] = 2] = "AUTO";
        SaveReason[SaveReason["FOCUS_CHANGE"] = 3] = "FOCUS_CHANGE";
        SaveReason[SaveReason["WINDOW_CHANGE"] = 4] = "WINDOW_CHANGE";
    })(SaveReason = exports.SaveReason || (exports.SaveReason = {}));
    exports.ITextFileService = instantiation_1.createDecorator(exports.TEXT_FILE_SERVICE_ID);
});

define(__m[16/*vs/workbench/api/node/extHostTypeConverters*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/severity*/,38/*vs/editor/common/modes*/,5/*vs/workbench/api/node/extHostTypes*/,48/*vs/platform/editor/common/editor*/,23/*vs/editor/common/editorCommon*/,6/*vs/base/common/uri*/,50/*vs/platform/progress/common/progress*/,37/*vs/workbench/services/textfile/common/textfiles*/,27/*vs/base/common/htmlContent*/]), function (require, exports, severity_1, modes, types, editor_1, editorCommon_1, uri_1, progress_1, textfiles_1, htmlContent) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function toSelection(selection) {
        var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
        var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
        var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
        return new types.Selection(start, end);
    }
    exports.toSelection = toSelection;
    function fromSelection(selection) {
        var anchor = selection.anchor, active = selection.active;
        return {
            selectionStartLineNumber: anchor.line + 1,
            selectionStartColumn: anchor.character + 1,
            positionLineNumber: active.line + 1,
            positionColumn: active.character + 1
        };
    }
    exports.fromSelection = fromSelection;
    function fromRange(range) {
        if (!range) {
            return undefined;
        }
        var start = range.start, end = range.end;
        return {
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    exports.fromRange = fromRange;
    function toRange(range) {
        if (!range) {
            return undefined;
        }
        var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
        return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
    }
    exports.toRange = toRange;
    function toPosition(position) {
        return new types.Position(position.lineNumber - 1, position.column - 1);
    }
    exports.toPosition = toPosition;
    function fromPosition(position) {
        return { lineNumber: position.line + 1, column: position.character + 1 };
    }
    exports.fromPosition = fromPosition;
    function fromDiagnosticSeverity(value) {
        switch (value) {
            case types.DiagnosticSeverity.Error:
                return severity_1.default.Error;
            case types.DiagnosticSeverity.Warning:
                return severity_1.default.Warning;
            case types.DiagnosticSeverity.Information:
                return severity_1.default.Info;
            case types.DiagnosticSeverity.Hint:
                return severity_1.default.Ignore;
        }
        return severity_1.default.Error;
    }
    exports.fromDiagnosticSeverity = fromDiagnosticSeverity;
    function toDiagnosticSeverty(value) {
        switch (value) {
            case severity_1.default.Info:
                return types.DiagnosticSeverity.Information;
            case severity_1.default.Warning:
                return types.DiagnosticSeverity.Warning;
            case severity_1.default.Error:
                return types.DiagnosticSeverity.Error;
            case severity_1.default.Ignore:
                return types.DiagnosticSeverity.Hint;
        }
        return types.DiagnosticSeverity.Error;
    }
    exports.toDiagnosticSeverty = toDiagnosticSeverty;
    function fromViewColumn(column) {
        var editorColumn = editor_1.Position.ONE;
        if (typeof column !== 'number') {
            // stick with ONE
        }
        else if (column === types.ViewColumn.Two) {
            editorColumn = editor_1.Position.TWO;
        }
        else if (column === types.ViewColumn.Three) {
            editorColumn = editor_1.Position.THREE;
        }
        return editorColumn;
    }
    exports.fromViewColumn = fromViewColumn;
    function toViewColumn(position) {
        if (typeof position !== 'number') {
            return undefined;
        }
        if (position === editor_1.Position.ONE) {
            return types.ViewColumn.One;
        }
        else if (position === editor_1.Position.TWO) {
            return types.ViewColumn.Two;
        }
        else if (position === editor_1.Position.THREE) {
            return types.ViewColumn.Three;
        }
        return undefined;
    }
    exports.toViewColumn = toViewColumn;
    function isDecorationOptions(something) {
        return (typeof something.range !== 'undefined');
    }
    function isDecorationOptionsArr(something) {
        if (something.length === 0) {
            return true;
        }
        return isDecorationOptions(something[0]) ? true : false;
    }
    var MarkdownString;
    (function (MarkdownString) {
        function fromMany(markup) {
            return markup.map(MarkdownString.from);
        }
        MarkdownString.fromMany = fromMany;
        function isCodeblock(thing) {
            return typeof thing === 'object'
                && typeof thing.language === 'string'
                && typeof thing.value === 'string';
        }
        function from(markup) {
            if (isCodeblock(markup)) {
                var language = markup.language, value = markup.value;
                return { value: '```' + language + '\n' + value + '\n```\n' };
            }
            else if (htmlContent.isMarkdownString(markup)) {
                return markup;
            }
            else if (typeof markup === 'string') {
                return { value: markup, isTrusted: true };
            }
            else {
                return { value: '' };
            }
        }
        MarkdownString.from = from;
        function to(value) {
            var ret = new htmlContent.MarkdownString(value.value);
            ret.isTrusted = value.isTrusted;
            return ret;
        }
        MarkdownString.to = to;
    })(MarkdownString = exports.MarkdownString || (exports.MarkdownString = {}));
    function fromRangeOrRangeWithMessage(ranges) {
        if (isDecorationOptionsArr(ranges)) {
            return ranges.map(function (r) {
                return {
                    range: fromRange(r.range),
                    hoverMessage: Array.isArray(r.hoverMessage) ? MarkdownString.fromMany(r.hoverMessage) : r.hoverMessage && MarkdownString.from(r.hoverMessage),
                    renderOptions: r.renderOptions
                };
            });
        }
        else {
            return ranges.map(function (r) {
                return {
                    range: fromRange(r)
                };
            });
        }
    }
    exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
    exports.TextEdit = {
        from: function (edit) {
            return {
                text: edit.newText,
                eol: EndOfLine.from(edit.newEol),
                range: fromRange(edit.range)
            };
        },
        to: function (edit) {
            var result = new types.TextEdit(toRange(edit.range), edit.text);
            result.newEol = EndOfLine.to(edit.eol);
            return result;
        }
    };
    var SymbolKind;
    (function (SymbolKind) {
        var _fromMapping = Object.create(null);
        _fromMapping[types.SymbolKind.File] = modes.SymbolKind.File;
        _fromMapping[types.SymbolKind.Module] = modes.SymbolKind.Module;
        _fromMapping[types.SymbolKind.Namespace] = modes.SymbolKind.Namespace;
        _fromMapping[types.SymbolKind.Package] = modes.SymbolKind.Package;
        _fromMapping[types.SymbolKind.Class] = modes.SymbolKind.Class;
        _fromMapping[types.SymbolKind.Method] = modes.SymbolKind.Method;
        _fromMapping[types.SymbolKind.Property] = modes.SymbolKind.Property;
        _fromMapping[types.SymbolKind.Field] = modes.SymbolKind.Field;
        _fromMapping[types.SymbolKind.Constructor] = modes.SymbolKind.Constructor;
        _fromMapping[types.SymbolKind.Enum] = modes.SymbolKind.Enum;
        _fromMapping[types.SymbolKind.Interface] = modes.SymbolKind.Interface;
        _fromMapping[types.SymbolKind.Function] = modes.SymbolKind.Function;
        _fromMapping[types.SymbolKind.Variable] = modes.SymbolKind.Variable;
        _fromMapping[types.SymbolKind.Constant] = modes.SymbolKind.Constant;
        _fromMapping[types.SymbolKind.String] = modes.SymbolKind.String;
        _fromMapping[types.SymbolKind.Number] = modes.SymbolKind.Number;
        _fromMapping[types.SymbolKind.Boolean] = modes.SymbolKind.Boolean;
        _fromMapping[types.SymbolKind.Array] = modes.SymbolKind.Array;
        _fromMapping[types.SymbolKind.Object] = modes.SymbolKind.Object;
        _fromMapping[types.SymbolKind.Key] = modes.SymbolKind.Key;
        _fromMapping[types.SymbolKind.Null] = modes.SymbolKind.Null;
        _fromMapping[types.SymbolKind.EnumMember] = modes.SymbolKind.EnumMember;
        _fromMapping[types.SymbolKind.Struct] = modes.SymbolKind.Struct;
        _fromMapping[types.SymbolKind.Event] = modes.SymbolKind.Event;
        _fromMapping[types.SymbolKind.Operator] = modes.SymbolKind.Operator;
        _fromMapping[types.SymbolKind.TypeParameter] = modes.SymbolKind.TypeParameter;
        function from(kind) {
            return _fromMapping[kind] || modes.SymbolKind.Property;
        }
        SymbolKind.from = from;
        function to(kind) {
            for (var k in _fromMapping) {
                if (_fromMapping[k] === kind) {
                    return Number(k);
                }
            }
            return types.SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    function fromSymbolInformation(info) {
        return {
            name: info.name,
            kind: SymbolKind.from(info.kind),
            containerName: info.containerName,
            location: exports.location.from(info.location)
        };
    }
    exports.fromSymbolInformation = fromSymbolInformation;
    function toSymbolInformation(bearing) {
        return new types.SymbolInformation(bearing.name, SymbolKind.to(bearing.kind), bearing.containerName, exports.location.to(bearing.location));
    }
    exports.toSymbolInformation = toSymbolInformation;
    exports.location = {
        from: function (value) {
            return {
                range: value.range && fromRange(value.range),
                uri: value.uri
            };
        },
        to: function (value) {
            return new types.Location(value.uri, toRange(value.range));
        }
    };
    function fromHover(hover) {
        return {
            range: fromRange(hover.range),
            contents: MarkdownString.fromMany(hover.contents)
        };
    }
    exports.fromHover = fromHover;
    function toHover(info) {
        return new types.Hover(info.contents.map(MarkdownString.to), toRange(info.range));
    }
    exports.toHover = toHover;
    function toDocumentHighlight(occurrence) {
        return new types.DocumentHighlight(toRange(occurrence.range), occurrence.kind);
    }
    exports.toDocumentHighlight = toDocumentHighlight;
    exports.CompletionItemKind = {
        from: function (kind) {
            switch (kind) {
                case types.CompletionItemKind.Method: return 'method';
                case types.CompletionItemKind.Function: return 'function';
                case types.CompletionItemKind.Constructor: return 'constructor';
                case types.CompletionItemKind.Field: return 'field';
                case types.CompletionItemKind.Variable: return 'variable';
                case types.CompletionItemKind.Class: return 'class';
                case types.CompletionItemKind.Interface: return 'interface';
                case types.CompletionItemKind.Struct: return 'struct';
                case types.CompletionItemKind.Module: return 'module';
                case types.CompletionItemKind.Property: return 'property';
                case types.CompletionItemKind.Unit: return 'unit';
                case types.CompletionItemKind.Value: return 'value';
                case types.CompletionItemKind.Constant: return 'constant';
                case types.CompletionItemKind.Enum: return 'enum';
                case types.CompletionItemKind.EnumMember: return 'enum-member';
                case types.CompletionItemKind.Keyword: return 'keyword';
                case types.CompletionItemKind.Snippet: return 'snippet';
                case types.CompletionItemKind.Text: return 'text';
                case types.CompletionItemKind.Color: return 'color';
                case types.CompletionItemKind.File: return 'file';
                case types.CompletionItemKind.Reference: return 'reference';
                case types.CompletionItemKind.Folder: return 'folder';
                case types.CompletionItemKind.Event: return 'event';
                case types.CompletionItemKind.Operator: return 'operator';
                case types.CompletionItemKind.TypeParameter: return 'type-parameter';
            }
            return 'property';
        },
        to: function (type) {
            if (!type) {
                return types.CompletionItemKind.Property;
            }
            else {
                return types.CompletionItemKind[type.charAt(0).toUpperCase() + type.substr(1)];
            }
        }
    };
    var Suggest;
    (function (Suggest) {
        function to(position, suggestion) {
            var result = new types.CompletionItem(suggestion.label);
            result.insertText = suggestion.insertText;
            result.kind = exports.CompletionItemKind.to(suggestion.type);
            result.detail = suggestion.detail;
            result.documentation = suggestion.documentation;
            result.sortText = suggestion.sortText;
            result.filterText = suggestion.filterText;
            // 'overwrite[Before|After]'-logic
            var overwriteBefore = (typeof suggestion.overwriteBefore === 'number') ? suggestion.overwriteBefore : 0;
            var startPosition = new types.Position(position.line, Math.max(0, position.character - overwriteBefore));
            var endPosition = position;
            if (typeof suggestion.overwriteAfter === 'number') {
                endPosition = new types.Position(position.line, position.character + suggestion.overwriteAfter);
            }
            result.range = new types.Range(startPosition, endPosition);
            // 'inserText'-logic
            if (suggestion.snippetType === 'textmate') {
                result.insertText = new types.SnippetString(suggestion.insertText);
            }
            else {
                result.insertText = suggestion.insertText;
                result.textEdit = new types.TextEdit(result.range, result.insertText);
            }
            // TODO additionalEdits, command
            return result;
        }
        Suggest.to = to;
    })(Suggest = exports.Suggest || (exports.Suggest = {}));
    ;
    var SignatureHelp;
    (function (SignatureHelp) {
        function from(signatureHelp) {
            return signatureHelp;
        }
        SignatureHelp.from = from;
        function to(hints) {
            return hints;
        }
        SignatureHelp.to = to;
    })(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
    var DocumentLink;
    (function (DocumentLink) {
        function from(link) {
            return {
                range: fromRange(link.range),
                url: link.target && link.target.toString()
            };
        }
        DocumentLink.from = from;
        function to(link) {
            return new types.DocumentLink(toRange(link.range), link.url && uri_1.default.parse(link.url));
        }
        DocumentLink.to = to;
    })(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        function to(reason) {
            switch (reason) {
                case textfiles_1.SaveReason.AUTO:
                    return types.TextDocumentSaveReason.AfterDelay;
                case textfiles_1.SaveReason.EXPLICIT:
                    return types.TextDocumentSaveReason.Manual;
                case textfiles_1.SaveReason.FOCUS_CHANGE:
                case textfiles_1.SaveReason.WINDOW_CHANGE:
                    return types.TextDocumentSaveReason.FocusOut;
            }
        }
        TextDocumentSaveReason.to = to;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var EndOfLine;
    (function (EndOfLine) {
        function from(eol) {
            if (eol === types.EndOfLine.CRLF) {
                return editorCommon_1.EndOfLineSequence.CRLF;
            }
            else if (eol === types.EndOfLine.LF) {
                return editorCommon_1.EndOfLineSequence.LF;
            }
            return undefined;
        }
        EndOfLine.from = from;
        function to(eol) {
            if (eol === editorCommon_1.EndOfLineSequence.CRLF) {
                return types.EndOfLine.CRLF;
            }
            else if (eol === editorCommon_1.EndOfLineSequence.LF) {
                return types.EndOfLine.LF;
            }
            return undefined;
        }
        EndOfLine.to = to;
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var ProgressLocation;
    (function (ProgressLocation) {
        function from(loc) {
            switch (loc) {
                case types.ProgressLocation.SourceControl: return progress_1.ProgressLocation.Scm;
                case types.ProgressLocation.Window: return progress_1.ProgressLocation.Window;
            }
            return undefined;
        }
        ProgressLocation.from = from;
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
});

define(__m[128/*vs/workbench/api/node/extHostApiCommands*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,16/*vs/workbench/api/node/extHostTypeConverters*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, uri_1, winjs_base_1, typeConverters, types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostApiCommands = (function () {
        function ExtHostApiCommands(commands) {
            this._disposables = [];
            this._commands = commands;
        }
        ExtHostApiCommands.register = function (commands) {
            return new ExtHostApiCommands(commands).registerCommands();
        };
        ExtHostApiCommands.prototype.registerCommands = function () {
            var _this = this;
            this._register('vscode.executeWorkspaceSymbolProvider', this._executeWorkspaceSymbolProvider, {
                description: 'Execute all workspace symbol provider.',
                args: [{ name: 'query', description: 'Search string', constraint: String }],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeDefinitionProvider', this._executeDefinitionProvider, {
                description: 'Execute all definition provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeImplementationProvider', this._executeImplementationProvider, {
                description: 'Execute all implementation providers.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instance.'
            });
            this._register('vscode.executeHoverProvider', this._executeHoverProvider, {
                description: 'Execute all hover provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Hover-instances.'
            });
            this._register('vscode.executeDocumentHighlights', this._executeDocumentHighlights, {
                description: 'Execute document highlight provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of DocumentHighlight-instances.'
            });
            this._register('vscode.executeReferenceProvider', this._executeReferenceProvider, {
                description: 'Execute reference provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeDocumentRenameProvider', this._executeDocumentRenameProvider, {
                description: 'Execute rename provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'newName', description: 'The new symbol name', constraint: String }
                ],
                returns: 'A promise that resolves to a WorkspaceEdit.'
            });
            this._register('vscode.executeSignatureHelpProvider', this._executeSignatureHelpProvider, {
                description: 'Execute signature help provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger signature help when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } }
                ],
                returns: 'A promise that resolves to SignatureHelp.'
            });
            this._register('vscode.executeDocumentSymbolProvider', this._executeDocumentSymbolProvider, {
                description: 'Execute document symbol provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeCompletionItemProvider', this._executeCompletionItemProvider, {
                description: 'Execute completion item provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger completion when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } }
                ],
                returns: 'A promise that resolves to a CompletionList-instance.'
            });
            this._register('vscode.executeCodeActionProvider', this._executeCodeActionProvider, {
                description: 'Execute code action provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range }
                ],
                returns: 'A promise that resolves to an array of Command-instances.'
            });
            this._register('vscode.executeCodeLensProvider', this._executeCodeLensProvider, {
                description: 'Execute CodeLens provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of CodeLens-instances.'
            });
            this._register('vscode.executeFormatDocumentProvider', this._executeFormatDocumentProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatRangeProvider', this._executeFormatRangeProvider, {
                description: 'Execute range format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatOnTypeProvider', this._executeFormatOnTypeProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'ch', description: 'Character that got typed', constraint: String },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeLinkProvider', this._executeDocumentLinkProvider, {
                description: 'Execute document link provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.default }
                ],
                returns: 'A promise that resolves to an array of DocumentLink-instances.'
            });
            this._register('vscode.previewHtml', function (uri, position, label, options) {
                return _this._commands.executeCommand('_workbench.previewHtml', uri, typeof position === 'number' && typeConverters.fromViewColumn(position), label, options);
            }, {
                description: "\n\t\t\t\t\tRender the html of the resource in an editor view.\n\n\t\t\t\t\tSee [working with the html preview](https://code.visualstudio.com/docs/extensionAPI/vscode-api-commands#working-with-the-html-preview) for more information about the html preview's intergration with the editor and for best practices for extension authors.\n\t\t\t\t",
                args: [
                    { name: 'uri', description: 'Uri of the resource to preview.', constraint: function (value) { return value instanceof uri_1.default || typeof value === 'string'; } },
                    { name: 'column', description: '(optional) Column in which to preview.', constraint: function (value) { return typeof value === 'undefined' || (typeof value === 'number' && typeof types.ViewColumn[value] === 'string'); } },
                    { name: 'label', description: '(optional) An human readable string that is used as title for the preview.', constraint: function (v) { return typeof v === 'string' || typeof v === 'undefined'; } },
                    { name: 'options', description: '(optional) Options for controlling webview environment.', constraint: function (v) { return typeof v === 'object' || typeof v === 'undefined'; } }
                ]
            });
            this._register('vscode.openFolder', function (uri, forceNewWindow) {
                if (!uri) {
                    return _this._commands.executeCommand('_files.pickFolderAndOpen', forceNewWindow);
                }
                return _this._commands.executeCommand('_files.windowOpen', [uri.fsPath], forceNewWindow);
            }, {
                description: 'Open a folder in the current window or new window depending on the newWindow argument. Note that opening in the same window will shutdown the current extension host process and start a new one on the given folder unless the newWindow parameter is set to true.',
                args: [
                    { name: 'uri', description: '(optional) Uri of the folder to open. If not provided, a native dialog will ask the user for the folder', constraint: function (value) { return value === void 0 || value instanceof uri_1.default; } },
                    { name: 'newWindow', description: '(optional) Whether to open the folder in a new window or the same. Defaults to opening in the same window.', constraint: function (value) { return value === void 0 || typeof value === 'boolean'; } }
                ]
            });
            this._register('vscode.startDebug', function (configuration, folderUri) {
                return _this._commands.executeCommand('_workbench.startDebug', configuration, folderUri);
            }, {
                description: 'Start a debugging session.',
                args: [
                    { name: 'configuration', description: '(optional) Name of the debug configuration from \'launch.json\' to use. Or a configuration json object to use.' }
                ]
            });
            this._register('vscode.diff', function (left, right, label, options) {
                var editorOptions;
                if (options) {
                    editorOptions = {
                        pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,
                        preserveFocus: options.preserveFocus,
                        selection: typeof options.selection === 'object' ? typeConverters.fromRange(options.selection) : undefined
                    };
                }
                return _this._commands.executeCommand('_workbench.diff', [
                    left, right,
                    label,
                    undefined,
                    editorOptions,
                    options ? typeConverters.fromViewColumn(options.viewColumn) : undefined
                ]);
            }, {
                description: 'Opens the provided resources in the diff editor to compare their contents.',
                args: [
                    { name: 'left', description: 'Left-hand side resource of the diff editor', constraint: uri_1.default },
                    { name: 'right', description: 'Right-hand side resource of the diff editor', constraint: uri_1.default },
                    { name: 'title', description: '(optional) Human readable title for the diff editor', constraint: function (v) { return v === void 0 || typeof v === 'string'; } },
                    { name: 'options', description: '(optional) Editor options, see vscode.TextDocumentShowOptions' }
                ]
            });
            this._register('vscode.open', function (resource, column) {
                return _this._commands.executeCommand('_workbench.open', [resource, typeConverters.fromViewColumn(column)]);
            }, {
                description: 'Opens the provided resource in the editor. Can be a text or binary file, or a http(s) url. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.',
                args: [
                    { name: 'resource', description: 'Resource to open', constraint: uri_1.default },
                    { name: 'column', description: '(optional) Column in which to open', constraint: function (v) { return v === void 0 || typeof v === 'number'; } }
                ]
            });
        };
        // --- command impl
        ExtHostApiCommands.prototype._register = function (id, handler, description) {
            var disposable = this._commands.registerCommand(id, handler, this, description);
            this._disposables.push(disposable);
        };
        /**
         * Execute workspace symbol provider.
         *
         * @param query Search string to match query symbol names
         * @return A promise that resolves to an array of symbol information.
         */
        ExtHostApiCommands.prototype._executeWorkspaceSymbolProvider = function (query) {
            return this._commands.executeCommand('_executeWorkspaceSymbolProvider', { query: query }).then(function (value) {
                var result = [];
                if (Array.isArray(value)) {
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var tuple = value_1[_i];
                        result.push.apply(result, tuple[1].map(typeConverters.toSymbolInformation));
                    }
                }
                return result;
            });
        };
        ExtHostApiCommands.prototype._executeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeDefinitionProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.location.to);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeImplementationProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeImplementationProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.location.to);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeHoverProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeHoverProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.toHover);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentHighlights = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeDocumentHighlights', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.toDocumentHighlight);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeReferenceProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position)
            };
            return this._commands.executeCommand('_executeReferenceProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.location.to);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentRenameProvider = function (resource, position, newName) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                newName: newName
            };
            return this._commands.executeCommand('_executeDocumentRenameProvider', args).then(function (value) {
                if (!value) {
                    return undefined;
                }
                if (value.rejectReason) {
                    return winjs_base_1.TPromise.wrapError(new Error(value.rejectReason));
                }
                var workspaceEdit = new types.WorkspaceEdit();
                for (var _i = 0, _a = value.edits; _i < _a.length; _i++) {
                    var edit = _a[_i];
                    workspaceEdit.replace(edit.resource, typeConverters.toRange(edit.range), edit.newText);
                }
                return workspaceEdit;
            });
        };
        ExtHostApiCommands.prototype._executeSignatureHelpProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeSignatureHelpProvider', args).then(function (value) {
                if (value) {
                    return typeConverters.SignatureHelp.to(value);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeCompletionItemProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.fromPosition(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeCompletionItemProvider', args).then(function (result) {
                if (result) {
                    var items = result.suggestions.map(function (suggestion) { return typeConverters.Suggest.to(position, suggestion); });
                    return new types.CompletionList(items, result.incomplete);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentSymbolProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentSymbolProvider', args).then(function (value) {
                if (value && Array.isArray(value.entries)) {
                    return value.entries.map(typeConverters.toSymbolInformation);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeCodeActionProvider = function (resource, range) {
            var _this = this;
            var args = {
                resource: resource,
                range: typeConverters.fromRange(range)
            };
            return this._commands.executeCommand('_executeCodeActionProvider', args).then(function (value) {
                if (!Array.isArray(value)) {
                    return undefined;
                }
                return value.map(function (quickFix) { return _this._commands.converter.fromInternal(quickFix); });
            });
        };
        ExtHostApiCommands.prototype._executeCodeLensProvider = function (resource) {
            var _this = this;
            var args = { resource: resource };
            return this._commands.executeCommand('_executeCodeLensProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (item) {
                        return new types.CodeLens(typeConverters.toRange(item.range), _this._commands.converter.fromInternal(item.command));
                    });
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeFormatDocumentProvider = function (resource, options) {
            var args = {
                resource: resource,
                options: options
            };
            return this._commands.executeCommand('_executeFormatDocumentProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeFormatRangeProvider = function (resource, range, options) {
            var args = {
                resource: resource,
                range: typeConverters.fromRange(range),
                options: options
            };
            return this._commands.executeCommand('_executeFormatRangeProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeFormatOnTypeProvider = function (resource, position, ch, options) {
            var args = {
                resource: resource,
                position: typeConverters.fromPosition(position),
                ch: ch,
                options: options
            };
            return this._commands.executeCommand('_executeFormatOnTypeProvider', args).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (edit) { return new types.TextEdit(typeConverters.toRange(edit.range), edit.text); });
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentLinkProvider = function (resource) {
            return this._commands.executeCommand('_executeLinkProvider', resource).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConverters.DocumentLink.to);
                }
                return undefined;
            });
        };
        return ExtHostApiCommands;
    }());
    exports.ExtHostApiCommands = ExtHostApiCommands;
});

define(__m[129/*vs/workbench/api/node/extHostDocumentSaveParticipant*/], __M([1/*require*/,0/*exports*/,57/*vs/base/common/callbackList*/,10/*vs/base/common/async*/,12/*vs/base/common/errors*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,16/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, callbackList_1, async_1, errors_1, winjs_base_1, extHostTypes_1, extHostTypeConverters_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentSaveParticipant = (function () {
        function ExtHostDocumentSaveParticipant(documents, workspace, thresholds) {
            if (thresholds === void 0) { thresholds = { timeout: 1500, errors: 3 }; }
            this._callbacks = new callbackList_1.default();
            this._badListeners = new WeakMap();
            this._documents = documents;
            this._workspace = workspace;
            this._thresholds = thresholds;
        }
        ExtHostDocumentSaveParticipant.prototype.dispose = function () {
            this._callbacks.dispose();
        };
        Object.defineProperty(ExtHostDocumentSaveParticipant.prototype, "onWillSaveTextDocumentEvent", {
            get: function () {
                var _this = this;
                return function (listener, thisArg, disposables) {
                    _this._callbacks.add(listener, thisArg);
                    var result = {
                        dispose: function () {
                            _this._callbacks.remove(listener, thisArg);
                        }
                    };
                    if (Array.isArray(disposables)) {
                        disposables.push(result);
                    }
                    return result;
                };
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDocumentSaveParticipant.prototype.$participateInSave = function (resource, reason) {
            var _this = this;
            var entries = this._callbacks.entries();
            var didTimeout = false;
            var didTimeoutHandle = setTimeout(function () { return didTimeout = true; }, this._thresholds.timeout);
            var promise = async_1.sequence(entries.map(function (_a) {
                var fn = _a[0], thisArg = _a[1];
                return function () {
                    if (didTimeout) {
                        // timeout - no more listeners
                        return undefined;
                    }
                    var document = _this._documents.getDocumentData(resource).document;
                    return _this._deliverEventAsyncAndBlameBadListeners(fn, thisArg, { document: document, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) });
                };
            }));
            return async_1.always(promise, function () { return clearTimeout(didTimeoutHandle); });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsyncAndBlameBadListeners = function (listener, thisArg, stubEvent) {
            var _this = this;
            var errors = this._badListeners.get(listener);
            if (errors > this._thresholds.errors) {
                // bad listener - ignore
                return winjs_base_1.TPromise.wrap(false);
            }
            return this._deliverEventAsync(listener, thisArg, stubEvent).then(function () {
                // don't send result across the wire
                return true;
            }, function (err) {
                if (!(err instanceof Error) || err.message !== 'concurrent_edits') {
                    var errors_2 = _this._badListeners.get(listener);
                    _this._badListeners.set(listener, !errors_2 ? 1 : errors_2 + 1);
                    // todo@joh signal to the listener?
                    // if (errors === this._thresholds.errors) {
                    // 	console.warn('BAD onWillSaveTextDocumentEvent-listener is from now on being ignored');
                    // }
                }
                return false;
            });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsync = function (listener, thisArg, stubEvent) {
            var _this = this;
            var promises = [];
            var document = stubEvent.document, reason = stubEvent.reason;
            var version = document.version;
            var event = Object.freeze({
                document: document,
                reason: reason,
                waitUntil: function (p) {
                    if (Object.isFrozen(promises)) {
                        throw errors_1.illegalState('waitUntil can not be called async');
                    }
                    promises.push(winjs_base_1.TPromise.wrap(p));
                }
            });
            try {
                // fire event
                listener.apply(thisArg, [event]);
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
            // freeze promises after event call
            Object.freeze(promises);
            return new winjs_base_1.TPromise(function (resolve, reject) {
                // join on all listener promises, reject after timeout
                var handle = setTimeout(function () { return reject(new Error('timeout')); }, _this._thresholds.timeout);
                return async_1.always(winjs_base_1.TPromise.join(promises), function () { return clearTimeout(handle); }).then(resolve, reject);
            }).then(function (values) {
                var edits = [];
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    if (Array.isArray(value) && value.every(function (e) { return e instanceof extHostTypes_1.TextEdit; })) {
                        for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                            var _b = value_1[_a], newText = _b.newText, newEol = _b.newEol, range = _b.range;
                            edits.push({
                                resource: document.uri,
                                range: range && extHostTypeConverters_1.fromRange(range),
                                newText: newText,
                                newEol: extHostTypeConverters_1.EndOfLine.from(newEol)
                            });
                        }
                    }
                }
                // apply edits if any and if document
                // didn't change somehow in the meantime
                if (edits.length === 0) {
                    return undefined;
                }
                if (version === document.version) {
                    return _this._workspace.$applyWorkspaceEdit(edits);
                }
                // TODO@joh bubble this to listener?
                return winjs_base_1.TPromise.wrapError(new Error('concurrent_edits'));
            });
        };
        return ExtHostDocumentSaveParticipant;
    }());
    exports.ExtHostDocumentSaveParticipant = ExtHostDocumentSaveParticipant;
});

define(__m[130/*vs/workbench/api/node/extHostProgress*/], __M([1/*require*/,0/*exports*/,16/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, extHostTypeConverters_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostProgress = (function () {
        function ExtHostProgress(proxy) {
            this._handles = 0;
            this._proxy = proxy;
        }
        ExtHostProgress.prototype.withProgress = function (extension, options, task) {
            var handle = this._handles++;
            var title = options.title, location = options.location;
            this._proxy.$startProgress(handle, { location: extHostTypeConverters_1.ProgressLocation.from(location), title: title, tooltip: extension.name });
            return this._withProgress(handle, task);
        };
        ExtHostProgress.prototype._withProgress = function (handle, task) {
            var _this = this;
            var progress = {
                report: function (p) {
                    _this._proxy.$progressReport(handle, p);
                }
            };
            var p;
            try {
                p = task(progress, null);
            }
            catch (err) {
                this._proxy.$progressEnd(handle);
                throw err;
            }
            p.then(function (result) { return _this._proxy.$progressEnd(handle); }, function (err) { return _this._proxy.$progressEnd(handle); });
            return p;
        };
        return ExtHostProgress;
    }());
    exports.ExtHostProgress = ExtHostProgress;
});

















define(__m[59/*vs/workbench/api/node/extHostTextEditor*/], __M([1/*require*/,0/*exports*/,30/*vs/base/common/assert*/,12/*vs/base/common/errors*/,86/*vs/base/common/idGenerator*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,16/*vs/workbench/api/node/extHostTypeConverters*/,27/*vs/base/common/htmlContent*/]), function (require, exports, assert_1, errors_1, idGenerator_1, winjs_base_1, extHostTypes_1, TypeConverters, htmlContent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorDecorationType = (function () {
        function TextEditorDecorationType(proxy, options) {
            this.key = TextEditorDecorationType._Keys.nextId();
            this._proxy = proxy;
            this._proxy.$registerTextEditorDecorationType(this.key, options);
        }
        TextEditorDecorationType.prototype.dispose = function () {
            this._proxy.$removeTextEditorDecorationType(this.key);
        };
        TextEditorDecorationType._Keys = new idGenerator_1.IdGenerator('TextEditorDecorationType');
        return TextEditorDecorationType;
    }());
    exports.TextEditorDecorationType = TextEditorDecorationType;
    var TextEditorEdit = (function () {
        function TextEditorEdit(document, options) {
            this._document = document;
            this._documentVersionId = document.version;
            this._collectedEdits = [];
            this._setEndOfLine = 0;
            this._undoStopBefore = options.undoStopBefore;
            this._undoStopAfter = options.undoStopAfter;
        }
        TextEditorEdit.prototype.finalize = function () {
            return {
                documentVersionId: this._documentVersionId,
                edits: this._collectedEdits,
                setEndOfLine: this._setEndOfLine,
                undoStopBefore: this._undoStopBefore,
                undoStopAfter: this._undoStopAfter
            };
        };
        TextEditorEdit.prototype.replace = function (location, value) {
            var range = null;
            if (location instanceof extHostTypes_1.Position) {
                range = new extHostTypes_1.Range(location, location);
            }
            else if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, value, false);
        };
        TextEditorEdit.prototype.insert = function (location, value) {
            this._pushEdit(new extHostTypes_1.Range(location, location), value, true);
        };
        TextEditorEdit.prototype.delete = function (location) {
            var range = null;
            if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, null, true);
        };
        TextEditorEdit.prototype._pushEdit = function (range, text, forceMoveMarkers) {
            var validRange = this._document.validateRange(range);
            this._collectedEdits.push({
                range: validRange,
                text: text,
                forceMoveMarkers: forceMoveMarkers
            });
        };
        TextEditorEdit.prototype.setEndOfLine = function (endOfLine) {
            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {
                throw errors_1.illegalArgument('endOfLine');
            }
            this._setEndOfLine = endOfLine;
        };
        return TextEditorEdit;
    }());
    exports.TextEditorEdit = TextEditorEdit;
    function deprecated(name, message) {
        if (message === void 0) { message = 'Refer to the documentation for further details.'; }
        return function (target, key, descriptor) {
            var originalMethod = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn("[Deprecation Warning] method '" + name + "' is deprecated and should no longer be used. " + message);
                return originalMethod.apply(this, args);
            };
            return descriptor;
        };
    }
    var ExtHostTextEditorOptions = (function () {
        function ExtHostTextEditorOptions(proxy, id, source) {
            this._proxy = proxy;
            this._id = id;
            this._accept(source);
        }
        ExtHostTextEditorOptions.prototype._accept = function (source) {
            this._tabSize = source.tabSize;
            this._insertSpaces = source.insertSpaces;
            this._cursorStyle = source.cursorStyle;
            this._lineNumbers = source.lineNumbers;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "tabSize", {
            get: function () {
                return this._tabSize;
            },
            set: function (value) {
                var tabSize = this._validateTabSize(value);
                if (tabSize === null) {
                    // ignore invalid call
                    return;
                }
                if (typeof tabSize === 'number') {
                    if (this._tabSize === tabSize) {
                        // nothing to do
                        return;
                    }
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    tabSize: tabSize
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateTabSize = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            if (typeof value === 'number') {
                var r = Math.floor(value);
                return (r > 0 ? r : null);
            }
            if (typeof value === 'string') {
                var r = parseInt(value, 10);
                if (isNaN(r)) {
                    return null;
                }
                return (r > 0 ? r : null);
            }
            return null;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "insertSpaces", {
            get: function () {
                return this._insertSpaces;
            },
            set: function (value) {
                var insertSpaces = this._validateInsertSpaces(value);
                if (typeof insertSpaces === 'boolean') {
                    if (this._insertSpaces === insertSpaces) {
                        // nothing to do
                        return;
                    }
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    insertSpaces: insertSpaces
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateInsertSpaces = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            return (value === 'false' ? false : Boolean(value));
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "cursorStyle", {
            get: function () {
                return this._cursorStyle;
            },
            set: function (value) {
                if (this._cursorStyle === value) {
                    // nothing to do
                    return;
                }
                this._cursorStyle = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    cursorStyle: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "lineNumbers", {
            get: function () {
                return this._lineNumbers;
            },
            set: function (value) {
                if (this._lineNumbers === value) {
                    // nothing to do
                    return;
                }
                this._lineNumbers = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    lineNumbers: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype.assign = function (newOptions) {
            var bulkConfigurationUpdate = {};
            var hasUpdate = false;
            if (typeof newOptions.tabSize !== 'undefined') {
                var tabSize = this._validateTabSize(newOptions.tabSize);
                if (tabSize === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
                else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
            }
            if (typeof newOptions.insertSpaces !== 'undefined') {
                var insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
                if (insertSpaces === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
                else if (this._insertSpaces !== insertSpaces) {
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
            }
            if (typeof newOptions.cursorStyle !== 'undefined') {
                if (this._cursorStyle !== newOptions.cursorStyle) {
                    this._cursorStyle = newOptions.cursorStyle;
                    hasUpdate = true;
                    bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
                }
            }
            if (typeof newOptions.lineNumbers !== 'undefined') {
                if (this._lineNumbers !== newOptions.lineNumbers) {
                    this._lineNumbers = newOptions.lineNumbers;
                    hasUpdate = true;
                    bulkConfigurationUpdate.lineNumbers = newOptions.lineNumbers;
                }
            }
            if (hasUpdate) {
                warnOnError(this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
            }
        };
        return ExtHostTextEditorOptions;
    }());
    exports.ExtHostTextEditorOptions = ExtHostTextEditorOptions;
    var ExtHostTextEditor = (function () {
        function ExtHostTextEditor(proxy, id, document, selections, options, viewColumn) {
            this._disposed = false;
            this._proxy = proxy;
            this._id = id;
            this._documentData = document;
            this._selections = selections;
            this._options = new ExtHostTextEditorOptions(this._proxy, this._id, options);
            this._viewColumn = viewColumn;
        }
        Object.defineProperty(ExtHostTextEditor.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.dispose = function () {
            assert_1.ok(!this._disposed);
            this._disposed = true;
        };
        ExtHostTextEditor.prototype.show = function (column) {
            this._proxy.$tryShowEditor(this._id, TypeConverters.fromViewColumn(column));
        };
        ExtHostTextEditor.prototype.hide = function () {
            this._proxy.$tryHideEditor(this._id);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "document", {
            // ---- the document
            get: function () {
                return this._documentData.document;
            },
            set: function (value) {
                throw errors_1.readonly('document');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "options", {
            // ---- options
            get: function () {
                return this._options;
            },
            set: function (value) {
                if (!this._disposed) {
                    this._options.assign(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptOptions = function (options) {
            assert_1.ok(!this._disposed);
            this._options._accept(options);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "viewColumn", {
            // ---- view column
            get: function () {
                return this._viewColumn;
            },
            set: function (value) {
                throw errors_1.readonly('viewColumn');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptViewColumn = function (value) {
            assert_1.ok(!this._disposed);
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "selection", {
            // ---- selections
            get: function () {
                return this._selections && this._selections[0];
            },
            set: function (value) {
                if (!(value instanceof extHostTypes_1.Selection)) {
                    throw errors_1.illegalArgument('selection');
                }
                this._selections = [value];
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "selections", {
            get: function () {
                return this._selections;
            },
            set: function (value) {
                if (!Array.isArray(value) || value.some(function (a) { return !(a instanceof extHostTypes_1.Selection); })) {
                    throw errors_1.illegalArgument('selections');
                }
                this._selections = value;
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.setDecorations = function (decorationType, ranges) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy.$trySetDecorations(_this._id, decorationType.key, TypeConverters.fromRangeOrRangeWithMessage(ranges)); });
        };
        ExtHostTextEditor.prototype.revealRange = function (range, revealType) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy.$tryRevealRange(_this._id, TypeConverters.fromRange(range), (revealType || extHostTypes_1.TextEditorRevealType.Default)); });
        };
        ExtHostTextEditor.prototype._trySetSelection = function () {
            var _this = this;
            var selection = this._selections.map(TypeConverters.fromSelection);
            return this._runOnProxy(function () { return _this._proxy.$trySetSelections(_this._id, selection); });
        };
        ExtHostTextEditor.prototype._acceptSelections = function (selections) {
            assert_1.ok(!this._disposed);
            this._selections = selections;
        };
        // ---- editing
        ExtHostTextEditor.prototype.edit = function (callback, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return winjs_base_1.TPromise.wrapError(new Error('TextEditor#edit not possible on closed editors'));
            }
            var edit = new TextEditorEdit(this._documentData.document, options);
            callback(edit);
            return this._applyEdit(edit);
        };
        ExtHostTextEditor.prototype._applyEdit = function (editBuilder) {
            var editData = editBuilder.finalize();
            // check that the edits are not overlapping (i.e. illegal)
            var editRanges = editData.edits.map(function (edit) { return edit.range; });
            // sort ascending (by end and then by start)
            editRanges.sort(function (a, b) {
                if (a.end.line === b.end.line) {
                    if (a.end.character === b.end.character) {
                        if (a.start.line === b.start.line) {
                            return a.start.character - b.start.character;
                        }
                        return a.start.line - b.start.line;
                    }
                    return a.end.character - b.end.character;
                }
                return a.end.line - b.end.line;
            });
            // check that no edits are overlapping
            for (var i = 0, count = editRanges.length - 1; i < count; i++) {
                var rangeEnd = editRanges[i].end;
                var nextRangeStart = editRanges[i + 1].start;
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    return winjs_base_1.TPromise.wrapError(new Error('Overlapping ranges are not allowed!'));
                }
            }
            // prepare data for serialization
            var edits = editData.edits.map(function (edit) {
                return {
                    range: TypeConverters.fromRange(edit.range),
                    text: edit.text,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this._proxy.$tryApplyEdits(this._id, editData.documentVersionId, edits, {
                setEndOfLine: editData.setEndOfLine,
                undoStopBefore: editData.undoStopBefore,
                undoStopAfter: editData.undoStopAfter
            });
        };
        ExtHostTextEditor.prototype.insertSnippet = function (snippet, where, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return winjs_base_1.TPromise.wrapError(new Error('TextEditor#insertSnippet not possible on closed editors'));
            }
            var ranges;
            if (!where || (Array.isArray(where) && where.length === 0)) {
                ranges = this._selections.map(TypeConverters.fromRange);
            }
            else if (where instanceof extHostTypes_1.Position) {
                var _a = TypeConverters.fromPosition(where), lineNumber = _a.lineNumber, column = _a.column;
                ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
            }
            else if (where instanceof extHostTypes_1.Range) {
                ranges = [TypeConverters.fromRange(where)];
            }
            else {
                ranges = [];
                for (var _i = 0, where_1 = where; _i < where_1.length; _i++) {
                    var posOrRange = where_1[_i];
                    if (posOrRange instanceof extHostTypes_1.Range) {
                        ranges.push(TypeConverters.fromRange(posOrRange));
                    }
                    else {
                        var _b = TypeConverters.fromPosition(posOrRange), lineNumber = _b.lineNumber, column = _b.column;
                        ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                    }
                }
            }
            return this._proxy.$tryInsertSnippet(this._id, snippet.value, ranges, options);
        };
        // ---- util
        ExtHostTextEditor.prototype._runOnProxy = function (callback) {
            var _this = this;
            if (this._disposed) {
                console.warn('TextEditor is closed/disposed');
                return winjs_base_1.TPromise.as(undefined);
            }
            return callback().then(function () { return _this; }, function (err) {
                if (!(err instanceof Error && err.name === 'DISPOSED')) {
                    console.warn(err);
                }
                return null;
            });
        };
        __decorate([
            deprecated('TextEditor.show')
        ], ExtHostTextEditor.prototype, "show", null);
        __decorate([
            deprecated('TextEditor.hide')
        ], ExtHostTextEditor.prototype, "hide", null);
        return ExtHostTextEditor;
    }());
    exports.ExtHostTextEditor = ExtHostTextEditor;
    var ExtHostTextEditor2 = (function (_super) {
        __extends(ExtHostTextEditor2, _super);
        function ExtHostTextEditor2(_extHostExtensions, _mainThreadTelemetry, proxy, id, document, selections, options, viewColumn) {
            var _this = _super.call(this, proxy, id, document, selections, options, viewColumn) || this;
            _this._extHostExtensions = _extHostExtensions;
            _this._mainThreadTelemetry = _mainThreadTelemetry;
            return _this;
        }
        ExtHostTextEditor2.prototype.setDecorations = function (decorationType, rangesOrOptions) {
            var _this = this;
            // (1) find out if this decoration is important for us
            var usesCommandLink = false;
            outer: for (var _i = 0, rangesOrOptions_1 = rangesOrOptions; _i < rangesOrOptions_1.length; _i++) {
                var rangeOrOption = rangesOrOptions_1[_i];
                if (extHostTypes_1.Range.isRange(rangeOrOption)) {
                    break;
                }
                if (typeof rangeOrOption.hoverMessage === 'string' && htmlContent_1.containsCommandLink(rangeOrOption.hoverMessage)) {
                    usesCommandLink = true;
                    break;
                }
                else if (Array.isArray(rangeOrOption.hoverMessage)) {
                    for (var _a = 0, _b = rangeOrOption.hoverMessage; _a < _b.length; _a++) {
                        var message = _b[_a];
                        if (typeof message === 'string' && htmlContent_1.containsCommandLink(message)) {
                            usesCommandLink = true;
                            break outer;
                        }
                    }
                }
            }
            // (2) send event for important decorations
            if (usesCommandLink) {
                var tag_1 = new Error();
                this._extHostExtensions.getExtensionPathIndex().then(function (index) {
                    var oldHandler = Error.prepareStackTrace;
                    Error.prepareStackTrace = function (error, stackTrace) {
                        for (var _i = 0, stackTrace_1 = stackTrace; _i < stackTrace_1.length; _i++) {
                            var call = stackTrace_1[_i];
                            var extension = index.findSubstr(call.getFileName());
                            if (extension) {
                                _this._mainThreadTelemetry.$publicLog('usesCommandLink', {
                                    extension: extension.id,
                                    from: 'decoration',
                                });
                                return;
                            }
                        }
                    };
                    // it all happens here...
                    // tslint:disable-next-line:no-unused-expression
                    tag_1.stack;
                    Error.prepareStackTrace = oldHandler;
                });
            }
            // (3) do it
            _super.prototype.setDecorations.call(this, decorationType, rangesOrOptions);
        };
        return ExtHostTextEditor2;
    }(ExtHostTextEditor));
    exports.ExtHostTextEditor2 = ExtHostTextEditor2;
    function warnOnError(promise) {
        promise.then(null, function (err) {
            console.warn(err);
        });
    }
});




















define(__m[132/*vs/workbench/common/editor/untitledEditorModel*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,116/*vs/workbench/common/editor/textEditorModel*/,39/*vs/editor/common/modes/modesRegistry*/,23/*vs/editor/common/editorCommon*/,96/*vs/platform/files/common/files*/,26/*vs/platform/configuration/common/configuration*/,45/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/,3/*vs/base/common/event*/,10/*vs/base/common/async*/,118/*vs/workbench/services/backup/common/backup*/,37/*vs/workbench/services/textfile/common/textfiles*/]), function (require, exports, winjs_base_1, textEditorModel_1, modesRegistry_1, editorCommon_1, files_1, configuration_1, modeService_1, modelService_1, event_1, async_1, backup_1, textfiles_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var UntitledEditorModel = (function (_super) {
        __extends(UntitledEditorModel, _super);
        function UntitledEditorModel(modeId, resource, hasAssociatedFilePath, initialValue, preferredEncoding, modeService, modelService, backupFileService, textFileService, configurationService) {
            var _this = _super.call(this, modelService, modeService) || this;
            _this.modeId = modeId;
            _this.resource = resource;
            _this.hasAssociatedFilePath = hasAssociatedFilePath;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.backupFileService = backupFileService;
            _this.textFileService = textFileService;
            _this.configurationService = configurationService;
            _this.dirty = false;
            _this.versionId = 0;
            _this._onDidChangeContent = new event_1.Emitter();
            _this._onDidChangeDirty = new event_1.Emitter();
            _this._onDidChangeEncoding = new event_1.Emitter();
            _this.contentChangeEventScheduler = new async_1.RunOnceScheduler(function () { return _this._onDidChangeContent.fire(); }, UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY);
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeContent", {
            get: function () {
                return this._onDidChangeContent.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeDirty", {
            get: function () {
                return this._onDidChangeDirty.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeEncoding", {
            get: function () {
                return this._onDidChangeEncoding.event;
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            if (!modeId || modeId === modesRegistry_1.PLAINTEXT_MODE_ID) {
                return modeService.getOrCreateModeByFilenameOrFirstLine(this.resource.fsPath, firstLineText); // lookup mode via resource path if the provided modeId is unspecific
            }
            return _super.prototype.getOrCreateMode.call(this, modeService, modeId, firstLineText);
        };
        UntitledEditorModel.prototype.registerListeners = function () {
            var _this = this;
            // Config Changes
            this.configurationChangeListener = this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationChange(_this.configurationService.getConfiguration()); });
        };
        UntitledEditorModel.prototype.onConfigurationChange = function (configuration) {
            this.configuredEncoding = configuration && configuration.files && configuration.files.encoding;
        };
        UntitledEditorModel.prototype.getVersionId = function () {
            return this.versionId;
        };
        UntitledEditorModel.prototype.getValue = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getValue(editorCommon_1.EndOfLinePreference.TextDefined, true /* Preserve BOM */);
            }
            return null;
        };
        UntitledEditorModel.prototype.getModeId = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getLanguageIdentifier().language;
            }
            return null;
        };
        UntitledEditorModel.prototype.getEncoding = function () {
            return this.preferredEncoding || this.configuredEncoding;
        };
        UntitledEditorModel.prototype.setEncoding = function (encoding) {
            var oldEncoding = this.getEncoding();
            this.preferredEncoding = encoding;
            // Emit if it changed
            if (oldEncoding !== this.preferredEncoding) {
                this._onDidChangeEncoding.fire();
            }
        };
        UntitledEditorModel.prototype.isDirty = function () {
            return this.dirty;
        };
        UntitledEditorModel.prototype.setDirty = function (dirty) {
            if (this.dirty === dirty) {
                return;
            }
            this.dirty = dirty;
            this._onDidChangeDirty.fire();
        };
        UntitledEditorModel.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorModel.prototype.revert = function () {
            this.setDirty(false);
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.load = function () {
            var _this = this;
            // Check for backups first
            return this.backupFileService.loadBackupResource(this.resource).then(function (backupResource) {
                if (backupResource) {
                    return _this.textFileService.resolveTextContent(backupResource, backup_1.BACKUP_FILE_RESOLVE_OPTIONS).then(function (rawTextContent) {
                        return _this.backupFileService.parseBackupContent(rawTextContent.value);
                    });
                }
                return null;
            }).then(function (backupContent) {
                // untitled associated to file path are dirty right away as well as untitled with content
                _this.setDirty(_this.hasAssociatedFilePath || !!backupContent);
                return _this.doLoad(backupContent || _this.initialValue || '').then(function (model) {
                    var configuration = _this.configurationService.getConfiguration();
                    // Encoding
                    _this.configuredEncoding = configuration && configuration.files && configuration.files.encoding;
                    // Listen to content changes
                    _this.textModelChangeListener = _this.textEditorModel.onDidChangeContent(function () { return _this.onModelContentChanged(); });
                    return model;
                });
            });
        };
        UntitledEditorModel.prototype.doLoad = function (content) {
            var _this = this;
            // Create text editor model if not yet done
            if (!this.textEditorModel) {
                return this.createTextEditorModel(content, this.resource, this.modeId).then(function (model) { return _this; });
            }
            else {
                this.updateTextEditorModel(content);
            }
            return winjs_base_1.TPromise.as(this);
        };
        UntitledEditorModel.prototype.onModelContentChanged = function () {
            this.versionId++;
            // mark the untitled editor as non-dirty once its content becomes empty and we do
            // not have an associated path set. we never want dirty indicator in that case.
            if (!this.hasAssociatedFilePath && this.textEditorModel.getLineCount() === 1 && this.textEditorModel.getLineContent(1) === '') {
                this.setDirty(false);
            }
            else {
                this.setDirty(true);
            }
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.textModelChangeListener) {
                this.textModelChangeListener.dispose();
                this.textModelChangeListener = null;
            }
            if (this.configurationChangeListener) {
                this.configurationChangeListener.dispose();
                this.configurationChangeListener = null;
            }
            this.contentChangeEventScheduler.dispose();
            this._onDidChangeContent.dispose();
            this._onDidChangeDirty.dispose();
            this._onDidChangeEncoding.dispose();
        };
        UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;
        UntitledEditorModel = __decorate([
            __param(5, modeService_1.IModeService),
            __param(6, modelService_1.IModelService),
            __param(7, backup_1.IBackupFileService),
            __param(8, textfiles_1.ITextFileService),
            __param(9, configuration_1.IConfigurationService)
        ], UntitledEditorModel);
        return UntitledEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.UntitledEditorModel = UntitledEditorModel;
});




















define(__m[133/*vs/workbench/common/editor/untitledEditorInput*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,54/*vs/base/common/mime*/,65/*vs/base/common/labels*/,39/*vs/editor/common/modes/modesRegistry*/,13/*vs/base/common/paths*/,56/*vs/workbench/common/editor*/,132/*vs/workbench/common/editor/untitledEditorModel*/,7/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/workspace/common/workspace*/,17/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/,37/*vs/workbench/services/textfile/common/textfiles*/,106/*vs/platform/telemetry/common/telemetryUtils*/,49/*vs/platform/environment/common/environment*/]), function (require, exports, winjs_base_1, mime_1, labels, modesRegistry_1, paths, editor_1, untitledEditorModel_1, instantiation_1, workspace_1, lifecycle_1, event_1, textfiles_1, telemetryUtils_1, environment_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor input to be used for untitled text buffers.
     */
    var UntitledEditorInput = (function (_super) {
        __extends(UntitledEditorInput, _super);
        function UntitledEditorInput(resource, hasAssociatedFilePath, modeId, initialValue, preferredEncoding, instantiationService, contextService, textFileService, environmentService) {
            var _this = _super.call(this) || this;
            _this.resource = resource;
            _this.modeId = modeId;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.instantiationService = instantiationService;
            _this.contextService = contextService;
            _this.textFileService = textFileService;
            _this.environmentService = environmentService;
            _this._hasAssociatedFilePath = hasAssociatedFilePath;
            _this.toUnbind = [];
            _this._onDidModelChangeContent = new event_1.Emitter();
            _this._onDidModelChangeEncoding = new event_1.Emitter();
            return _this;
        }
        Object.defineProperty(UntitledEditorInput.prototype, "hasAssociatedFilePath", {
            get: function () {
                return this._hasAssociatedFilePath;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeContent", {
            get: function () {
                return this._onDidModelChangeContent.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeEncoding", {
            get: function () {
                return this._onDidModelChangeEncoding.event;
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getTypeId = function () {
            return UntitledEditorInput.ID;
        };
        UntitledEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorInput.prototype.getModeId = function () {
            if (this.cachedModel) {
                return this.cachedModel.getModeId();
            }
            return this.modeId;
        };
        UntitledEditorInput.prototype.getName = function () {
            return this.hasAssociatedFilePath ? paths.basename(this.resource.fsPath) : this.resource.fsPath;
        };
        UntitledEditorInput.prototype.getDescription = function () {
            return this.hasAssociatedFilePath ? labels.getPathLabel(paths.dirname(this.resource.fsPath), this.contextService, this.environmentService) : null;
        };
        UntitledEditorInput.prototype.isDirty = function () {
            if (this.cachedModel) {
                return this.cachedModel.isDirty();
            }
            // A disposed input is never dirty, even if it was restored from backup
            if (this.isDisposed()) {
                return false;
            }
            // untitled files with an associated path or associated resource
            return this.hasAssociatedFilePath;
        };
        UntitledEditorInput.prototype.confirmSave = function () {
            return this.textFileService.confirmSave([this.resource]);
        };
        UntitledEditorInput.prototype.save = function () {
            return this.textFileService.save(this.resource);
        };
        UntitledEditorInput.prototype.revert = function () {
            if (this.cachedModel) {
                this.cachedModel.revert();
            }
            this.dispose(); // a reverted untitled editor is no longer valid, so we dispose it
            return winjs_base_1.TPromise.as(true);
        };
        UntitledEditorInput.prototype.suggestFileName = function () {
            if (!this.hasAssociatedFilePath) {
                if (this.cachedModel) {
                    var modeId = this.cachedModel.getModeId();
                    if (modeId !== modesRegistry_1.PLAINTEXT_MODE_ID) {
                        return mime_1.suggestFilename(modeId, this.getName());
                    }
                }
            }
            return this.getName();
        };
        UntitledEditorInput.prototype.getEncoding = function () {
            if (this.cachedModel) {
                return this.cachedModel.getEncoding();
            }
            return this.preferredEncoding;
        };
        UntitledEditorInput.prototype.setEncoding = function (encoding, mode /* ignored, we only have Encode */) {
            this.preferredEncoding = encoding;
            if (this.cachedModel) {
                this.cachedModel.setEncoding(encoding);
            }
        };
        UntitledEditorInput.prototype.resolve = function () {
            // Join a model resolve if we have had one before
            if (this.modelResolve) {
                return this.modelResolve;
            }
            // Otherwise Create Model and load
            this.cachedModel = this.createModel();
            this.modelResolve = this.cachedModel.load();
            return this.modelResolve;
        };
        UntitledEditorInput.prototype.createModel = function () {
            var _this = this;
            var model = this.instantiationService.createInstance(untitledEditorModel_1.UntitledEditorModel, this.modeId, this.resource, this.hasAssociatedFilePath, this.initialValue, this.preferredEncoding);
            // re-emit some events from the model
            this.toUnbind.push(model.onDidChangeContent(function () { return _this._onDidModelChangeContent.fire(); }));
            this.toUnbind.push(model.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this.toUnbind.push(model.onDidChangeEncoding(function () { return _this._onDidModelChangeEncoding.fire(); }));
            return model;
        };
        UntitledEditorInput.prototype.getTelemetryDescriptor = function () {
            var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
            descriptor['resource'] = telemetryUtils_1.telemetryURIDescriptor(this.getResource());
            return descriptor;
        };
        UntitledEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            // {{SQL CARBON EDIT}}
            var isUntitledInput = otherInput instanceof UntitledEditorInput;
            var isQueryInput = otherInput && otherInput.sql && otherInput.sql instanceof UntitledEditorInput;
            if (isUntitledInput || isQueryInput) {
                var otherUntitledEditorInput = isUntitledInput ? otherInput : otherInput.sql;
                // Otherwise compare by properties
                return otherUntitledEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        UntitledEditorInput.prototype.dispose = function () {
            this._onDidModelChangeContent.dispose();
            this._onDidModelChangeEncoding.dispose();
            // Listeners
            lifecycle_1.dispose(this.toUnbind);
            // Model
            if (this.cachedModel) {
                this.cachedModel.dispose();
                this.cachedModel = null;
            }
            this.modelResolve = void 0;
            _super.prototype.dispose.call(this);
        };
        UntitledEditorInput.ID = 'workbench.editors.untitledEditorInput';
        UntitledEditorInput = __decorate([
            __param(5, instantiation_1.IInstantiationService),
            __param(6, workspace_1.IWorkspaceContextService),
            __param(7, textfiles_1.ITextFileService),
            __param(8, environment_1.IEnvironmentService)
        ], UntitledEditorInput);
        return UntitledEditorInput;
    }(editor_1.EditorInput));
    exports.UntitledEditorInput = UntitledEditorInput;
});

define(__m[60/*vs/workbench/services/thread/common/threadService*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProxyIdentifier = (function () {
        function ProxyIdentifier(isMain, id) {
            this.isMain = isMain;
            this.id = id;
        }
        return ProxyIdentifier;
    }());
    exports.ProxyIdentifier = ProxyIdentifier;
    function createMainContextProxyIdentifier(identifier) {
        return new ProxyIdentifier(true, 'm' + identifier);
    }
    exports.createMainContextProxyIdentifier = createMainContextProxyIdentifier;
    function createExtHostContextProxyIdentifier(identifier) {
        return new ProxyIdentifier(false, 'e' + identifier);
    }
    exports.createExtHostContextProxyIdentifier = createExtHostContextProxyIdentifier;
});

define(__m[22/*sql/workbench/api/node/sqlExtHost.protocol*/], __M([1/*require*/,0/*exports*/,60/*vs/workbench/services/thread/common/threadService*/]), function (require, exports, threadService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostAccountManagementShape = (function () {
        function ExtHostAccountManagementShape() {
        }
        ExtHostAccountManagementShape.prototype.$clear = function (handle, accountKey) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$getSecurityToken = function (handle, account) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$initialize = function (handle, restoredAccounts) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$prompt = function (handle) { throw ni(); };
        ExtHostAccountManagementShape.prototype.$refresh = function (handle, account) { throw ni(); };
        return ExtHostAccountManagementShape;
    }());
    exports.ExtHostAccountManagementShape = ExtHostAccountManagementShape;
    var ExtHostDataProtocolShape = (function () {
        function ExtHostDataProtocolShape() {
        }
        /**
         * Establish a connection to a data source using the provided ConnectionInfo instance.
         */
        ExtHostDataProtocolShape.prototype.$connect = function (handle, connectionUri, connection) { throw ni(); };
        /**
         * Disconnect from a data source using the provided connectionUri string.
         */
        ExtHostDataProtocolShape.prototype.$disconnect = function (handle, connectionUri) { throw ni(); };
        /**
         * Cancel a connection to a data source using the provided connectionUri string.
         */
        ExtHostDataProtocolShape.prototype.$cancelConnect = function (handle, connectionUri) { throw ni(); };
        /**
         * Change the database for the connection.
         */
        ExtHostDataProtocolShape.prototype.$changeDatabase = function (handle, connectionUri, newDatabase) { throw ni(); };
        /**
         * List databases for a data source using the provided connectionUri string.
         * @param handle the handle to use when looking up a provider
         * @param connectionUri URI identifying a connected resource
         */
        ExtHostDataProtocolShape.prototype.$listDatabases = function (handle, connectionUri) { throw ni(); };
        /**
         * Notifies all listeners on the Extension Host side that a language change occurred
         * for a dataprotocol language. The sub-flavor is the specific implementation used for query
         * and other events
         * @param params information on what URI was changed and the new language
         */
        ExtHostDataProtocolShape.prototype.$languageFlavorChanged = function (params) { throw ni(); };
        /**
         * Callback when a connection request has completed
         */
        ExtHostDataProtocolShape.prototype.$onConnectComplete = function (handle, connectionInfoSummary) { throw ni(); };
        /**
         * Callback when a IntelliSense cache has been built
         */
        ExtHostDataProtocolShape.prototype.$onIntelliSenseCacheComplete = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getServerCapabilities = function (handle, client) { throw ni(); };
        /**
         * Metadata service methods
         *
         */
        ExtHostDataProtocolShape.prototype.$getMetadata = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getDatabases = function (handle, connectionUri) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getTableInfo = function (handle, connectionUri, metadata) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$getViewInfo = function (handle, connectionUri, metadata) { throw ni(); };
        /**
         * Object Explorer
         */
        ExtHostDataProtocolShape.prototype.$createObjectExplorerSession = function (handle, connInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$expandObjectExplorerNode = function (handle, nodeInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$refreshObjectExplorerNode = function (handle, nodeInfo) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$closeObjectExplorerSession = function (handle, closeSessionInfo) { throw ni(); };
        /**
         * Tasks
         */
        ExtHostDataProtocolShape.prototype.$getAllTasks = function (handle, listTasksParams) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$cancelTask = function (handle, cancelTaskParams) { throw ni(); };
        /**
         * Scripting methods
         */
        ExtHostDataProtocolShape.prototype.$scriptAsSelect = function (handle, connectionUri, metadata, paramDetails) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$scriptAsCreate = function (handle, connectionUri, metadata, paramDetails) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$scriptAsUpdate = function (handle, connectionUri, metadata, paramDetails) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$scriptAsInsert = function (handle, connectionUri, metadata, paramDetails) { throw ni(); };
        ExtHostDataProtocolShape.prototype.$scriptAsDelete = function (handle, connectionUri, metadata, paramDetails) { throw ni(); };
        /**
         * Cancels the currently running query for a URI
         */
        ExtHostDataProtocolShape.prototype.$cancelQuery = function (handle, ownerUri) { throw ni(); };
        /**
         * Runs a query for a text selection inside a document
         */
        ExtHostDataProtocolShape.prototype.$runQuery = function (handle, ownerUri, selection, runOptions) { throw ni(); };
        /**
         * Runs the current SQL statement query for a text document
         */
        ExtHostDataProtocolShape.prototype.$runQueryStatement = function (handle, ownerUri, line, column) { throw ni(); };
        /**
         * Runs a query for a provided query
         */
        ExtHostDataProtocolShape.prototype.$runQueryString = function (handle, ownerUri, queryString) { throw ni(); };
        /**
         * Runs a query for a provided query and returns result
         */
        ExtHostDataProtocolShape.prototype.$runQueryAndReturn = function (handle, ownerUri, queryString) { throw ni(); };
        /**
         * Gets a subset of rows in a result set in order to display in the UI
         */
        ExtHostDataProtocolShape.prototype.$getQueryRows = function (handle, rowData) { throw ni(); };
        /**
         * Disposes the cached information regarding a query
         */
        ExtHostDataProtocolShape.prototype.$disposeQuery = function (handle, ownerUri) { throw ni(); };
        /**
         * Refreshes the IntelliSense cache
         */
        ExtHostDataProtocolShape.prototype.$rebuildIntelliSenseCache = function (handle, ownerUri) { throw ni(); };
        /**
         * Callback when a query has completed
         */
        ExtHostDataProtocolShape.prototype.$onQueryComplete = function (handle, result) { throw ni(); };
        /**
         * Callback when a batch has started. This enables the UI to display when batch execution has started
         */
        ExtHostDataProtocolShape.prototype.$onBatchStart = function (handle, batchInfo) { throw ni(); };
        /**
         * Callback when a batch is complete. This includes updated information on result sets, time to execute, and
         * other relevant batch information
         */
        ExtHostDataProtocolShape.prototype.$onBatchComplete = function (handle, batchInfo) { throw ni(); };
        /**
         * Callback when a result set has been returned from query execution and can be displayed
         */
        ExtHostDataProtocolShape.prototype.$onResultSetComplete = function (handle, resultSetInfo) { throw ni(); };
        /**
         * Callback when a message generated during query execution is issued
         */
        ExtHostDataProtocolShape.prototype.$onQueryMessage = function (handle, message) { throw ni(); };
        /**
         * Requests saving of the results from a result set into a specific format (CSV, JSON, Excel)
         */
        ExtHostDataProtocolShape.prototype.$saveResults = function (handle, requestParams) { throw ni(); };
        /**
         * Commits all pending edits in an edit session
         */
        ExtHostDataProtocolShape.prototype.$commitEdit = function (handle, ownerUri) { throw ni(); };
        /**
         * Creates a new row in the edit session
         */
        ExtHostDataProtocolShape.prototype.$createRow = function (handle, ownerUri) { throw ni(); };
        /**
         * Marks the selected row for deletion in the edit session
         */
        ExtHostDataProtocolShape.prototype.$deleteRow = function (handle, ownerUri, rowId) { throw ni(); };
        /**
         * Initializes a new edit data session for the requested table/view
         */
        ExtHostDataProtocolShape.prototype.$initializeEdit = function (handle, ownerUri, schemaName, objectName, objectType, rowLimit) { throw ni(); };
        /**
         * Reverts any pending changes for the requested cell and returns the original value
         */
        ExtHostDataProtocolShape.prototype.$revertCell = function (handle, ownerUri, rowId, columnId) { throw ni(); };
        /**
         * Reverts any pending changes for the requested row
         */
        ExtHostDataProtocolShape.prototype.$revertRow = function (handle, ownerUri, rowId) { throw ni(); };
        /**
         * Updates a cell value in the requested row. Returns if there are any corrections to the value
         */
        ExtHostDataProtocolShape.prototype.$updateCell = function (handle, ownerUri, rowId, columId, newValue) { throw ni(); };
        /**
         * Gets a subset of rows in a result set, merging pending edit changes in order to display in the UI
         */
        ExtHostDataProtocolShape.prototype.$getEditRows = function (handle, rowData) { throw ni(); };
        /**
         * Diposes an initialized edit session and cleans up pending edits
         */
        ExtHostDataProtocolShape.prototype.$disposeEdit = function (handle, ownerUri) { throw ni(); };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocolShape.prototype.$createDatabase = function (handle, connectionUri, database) { throw ni(); };
        /**
         * Get the default database prototype
         */
        ExtHostDataProtocolShape.prototype.$getDefaultDatabaseInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Get the database info
         */
        ExtHostDataProtocolShape.prototype.$getDatabaseInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Create a new login on the provided connection
         */
        ExtHostDataProtocolShape.prototype.$createLogin = function (handle, connectionUri, login) { throw ni(); };
        /**
         * Backup a database
         */
        ExtHostDataProtocolShape.prototype.$backup = function (handle, connectionUri, backupInfo, taskExecutionMode) { throw ni(); };
        /**
         * Get the extended database prototype
         */
        ExtHostDataProtocolShape.prototype.$getBackupConfigInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Restores a database
         */
        ExtHostDataProtocolShape.prototype.$restore = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Gets a plan for restoring a database
         */
        ExtHostDataProtocolShape.prototype.$getRestorePlan = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Cancels a plan
         */
        ExtHostDataProtocolShape.prototype.$cancelRestorePlan = function (handle, connectionUri, restoreInfo) { throw ni(); };
        /**
         * Gets restore config Info
         */
        ExtHostDataProtocolShape.prototype.$getRestoreConfigInfo = function (handle, connectionUri) { throw ni(); };
        /**
         * Open a file browser
         */
        ExtHostDataProtocolShape.prototype.$openFileBrowser = function (handle, ownerUri, expandPath, fileFilters, changeFilter) { throw ni(); };
        /**
         * Expand a folder node
         */
        ExtHostDataProtocolShape.prototype.$expandFolderNode = function (handle, ownerUri, expandPath) { throw ni(); };
        /**
         * Validate selected file paths
         */
        ExtHostDataProtocolShape.prototype.$validateFilePaths = function (handle, ownerUri, serviceType, selectedFiles) { throw ni(); };
        /**
         * Close file browser
         */
        ExtHostDataProtocolShape.prototype.$closeFileBrowser = function (handle, ownerUri) { throw ni(); };
        return ExtHostDataProtocolShape;
    }());
    exports.ExtHostDataProtocolShape = ExtHostDataProtocolShape;
    /**
     * ResourceProvider extension host class.
     */
    var ExtHostResourceProviderShape = (function () {
        function ExtHostResourceProviderShape() {
        }
        /**
         * Create a firewall rule
         */
        ExtHostResourceProviderShape.prototype.$createFirewallRule = function (handle, account, firewallRuleInfo) { throw ni(); };
        /**
         * Handle firewall rule
         */
        ExtHostResourceProviderShape.prototype.$handleFirewallRule = function (handle, errorCode, errorMessage, connectionTypeId) { throw ni(); };
        return ExtHostResourceProviderShape;
    }());
    exports.ExtHostResourceProviderShape = ExtHostResourceProviderShape;
    /**
     * Credential Management extension host class.
     */
    var ExtHostCredentialManagementShape = (function () {
        function ExtHostCredentialManagementShape() {
        }
        ExtHostCredentialManagementShape.prototype.$saveCredential = function (credentialId, password) { throw ni(); };
        ExtHostCredentialManagementShape.prototype.$readCredential = function (credentialId) { throw ni(); };
        ExtHostCredentialManagementShape.prototype.$deleteCredential = function (credentialId) { throw ni(); };
        return ExtHostCredentialManagementShape;
    }());
    exports.ExtHostCredentialManagementShape = ExtHostCredentialManagementShape;
    /**
     * Serialization provider extension host class.
     */
    var ExtHostSerializationProviderShape = (function () {
        function ExtHostSerializationProviderShape() {
        }
        ExtHostSerializationProviderShape.prototype.$saveAs = function (saveFormat, savePath, results, appendToFile) { throw ni(); };
        return ExtHostSerializationProviderShape;
    }());
    exports.ExtHostSerializationProviderShape = ExtHostSerializationProviderShape;
    var MainThreadAccountManagementShape = (function () {
        function MainThreadAccountManagementShape() {
        }
        MainThreadAccountManagementShape.prototype.$registerAccountProvider = function (providerMetadata, handle) { throw ni(); };
        MainThreadAccountManagementShape.prototype.$unregisterAccountProvider = function (handle) { throw ni(); };
        MainThreadAccountManagementShape.prototype.$performOAuthAuthorization = function (url, silent) { throw ni(); };
        return MainThreadAccountManagementShape;
    }());
    exports.MainThreadAccountManagementShape = MainThreadAccountManagementShape;
    var MainThreadResourceProviderShape = (function () {
        function MainThreadResourceProviderShape() {
        }
        MainThreadResourceProviderShape.prototype.$registerResourceProvider = function (providerMetadata, handle) { throw ni(); };
        MainThreadResourceProviderShape.prototype.$unregisterResourceProvider = function (handle) { throw ni(); };
        return MainThreadResourceProviderShape;
    }());
    exports.MainThreadResourceProviderShape = MainThreadResourceProviderShape;
    var MainThreadDataProtocolShape = (function () {
        function MainThreadDataProtocolShape() {
        }
        MainThreadDataProtocolShape.prototype.$registerProvider = function (providerId, handle) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$unregisterProvider = function (handle) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onConnectionComplete = function (handle, connectionInfoSummary) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onIntelliSenseCacheComplete = function (handle, connectionUri) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onConnectionChangeNotification = function (handle, changedConnInfo) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onQueryComplete = function (handle, result) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onBatchStart = function (handle, batchInfo) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onBatchComplete = function (handle, batchInfo) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onResultSetComplete = function (handle, resultSetInfo) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onQueryMessage = function (handle, message) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onObjectExplorerSessionCreated = function (handle, message) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onObjectExplorerNodeExpanded = function (handle, message) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onTaskCreated = function (handle, sessionResponse) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onTaskStatusChanged = function (handle, sessionResponse) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onFileBrowserOpened = function (handle, response) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onFolderNodeExpanded = function (handle, response) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onFilePathsValidated = function (handle, response) { throw ni(); };
        MainThreadDataProtocolShape.prototype.$onScriptingComplete = function (handle, message) { throw ni(); };
        /**
         * Callback when a session has completed initialization
         */
        MainThreadDataProtocolShape.prototype.$onEditSessionReady = function (handle, ownerUri, success, message) { throw ni(); };
        return MainThreadDataProtocolShape;
    }());
    exports.MainThreadDataProtocolShape = MainThreadDataProtocolShape;
    var MainThreadCredentialManagementShape = (function () {
        function MainThreadCredentialManagementShape() {
        }
        MainThreadCredentialManagementShape.prototype.$registerCredentialProvider = function (handle) { throw ni(); };
        MainThreadCredentialManagementShape.prototype.$unregisterCredentialProvider = function (handle) { throw ni(); };
        return MainThreadCredentialManagementShape;
    }());
    exports.MainThreadCredentialManagementShape = MainThreadCredentialManagementShape;
    var MainThreadSerializationProviderShape = (function () {
        function MainThreadSerializationProviderShape() {
        }
        MainThreadSerializationProviderShape.prototype.$registerSerializationProvider = function (handle) { throw ni(); };
        MainThreadSerializationProviderShape.prototype.$unregisterSerializationProvider = function (handle) { throw ni(); };
        return MainThreadSerializationProviderShape;
    }());
    exports.MainThreadSerializationProviderShape = MainThreadSerializationProviderShape;
    // export class SqlInstanceCollection {
    // 	private _items: { [id: string]: any; };
    // 	constructor() {
    // 		this._items = Object.create(null);
    // 	}
    // 	public define<T>(id: ProxyIdentifier<T>): InstanceSetter<T> {
    // 		let that = this;
    // 		return new class {
    // 			set<R extends T>(value: T): R {
    // 				that._set(id, value);
    // 				return <R>value;
    // 			}
    // 		};
    // 	}
    // 	_set<T>(id: ProxyIdentifier<T>, value: T): void {
    // 		this._items[id.id] = value;
    // 	}
    // 	public finish(isMain: boolean, threadService: IThreadService): void {
    // 		let expected = (isMain ? SqlMainContext : SqlExtHostContext);
    // 		Object.keys(expected).forEach((key) => {
    // 			let id = expected[key];
    // 			let value = this._items[id.id];
    // 			if (!value) {
    // 				throw new Error(`Missing actor ${key} (isMain: ${id.isMain}, id:  ${id.id})`);
    // 			}
    // 			threadService.set<any>(id, value);
    // 		});
    // 	}
    // }
    function ni() { return new Error('Not implemented'); }
    // --- proxy identifiers
    exports.SqlMainContext = {
        // SQL entries
        MainThreadAccountManagement: threadService_1.createMainContextProxyIdentifier('MainThreadAccountManagement'),
        MainThreadCredentialManagement: threadService_1.createMainContextProxyIdentifier('MainThreadCredentialManagement'),
        MainThreadDataProtocol: threadService_1.createMainContextProxyIdentifier('MainThreadDataProtocol'),
        MainThreadSerializationProvider: threadService_1.createMainContextProxyIdentifier('MainThreadSerializationProvider'),
        MainThreadResourceProvider: threadService_1.createMainContextProxyIdentifier('MainThreadResourceProvider')
    };
    exports.SqlExtHostContext = {
        ExtHostAccountManagement: threadService_1.createExtHostContextProxyIdentifier('ExtHostAccountManagement'),
        ExtHostCredentialManagement: threadService_1.createExtHostContextProxyIdentifier('ExtHostCredentialManagement'),
        ExtHostDataProtocol: threadService_1.createExtHostContextProxyIdentifier('ExtHostDataProtocol'),
        ExtHostSerializationProvider: threadService_1.createExtHostContextProxyIdentifier('ExtHostSerializationProvider'),
        ExtHostResourceProvider: threadService_1.createExtHostContextProxyIdentifier('ExtHostResourceProvider')
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[136/*sql/workbench/api/node/extHostAccountManagement*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, winjs_base_1, extHostTypes_1, sqlExtHost_protocol_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostAccountManagement = (function (_super) {
        __extends(ExtHostAccountManagement, _super);
        function ExtHostAccountManagement(threadService) {
            var _this = _super.call(this) || this;
            _this._handlePool = 0;
            _this._providers = {};
            _this._proxy = threadService.get(sqlExtHost_protocol_1.SqlMainContext.MainThreadAccountManagement);
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        // - MAIN THREAD AVAILABLE METHODS /////////////////////////////////////
        ExtHostAccountManagement.prototype.$clear = function (handle, accountKey) {
            return this._withProvider(handle, function (provider) { return provider.clear(accountKey); });
        };
        ExtHostAccountManagement.prototype.$getSecurityToken = function (handle, account) {
            return this._withProvider(handle, function (provider) { return provider.getSecurityToken(account); });
        };
        ExtHostAccountManagement.prototype.$initialize = function (handle, restoredAccounts) {
            return this._withProvider(handle, function (provider) { return provider.initialize(restoredAccounts); });
        };
        ExtHostAccountManagement.prototype.$prompt = function (handle) {
            return this._withProvider(handle, function (provider) { return provider.prompt(); });
        };
        ExtHostAccountManagement.prototype.$refresh = function (handle, account) {
            return this._withProvider(handle, function (provider) { return provider.refresh(account); });
        };
        // - EXTENSION HOST AVAILABLE METHODS //////////////////////////////////
        ExtHostAccountManagement.prototype.$performOAuthAuthorization = function (url, silent) {
            return this._proxy.$performOAuthAuthorization(url, silent);
        };
        ExtHostAccountManagement.prototype.$registerAccountProvider = function (providerMetadata, provider) {
            var self = this;
            // Look for any account providers that have the same provider ID
            var matchingProviderIndex = Object.values(this._providers).findIndex(function (provider) {
                return provider.metadata.id === providerMetadata.id;
            });
            if (matchingProviderIndex >= 0) {
                throw new Error("Account Provider with ID '" + providerMetadata.id + "' has already been registered");
            }
            // Create the handle for the provider
            var handle = this._nextHandle();
            this._providers[handle] = {
                metadata: providerMetadata,
                provider: provider
            };
            // Register the provider in the main thread via the proxy
            this._proxy.$registerAccountProvider(providerMetadata, handle);
            // Return a disposable to cleanup the provider
            return new extHostTypes_1.Disposable(function () {
                delete self._providers[handle];
                self._proxy.$unregisterAccountProvider(handle);
            });
        };
        /**
         * This method is for testing only, it is not exposed via the shape.
         * @return {number} Number of providers that are currently registered
         */
        ExtHostAccountManagement.prototype.getProviderCount = function () {
            return Object.keys(this._providers).length;
        };
        // PRIVATE METHODS /////////////////////////////////////////////////////
        ExtHostAccountManagement.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostAccountManagement.prototype._withProvider = function (handle, callback) {
            var provider = this._providers[handle];
            if (provider === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error("Provider " + handle + " not found."));
            }
            return callback(provider.provider);
        };
        return ExtHostAccountManagement;
    }(sqlExtHost_protocol_1.ExtHostAccountManagementShape));
    exports.ExtHostAccountManagement = ExtHostAccountManagement;
});











define(__m[137/*sql/workbench/api/node/extHostCredentialManagement*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, winjs_base_1, sqlExtHost_protocol_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CredentialAdapter = (function () {
        function CredentialAdapter(provider) {
            this.provider = provider;
        }
        CredentialAdapter.prototype.saveCredential = function (credentialId, password) {
            return this.provider.saveCredential(credentialId, password);
        };
        CredentialAdapter.prototype.readCredential = function (credentialId) {
            return this.provider.readCredential(credentialId);
        };
        CredentialAdapter.prototype.deleteCredential = function (credentialId) {
            return this.provider.deleteCredential(credentialId);
        };
        return CredentialAdapter;
    }());
    var ExtHostCredentialManagement = (function (_super) {
        __extends(ExtHostCredentialManagement, _super);
        function ExtHostCredentialManagement(threadService) {
            var _this = _super.call(this) || this;
            // MEMBER VARIABLES ////////////////////////////////////////////////////
            _this._adapter = Object.create(null);
            _this._handlePool = 0;
            var self = _this;
            _this._proxy = threadService.get(sqlExtHost_protocol_1.SqlMainContext.MainThreadCredentialManagement);
            // Create a promise to resolve when a credential provider has been registered.
            // HACK: this gives us a deferred promise
            _this._registrationPromise = new Promise(function (resolve) { self._registrationPromiseResolve = resolve; });
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        ExtHostCredentialManagement.prototype.$registerCredentialProvider = function (provider) {
            // Store the credential provider
            provider.handle = this._nextHandle();
            this._adapter[provider.handle] = new CredentialAdapter(provider);
            // Register the credential provider with the main thread
            this._proxy.$registerCredentialProvider(provider.handle);
            // Resolve the credential provider registration promise
            this._registrationPromiseResolve();
            return this._createDisposable(provider.handle);
        };
        ExtHostCredentialManagement.prototype.$getCredentialProvider = function (namespaceId) {
            var self = this;
            if (!namespaceId) {
                return winjs_base_1.TPromise.wrapError(new Error('A namespace must be provided when retrieving a credential provider'));
            }
            // When the registration promise has finished successfully,
            return this._registrationPromise.then(function () {
                return self._withAdapter(0, CredentialAdapter, function (adapter) { return self._createNamespacedCredentialProvider(namespaceId, adapter); });
            });
        };
        ExtHostCredentialManagement.prototype.$saveCredential = function (credentialId, password) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.saveCredential(credentialId, password); });
        };
        ExtHostCredentialManagement.prototype.$readCredential = function (credentialId) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.readCredential(credentialId); });
        };
        ExtHostCredentialManagement.prototype.$deleteCredential = function (credentialId) {
            return this._withAdapter(0, CredentialAdapter, function (adapter) { return adapter.deleteCredential(credentialId); });
        };
        /**
         * Helper method for tests. Not exposed via shape.
         * @return {number} Number of providers registered
         */
        ExtHostCredentialManagement.prototype.getProviderCount = function () {
            return Object.keys(this._adapter).length;
        };
        // PRIVATE HELPERS /////////////////////////////////////////////////////
        ExtHostCredentialManagement._getNamespacedCredentialId = function (namespaceId, credentialId) {
            return namespaceId + "|" + credentialId;
        };
        ExtHostCredentialManagement.prototype._createNamespacedCredentialProvider = function (namespaceId, adapter) {
            // Create a provider that wraps the methods in a namespace
            var provider = {
                handle: adapter.provider.handle,
                deleteCredential: function (credentialId) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.deleteCredential(namespacedId);
                },
                readCredential: function (credentialId) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.readCredential(namespacedId);
                },
                saveCredential: function (credentialId, credential) {
                    var namespacedId = ExtHostCredentialManagement._getNamespacedCredentialId(namespaceId, credentialId);
                    return adapter.provider.saveCredential(namespacedId, credential);
                }
            };
            return Promise.resolve(provider);
        };
        ExtHostCredentialManagement.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                delete _this._adapter[handle];
                _this._proxy.$unregisterCredentialProvider(handle);
            });
        };
        ExtHostCredentialManagement.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostCredentialManagement.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter[handle];
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        return ExtHostCredentialManagement;
    }(sqlExtHost_protocol_1.ExtHostCredentialManagementShape));
    exports.ExtHostCredentialManagement = ExtHostCredentialManagement;
});











define(__m[138/*sql/workbench/api/node/extHostDataProtocol*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, event_1, sqlExtHost_protocol_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDataProtocol = (function (_super) {
        __extends(ExtHostDataProtocol, _super);
        function ExtHostDataProtocol(threadService) {
            var _this = _super.call(this) || this;
            _this._onDidChangeLanguageFlavor = new event_1.Emitter();
            _this.onDidChangeLanguageFlavor = _this._onDidChangeLanguageFlavor.event;
            _this._adapter = new Map();
            _this._proxy = threadService.get(sqlExtHost_protocol_1.SqlMainContext.MainThreadDataProtocol);
            return _this;
        }
        ExtHostDataProtocol.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapter.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostDataProtocol.prototype._nextHandle = function () {
            return ExtHostDataProtocol._handlePool++;
        };
        ExtHostDataProtocol.prototype._runWithProvider = function (handle, action) {
            var provider = this._adapter.get(handle);
            return provider !== undefined
                ? action(provider)
                : undefined;
        };
        ExtHostDataProtocol.prototype.$registerProvider = function (provider) {
            provider.handle = this._nextHandle();
            this._adapter.set(provider.handle, provider);
            this._proxy.$registerProvider(provider.providerId, provider.handle);
            return this._createDisposable(provider.handle);
        };
        // Capabilities Discovery handlers
        ExtHostDataProtocol.prototype.$getServerCapabilities = function (handle, client) {
            return this._runWithProvider(handle, function (provider) {
                return provider.capabilitiesProvider ? provider.capabilitiesProvider.getServerCapabilities(client)
                    : undefined;
            });
        };
        // Connection Management handlers
        ExtHostDataProtocol.prototype.$connect = function (handle, connectionUri, connection) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.connect(connectionUri, connection)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$disconnect = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.disconnect(connectionUri)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$cancelConnect = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.cancelConnect(connectionUri)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$changeDatabase = function (handle, connectionUri, newDatabase) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.changeDatabase(connectionUri, newDatabase)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$listDatabases = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.listDatabases(connectionUri)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$rebuildIntelliSenseCache = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.connectionProvider ? provider.connectionProvider.rebuildIntelliSenseCache(connectionUri)
                    : undefined;
            });
        };
        ExtHostDataProtocol.prototype.$onConnectComplete = function (handle, connectionInfoSummary) {
            this._proxy.$onConnectionComplete(handle, connectionInfoSummary);
        };
        ExtHostDataProtocol.prototype.$onIntelliSenseCacheComplete = function (handle, connectionUri) {
            this._proxy.$onIntelliSenseCacheComplete(handle, connectionUri);
        };
        ExtHostDataProtocol.prototype.$onConnectionChanged = function (handle, changedConnInfo) {
            this._proxy.$onConnectionChangeNotification(handle, changedConnInfo);
        };
        // Protocol-wide Event Handlers
        ExtHostDataProtocol.prototype.$languageFlavorChanged = function (params) {
            this._onDidChangeLanguageFlavor.fire(params);
        };
        // Query Management handlers
        ExtHostDataProtocol.prototype.$cancelQuery = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.cancelQuery(ownerUri);
            });
        };
        ExtHostDataProtocol.prototype.$runQuery = function (handle, ownerUri, selection, runOptions) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.runQuery(ownerUri, selection, runOptions);
            });
        };
        ExtHostDataProtocol.prototype.$runQueryStatement = function (handle, ownerUri, line, column) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.runQueryStatement(ownerUri, line, column);
            });
        };
        ExtHostDataProtocol.prototype.$runQueryString = function (handle, ownerUri, queryString) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.runQueryString(ownerUri, queryString);
            });
        };
        ExtHostDataProtocol.prototype.$runQueryAndReturn = function (handle, ownerUri, queryString) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.runQueryAndReturn(ownerUri, queryString);
            });
        };
        ExtHostDataProtocol.prototype.$getQueryRows = function (handle, rowData) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.getQueryRows(rowData);
            });
        };
        ExtHostDataProtocol.prototype.$disposeQuery = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.disposeQuery(ownerUri);
            });
        };
        ExtHostDataProtocol.prototype.$onQueryComplete = function (handle, result) {
            this._proxy.$onQueryComplete(handle, result);
        };
        ExtHostDataProtocol.prototype.$onBatchStart = function (handle, batchInfo) {
            this._proxy.$onBatchStart(handle, batchInfo);
        };
        ExtHostDataProtocol.prototype.$onBatchComplete = function (handle, batchInfo) {
            this._proxy.$onBatchComplete(handle, batchInfo);
        };
        ExtHostDataProtocol.prototype.$onResultSetComplete = function (handle, resultSetInfo) {
            this._proxy.$onResultSetComplete(handle, resultSetInfo);
        };
        ExtHostDataProtocol.prototype.$onQueryMessage = function (handle, message) {
            this._proxy.$onQueryMessage(handle, message);
        };
        ExtHostDataProtocol.prototype.$saveResults = function (handle, requestParams) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.saveResults(requestParams);
            });
        };
        // Edit Data handlers
        ExtHostDataProtocol.prototype.$commitEdit = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.commitEdit(ownerUri);
            });
        };
        ExtHostDataProtocol.prototype.$createRow = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.createRow(ownerUri);
            });
        };
        ExtHostDataProtocol.prototype.$deleteRow = function (handle, ownerUri, rowId) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.deleteRow(ownerUri, rowId);
            });
        };
        ExtHostDataProtocol.prototype.$disposeEdit = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.disposeEdit(ownerUri);
            });
        };
        ExtHostDataProtocol.prototype.$initializeEdit = function (handle, ownerUri, schemaName, objectName, objectType, rowLimit) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.initializeEdit(ownerUri, schemaName, objectName, objectType, rowLimit);
            });
        };
        ExtHostDataProtocol.prototype.$revertCell = function (handle, ownerUri, rowId, columnId) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.revertCell(ownerUri, rowId, columnId);
            });
        };
        ExtHostDataProtocol.prototype.$revertRow = function (handle, ownerUri, rowId) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.revertRow(ownerUri, rowId);
            });
        };
        ExtHostDataProtocol.prototype.$updateCell = function (handle, ownerUri, rowId, columnId, newValue) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.updateCell(ownerUri, rowId, columnId, newValue);
            });
        };
        ExtHostDataProtocol.prototype.$getEditRows = function (handle, rowData) {
            return this._runWithProvider(handle, function (provider) {
                return provider.queryProvider.getEditRows(rowData);
            });
        };
        ExtHostDataProtocol.prototype.$onEditSessionReady = function (handle, ownerUri, success, message) {
            this._proxy.$onEditSessionReady(handle, ownerUri, success, message);
        };
        // Metadata handlers
        ExtHostDataProtocol.prototype.$getMetadata = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.metadataProvider ? provider.metadataProvider.getMetadata(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        // Object Explorer Service
        ExtHostDataProtocol.prototype.$createObjectExplorerSession = function (handle, connInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.objectExplorerProvider ? provider.objectExplorerProvider.createNewSession(connInfo)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$expandObjectExplorerNode = function (handle, nodeInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.objectExplorerProvider ? provider.objectExplorerProvider.expandNode(nodeInfo)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$refreshObjectExplorerNode = function (handle, nodeInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.objectExplorerProvider ? provider.objectExplorerProvider.refreshNode(nodeInfo)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$closeObjectExplorerSession = function (handle, closeSessionInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.objectExplorerProvider ? provider.objectExplorerProvider.closeSession(closeSessionInfo)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$onObjectExplorerSessionCreated = function (handle, response) {
            this._proxy.$onObjectExplorerSessionCreated(handle, response);
        };
        ExtHostDataProtocol.prototype.$onObjectExplorerNodeExpanded = function (handle, response) {
            this._proxy.$onObjectExplorerNodeExpanded(handle, response);
        };
        // Task Service
        ExtHostDataProtocol.prototype.$getAllTasks = function (handle, listTasksParams) {
            return this._runWithProvider(handle, function (provider) {
                return provider.taskServicesProvider ? provider.taskServicesProvider.getAllTasks(listTasksParams)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$cancelTask = function (handle, cancelTaskParams) {
            return this._runWithProvider(handle, function (provider) {
                return provider.taskServicesProvider ? provider.taskServicesProvider.cancelTask(cancelTaskParams)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$onTaskStatusChanged = function (handle, response) {
            this._proxy.$onTaskStatusChanged(handle, response);
        };
        ExtHostDataProtocol.prototype.$onTaskCreated = function (handle, response) {
            this._proxy.$onTaskCreated(handle, response);
        };
        ExtHostDataProtocol.prototype.$getDatabases = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.metadataProvider ? provider.metadataProvider.getDatabases(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$getTableInfo = function (handle, connectionUri, metadata) {
            return this._runWithProvider(handle, function (provider) {
                return provider.metadataProvider ? provider.metadataProvider.getTableInfo(connectionUri, metadata)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$getViewInfo = function (handle, connectionUri, metadata) {
            return this._runWithProvider(handle, function (provider) {
                return provider.metadataProvider ? provider.metadataProvider.getViewInfo(connectionUri, metadata)
                    : Promise.resolve(undefined);
            });
        };
        // Scripting handlers
        ExtHostDataProtocol.prototype.$scriptAsSelect = function (handle, connectionUri, metadata, paramDetails) {
            return this._runWithProvider(handle, function (provider) {
                return provider.scriptingProvider ? provider.scriptingProvider.scriptAsSelect(connectionUri, metadata, paramDetails)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$scriptAsCreate = function (handle, connectionUri, metadata, paramDetails) {
            return this._runWithProvider(handle, function (provider) {
                return provider.scriptingProvider ? provider.scriptingProvider.scriptAsCreate(connectionUri, metadata, paramDetails)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$scriptAsUpdate = function (handle, connectionUri, metadata, paramDetails) {
            return this._runWithProvider(handle, function (provider) {
                return provider.scriptingProvider ? provider.scriptingProvider.scriptAsUpdate(connectionUri, metadata, paramDetails)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$scriptAsInsert = function (handle, connectionUri, metadata, paramDetails) {
            return this._runWithProvider(handle, function (provider) {
                return provider.scriptingProvider ? provider.scriptingProvider.scriptAsInsert(connectionUri, metadata, paramDetails)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$scriptAsDelete = function (handle, connectionUri, metadata, paramDetails) {
            return this._runWithProvider(handle, function (provider) {
                return provider.scriptingProvider ? provider.scriptingProvider.scriptAsDelete(connectionUri, metadata, paramDetails)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol.prototype.$onScriptingComplete = function (handle, scriptingCompleteResult) {
            this._proxy.$onScriptingComplete(handle, scriptingCompleteResult);
        };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocol.prototype.$createDatabase = function (handle, connectionUri, database) {
            return this._runWithProvider(handle, function (provider) {
                return provider.adminServicesProvider ? provider.adminServicesProvider.createDatabase(connectionUri, database)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Create a new database on the provided connection
         */
        ExtHostDataProtocol.prototype.$getDefaultDatabaseInfo = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.adminServicesProvider ? provider.adminServicesProvider.getDefaultDatabaseInfo(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Get the info on a database
         */
        ExtHostDataProtocol.prototype.$getDatabaseInfo = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.adminServicesProvider ? provider.adminServicesProvider.getDatabaseInfo(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Create a new login on the provided connection
         */
        ExtHostDataProtocol.prototype.$createLogin = function (handle, connectionUri, login) {
            return this._runWithProvider(handle, function (provider) {
                return provider.adminServicesProvider ? provider.adminServicesProvider.createLogin(connectionUri, login)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Backup a database
         */
        ExtHostDataProtocol.prototype.$backup = function (handle, connectionUri, backupInfo, taskExecutionMode) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.backup(connectionUri, backupInfo, taskExecutionMode)
                    : Promise.resolve(undefined);
            });
        };
        /**
        * Create a new database on the provided connection
        */
        ExtHostDataProtocol.prototype.$getBackupConfigInfo = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.getBackupConfigInfo(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Restores a database
         */
        ExtHostDataProtocol.prototype.$restore = function (handle, connectionUri, restoreInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.restore(connectionUri, restoreInfo)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Gets a plan for restoring a database
         */
        ExtHostDataProtocol.prototype.$getRestorePlan = function (handle, connectionUri, restoreInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.getRestorePlan(connectionUri, restoreInfo)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * cancels a restore plan
         */
        ExtHostDataProtocol.prototype.$cancelRestorePlan = function (handle, connectionUri, restoreInfo) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.cancelRestorePlan(connectionUri, restoreInfo)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Gets restore config Info
         */
        ExtHostDataProtocol.prototype.$getRestoreConfigInfo = function (handle, connectionUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.disasterRecoveryProvider ? provider.disasterRecoveryProvider.getRestoreConfigInfo(connectionUri)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Open a file browser
         */
        ExtHostDataProtocol.prototype.$openFileBrowser = function (handle, ownerUri, expandPath, fileFilters, changeFilter) {
            return this._runWithProvider(handle, function (provider) {
                return provider.fileBrowserProvider ? provider.fileBrowserProvider.openFileBrowser(ownerUri, expandPath, fileFilters, changeFilter)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Send event when opening browser is complete
         */
        ExtHostDataProtocol.prototype.$onFileBrowserOpened = function (handle, response) {
            this._proxy.$onFileBrowserOpened(handle, response);
        };
        /**
         * Expand a folder node
         */
        ExtHostDataProtocol.prototype.$expandFolderNode = function (handle, ownerUri, expandPath) {
            return this._runWithProvider(handle, function (provider) {
                return provider.fileBrowserProvider ? provider.fileBrowserProvider.expandFolderNode(ownerUri, expandPath)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Send event when expansion is complete
         */
        ExtHostDataProtocol.prototype.$onFolderNodeExpanded = function (handle, response) {
            this._proxy.$onFolderNodeExpanded(handle, response);
        };
        /**
         * Validate selected file path
         */
        ExtHostDataProtocol.prototype.$validateFilePaths = function (handle, ownerUri, serviceType, selectedFiles) {
            return this._runWithProvider(handle, function (provider) {
                return provider.fileBrowserProvider ? provider.fileBrowserProvider.validateFilePaths(ownerUri, serviceType, selectedFiles)
                    : Promise.resolve(undefined);
            });
        };
        /**
         * Send event when validation is complete
         */
        ExtHostDataProtocol.prototype.$onFilePathsValidated = function (handle, response) {
            this._proxy.$onFilePathsValidated(handle, response);
        };
        /**
         * Close file browser
         */
        ExtHostDataProtocol.prototype.$closeFileBrowser = function (handle, ownerUri) {
            return this._runWithProvider(handle, function (provider) {
                return provider.fileBrowserProvider ? provider.fileBrowserProvider.closeFileBrowser(ownerUri)
                    : Promise.resolve(undefined);
            });
        };
        ExtHostDataProtocol._handlePool = 0;
        return ExtHostDataProtocol;
    }(sqlExtHost_protocol_1.ExtHostDataProtocolShape));
    exports.ExtHostDataProtocol = ExtHostDataProtocol;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










define(__m[139/*sql/workbench/api/node/extHostResourceProvider*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/]), function (require, exports, winjs_base_1, extHostTypes_1, sqlExtHost_protocol_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostResourceProvider = (function (_super) {
        __extends(ExtHostResourceProvider, _super);
        function ExtHostResourceProvider(threadService) {
            var _this = _super.call(this) || this;
            _this._handlePool = 0;
            _this._providers = {};
            _this._proxy = threadService.get(sqlExtHost_protocol_1.SqlMainContext.MainThreadResourceProvider);
            return _this;
        }
        // PUBLIC METHODS //////////////////////////////////////////////////////
        // - MAIN THREAD AVAILABLE METHODS /////////////////////////////////////
        ExtHostResourceProvider.prototype.$createFirewallRule = function (handle, account, firewallRuleInfo) {
            return this._withProvider(handle, function (provider) { return provider.createFirewallRule(account, firewallRuleInfo); });
        };
        ExtHostResourceProvider.prototype.$handleFirewallRule = function (handle, errorCode, errorMessage, connectionTypeId) {
            return this._withProvider(handle, function (provider) { return provider.handleFirewallRule(errorCode, errorMessage, connectionTypeId); });
        };
        // - EXTENSION HOST AVAILABLE METHODS //////////////////////////////////
        ExtHostResourceProvider.prototype.$registerResourceProvider = function (providerMetadata, provider) {
            var self = this;
            // Look for any account providers that have the same provider ID
            var matchingProviderIndex = Object.values(this._providers).findIndex(function (provider) {
                return provider.metadata.id === providerMetadata.id;
            });
            if (matchingProviderIndex >= 0) {
                throw new Error("Resource Provider with ID '" + providerMetadata.id + "' has already been registered");
            }
            // Create the handle for the provider
            var handle = this._nextHandle();
            this._providers[handle] = {
                metadata: providerMetadata,
                provider: provider
            };
            // Register the provider in the main thread via the proxy
            this._proxy.$registerResourceProvider(providerMetadata, handle);
            // Return a disposable to cleanup the provider
            return new extHostTypes_1.Disposable(function () {
                delete self._providers[handle];
                self._proxy.$unregisterResourceProvider(handle);
            });
        };
        /**
         * This method is for testing only, it is not exposed via the shape.
         * @return {number} Number of providers that are currently registered
         */
        ExtHostResourceProvider.prototype.getProviderCount = function () {
            return Object.keys(this._providers).length;
        };
        // PRIVATE METHODS /////////////////////////////////////////////////////
        ExtHostResourceProvider.prototype._nextHandle = function () {
            return this._handlePool++;
        };
        ExtHostResourceProvider.prototype._withProvider = function (handle, callback) {
            var provider = this._providers[handle];
            if (provider === undefined) {
                return winjs_base_1.TPromise.wrapError(new Error("Provider " + handle + " not found."));
            }
            return callback(provider.provider);
        };
        return ExtHostResourceProvider;
    }(sqlExtHost_protocol_1.ExtHostResourceProviderShape));
    exports.ExtHostResourceProvider = ExtHostResourceProvider;
});











define(__m[140/*sql/workbench/api/node/extHostSerializationProvider*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, winjs_base_1, sqlExtHost_protocol_1, extHostTypes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SerializationAdapter = (function () {
        function SerializationAdapter(provider) {
            this._provider = provider;
        }
        SerializationAdapter.prototype.saveAs = function (saveFormat, savePath, results, appendToFile) {
            return this._provider.saveAs(saveFormat, savePath, results, appendToFile);
        };
        return SerializationAdapter;
    }());
    var ExtHostSerializationProvider = (function (_super) {
        __extends(ExtHostSerializationProvider, _super);
        function ExtHostSerializationProvider(threadService) {
            var _this = _super.call(this) || this;
            _this._adapter = Object.create(null);
            _this._proxy = threadService.get(sqlExtHost_protocol_1.SqlMainContext.MainThreadSerializationProvider);
            return _this;
        }
        ExtHostSerializationProvider.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                delete _this._adapter[handle];
                _this._proxy.$unregisterSerializationProvider(handle);
            });
        };
        ExtHostSerializationProvider.prototype._nextHandle = function () {
            return ExtHostSerializationProvider._handlePool++;
        };
        ExtHostSerializationProvider.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter[handle];
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        ExtHostSerializationProvider.prototype.$registerSerializationProvider = function (provider) {
            provider.handle = this._nextHandle();
            this._adapter[provider.handle] = new SerializationAdapter(provider);
            this._proxy.$registerSerializationProvider(provider.handle);
            return this._createDisposable(provider.handle);
        };
        ExtHostSerializationProvider.prototype.$saveAs = function (saveFormat, savePath, results, appendToFile) {
            return this._withAdapter(0, SerializationAdapter, function (adapter) { return adapter.saveAs(saveFormat, savePath, results, appendToFile); });
        };
        ExtHostSerializationProvider._handlePool = 0;
        return ExtHostSerializationProvider;
    }(sqlExtHost_protocol_1.ExtHostSerializationProviderShape));
    exports.ExtHostSerializationProvider = ExtHostSerializationProvider;
});

define(__m[4/*vs/workbench/api/node/extHost.protocol*/], __M([1/*require*/,0/*exports*/,60/*vs/workbench/services/thread/common/threadService*/]), function (require, exports, threadService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var ObjectIdentifier;
    (function (ObjectIdentifier) {
        ObjectIdentifier.name = '$ident';
        function mixin(obj, id) {
            Object.defineProperty(obj, ObjectIdentifier.name, { value: id, enumerable: true });
            return obj;
        }
        ObjectIdentifier.mixin = mixin;
        function of(obj) {
            return obj[ObjectIdentifier.name];
        }
        ObjectIdentifier.of = of;
    })(ObjectIdentifier = exports.ObjectIdentifier || (exports.ObjectIdentifier = {}));
    // --- proxy identifiers
    exports.MainContext = {
        MainThreadCommands: threadService_1.createMainContextProxyIdentifier('MainThreadCommands'),
        MainThreadConfiguration: threadService_1.createMainContextProxyIdentifier('MainThreadConfiguration'),
        // {{SQL CARBON EDIT}}
        // MainThreadDebugService: createMainId<MainThreadDebugServiceShape>('MainThreadDebugService'),
        MainThreadDiagnostics: threadService_1.createMainContextProxyIdentifier('MainThreadDiagnostics'),
        MainThreadDialogs: threadService_1.createMainContextProxyIdentifier('MainThreadDiaglogs'),
        MainThreadDocuments: threadService_1.createMainContextProxyIdentifier('MainThreadDocuments'),
        MainThreadDocumentContentProviders: threadService_1.createMainContextProxyIdentifier('MainThreadDocumentContentProviders'),
        MainThreadEditors: threadService_1.createMainContextProxyIdentifier('MainThreadEditors'),
        MainThreadErrors: threadService_1.createMainContextProxyIdentifier('MainThreadErrors'),
        MainThreadTreeViews: threadService_1.createMainContextProxyIdentifier('MainThreadTreeViews'),
        MainThreadLanguageFeatures: threadService_1.createMainContextProxyIdentifier('MainThreadLanguageFeatures'),
        MainThreadLanguages: threadService_1.createMainContextProxyIdentifier('MainThreadLanguages'),
        MainThreadMessageService: threadService_1.createMainContextProxyIdentifier('MainThreadMessageService'),
        MainThreadOutputService: threadService_1.createMainContextProxyIdentifier('MainThreadOutputService'),
        MainThreadProgress: threadService_1.createMainContextProxyIdentifier('MainThreadProgress'),
        MainThreadQuickOpen: threadService_1.createMainContextProxyIdentifier('MainThreadQuickOpen'),
        MainThreadStatusBar: threadService_1.createMainContextProxyIdentifier('MainThreadStatusBar'),
        MainThreadStorage: threadService_1.createMainContextProxyIdentifier('MainThreadStorage'),
        MainThreadTelemetry: threadService_1.createMainContextProxyIdentifier('MainThreadTelemetry'),
        MainThreadTerminalService: threadService_1.createMainContextProxyIdentifier('MainThreadTerminalService'),
        MainThreadWorkspace: threadService_1.createMainContextProxyIdentifier('MainThreadWorkspace'),
        MainThreadExtensionService: threadService_1.createMainContextProxyIdentifier('MainThreadExtensionService'),
        MainThreadSCM: threadService_1.createMainContextProxyIdentifier('MainThreadSCM'),
        MainThreadTask: threadService_1.createMainContextProxyIdentifier('MainThreadTask'),
        MainThreadCredentials: threadService_1.createMainContextProxyIdentifier('MainThreadCredentials'),
        MainThreadWindow: threadService_1.createMainContextProxyIdentifier('MainThreadWindow'),
    };
    exports.ExtHostContext = {
        ExtHostCommands: threadService_1.createExtHostContextProxyIdentifier('ExtHostCommands'),
        ExtHostConfiguration: threadService_1.createExtHostContextProxyIdentifier('ExtHostConfiguration'),
        ExtHostDiagnostics: threadService_1.createExtHostContextProxyIdentifier('ExtHostDiagnostics'),
        // {{SQL CARBON EDIT}}
        // ExtHostDebugService: createExtId<ExtHostDebugServiceShape>('ExtHostDebugService'),
        ExtHostDocumentsAndEditors: threadService_1.createExtHostContextProxyIdentifier('ExtHostDocumentsAndEditors'),
        ExtHostDocuments: threadService_1.createExtHostContextProxyIdentifier('ExtHostDocuments'),
        ExtHostDocumentContentProviders: threadService_1.createExtHostContextProxyIdentifier('ExtHostDocumentContentProviders'),
        ExtHostDocumentSaveParticipant: threadService_1.createExtHostContextProxyIdentifier('ExtHostDocumentSaveParticipant'),
        ExtHostEditors: threadService_1.createExtHostContextProxyIdentifier('ExtHostEditors'),
        ExtHostTreeViews: threadService_1.createExtHostContextProxyIdentifier('ExtHostTreeViews'),
        ExtHostFileSystemEventService: threadService_1.createExtHostContextProxyIdentifier('ExtHostFileSystemEventService'),
        ExtHostHeapService: threadService_1.createExtHostContextProxyIdentifier('ExtHostHeapMonitor'),
        ExtHostLanguageFeatures: threadService_1.createExtHostContextProxyIdentifier('ExtHostLanguageFeatures'),
        ExtHostQuickOpen: threadService_1.createExtHostContextProxyIdentifier('ExtHostQuickOpen'),
        ExtHostExtensionService: threadService_1.createExtHostContextProxyIdentifier('ExtHostExtensionService'),
        ExtHostTerminalService: threadService_1.createExtHostContextProxyIdentifier('ExtHostTerminalService'),
        ExtHostSCM: threadService_1.createExtHostContextProxyIdentifier('ExtHostSCM'),
        ExtHostTask: threadService_1.createExtHostContextProxyIdentifier('ExtHostTask'),
        ExtHostWorkspace: threadService_1.createExtHostContextProxyIdentifier('ExtHostWorkspace'),
        ExtHostCredentials: threadService_1.createExtHostContextProxyIdentifier('ExtHostCredentials'),
        ExtHostWindow: threadService_1.createExtHostContextProxyIdentifier('ExtHostWindow'),
    };
});

define(__m[142/*vs/workbench/api/node/extHostCommands*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/,2/*vs/base/common/winjs.base*/,5/*vs/workbench/api/node/extHostTypes*/,16/*vs/workbench/api/node/extHostTypeConverters*/,11/*vs/base/common/objects*/,4/*vs/workbench/api/node/extHost.protocol*/,15/*vs/base/common/arrays*/]), function (require, exports, types_1, winjs_base_1, extHostTypes, extHostTypeConverter, objects_1, extHost_protocol_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostCommands = (function () {
        function ExtHostCommands(mainContext, heapService) {
            this._commands = new Map();
            this._argumentProcessors = [];
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadCommands);
            this._converter = new CommandsConverter(this, heapService);
        }
        Object.defineProperty(ExtHostCommands.prototype, "converter", {
            get: function () {
                return this._converter;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostCommands.prototype.registerArgumentProcessor = function (processor) {
            this._argumentProcessors.push(processor);
        };
        ExtHostCommands.prototype.registerCommand = function (id, callback, thisArg, description) {
            var _this = this;
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this._commands.has(id)) {
                throw new Error("command '" + id + "' already exists");
            }
            this._commands.set(id, { callback: callback, thisArg: thisArg, description: description });
            this._proxy.$registerCommand(id);
            return new extHostTypes.Disposable(function () {
                if (_this._commands.delete(id)) {
                    _this._proxy.$unregisterCommand(id);
                }
            });
        };
        ExtHostCommands.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this._commands.has(id)) {
                // we stay inside the extension host and support
                // to pass any kind of parameters around
                return this.$executeContributedCommand.apply(this, [id].concat(args));
            }
            else {
                // automagically convert some argument types
                args = objects_1.cloneAndChange(args, function (value) {
                    if (value instanceof extHostTypes.Position) {
                        return extHostTypeConverter.fromPosition(value);
                    }
                    if (value instanceof extHostTypes.Range) {
                        return extHostTypeConverter.fromRange(value);
                    }
                    if (value instanceof extHostTypes.Location) {
                        return extHostTypeConverter.location.from(value);
                    }
                    if (!Array.isArray(value)) {
                        return value;
                    }
                });
                return this._proxy.$executeCommand(id, args);
            }
        };
        ExtHostCommands.prototype.$executeContributedCommand = function (id) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var command = this._commands.get(id);
            if (!command) {
                return winjs_base_1.TPromise.wrapError(new Error("Contributed command '" + id + "' does not exist."));
            }
            var callback = command.callback, thisArg = command.thisArg, description = command.description;
            if (description) {
                for (var i = 0; i < description.args.length; i++) {
                    try {
                        types_1.validateConstraint(args[i], description.args[i].constraint);
                    }
                    catch (err) {
                        return winjs_base_1.TPromise.wrapError(new Error("Running the contributed command:'" + id + "' failed. Illegal argument '" + description.args[i].name + "' - " + description.args[i].description));
                    }
                }
            }
            args = args.map(function (arg) { return _this._argumentProcessors.reduce(function (r, p) { return p.processArgument(r); }, arg); });
            try {
                var result = callback.apply(thisArg, args);
                return winjs_base_1.TPromise.as(result);
            }
            catch (err) {
                // console.log(err);
                // try {
                // 	console.log(toErrorMessage(err));
                // } catch (err) {
                // 	//
                // }
                return winjs_base_1.TPromise.wrapError(new Error("Running the contributed command:'" + id + "' failed."));
            }
        };
        ExtHostCommands.prototype.getCommands = function (filterUnderscoreCommands) {
            if (filterUnderscoreCommands === void 0) { filterUnderscoreCommands = false; }
            return this._proxy.$getCommands().then(function (result) {
                if (filterUnderscoreCommands) {
                    result = result.filter(function (command) { return command[0] !== '_'; });
                }
                return result;
            });
        };
        ExtHostCommands.prototype.$getContributedCommandHandlerDescriptions = function () {
            var result = Object.create(null);
            this._commands.forEach(function (command, id) {
                var description = command.description;
                if (description) {
                    result[id] = description;
                }
            });
            return winjs_base_1.TPromise.as(result);
        };
        return ExtHostCommands;
    }());
    exports.ExtHostCommands = ExtHostCommands;
    var CommandsConverter = (function () {
        // --- conversion between internal and api commands
        function CommandsConverter(commands, heap) {
            this._commands = commands;
            this._heap = heap;
            this._commands.registerCommand('_internal_command_delegation', this._executeConvertedCommand, this);
        }
        CommandsConverter.prototype.toInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var result = {
                id: command.command,
                title: command.title
            };
            if (command.command && !arrays_1.isFalsyOrEmpty(command.arguments)) {
                // we have a contributed command with arguments. that
                // means we don't want to send the arguments around
                var id = this._heap.keep(command);
                extHost_protocol_1.ObjectIdentifier.mixin(result, id);
                result.id = '_internal_command_delegation';
                result.arguments = [id];
            }
            if (command.tooltip) {
                result.tooltip = command.tooltip;
            }
            return result;
        };
        CommandsConverter.prototype.fromInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(command);
            if (typeof id === 'number') {
                return this._heap.get(id);
            }
            else {
                return {
                    command: command.id,
                    title: command.title,
                    arguments: command.arguments
                };
            }
        };
        CommandsConverter.prototype._executeConvertedCommand = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var actualCmd = this._heap.get(args[0]);
            return (_a = this._commands).executeCommand.apply(_a, [actualCmd.command].concat(actualCmd.arguments));
            var _a;
        };
        return CommandsConverter;
    }());
    exports.CommandsConverter = CommandsConverter;
});

define(__m[143/*vs/workbench/api/node/extHostCredentials*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostCredentials = (function () {
        function ExtHostCredentials(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadCredentials);
        }
        ;
        ExtHostCredentials.prototype.readSecret = function (service, account) {
            return this._proxy.$readSecret(service, account);
        };
        ExtHostCredentials.prototype.writeSecret = function (service, account, secret) {
            return this._proxy.$writeSecret(service, account, secret);
        };
        ExtHostCredentials.prototype.deleteSecret = function (service, account) {
            return this._proxy.$deleteSecret(service, account);
        };
        return ExtHostCredentials;
    }());
    exports.ExtHostCredentials = ExtHostCredentials;
});











define(__m[144/*vs/workbench/api/node/extHostDiagnostics*/], __M([1/*require*/,0/*exports*/,84/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/,6/*vs/base/common/uri*/,25/*vs/base/common/severity*/,4/*vs/workbench/api/node/extHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/,15/*vs/base/common/arrays*/]), function (require, exports, nls_1, uri_1, severity_1, extHost_protocol_1, extHostTypes_1, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiagnosticCollection = (function () {
        function DiagnosticCollection(name, proxy) {
            this._isDisposed = false;
            this._data = new Map();
            this._name = name;
            this._proxy = proxy;
        }
        DiagnosticCollection.prototype.dispose = function () {
            if (!this._isDisposed) {
                this._proxy.$clear(this.name);
                this._proxy = undefined;
                this._data = undefined;
                this._isDisposed = true;
            }
        };
        Object.defineProperty(DiagnosticCollection.prototype, "name", {
            get: function () {
                this._checkDisposed();
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        DiagnosticCollection.prototype.set = function (first, diagnostics) {
            if (!first) {
                // this set-call is a clear-call
                this.clear();
                return;
            }
            // the actual implementation for #set
            this._checkDisposed();
            var toSync;
            if (first instanceof uri_1.default) {
                if (!diagnostics) {
                    // remove this entry
                    this.delete(first);
                    return;
                }
                // update single row
                this._data.set(first.toString(), diagnostics);
                toSync = [first];
            }
            else if (Array.isArray(first)) {
                // update many rows
                toSync = [];
                var lastUri = void 0;
                // ensure stable-sort
                arrays_1.mergeSort(first, DiagnosticCollection._compareIndexedTuplesByUri);
                for (var _i = 0, first_1 = first; _i < first_1.length; _i++) {
                    var tuple = first_1[_i];
                    var uri = tuple[0], diagnostics_1 = tuple[1];
                    if (!lastUri || uri.toString() !== lastUri.toString()) {
                        if (lastUri && this._data.get(lastUri.toString()).length === 0) {
                            this._data.delete(lastUri.toString());
                        }
                        lastUri = uri;
                        toSync.push(uri);
                        this._data.set(uri.toString(), []);
                    }
                    if (!diagnostics_1) {
                        // [Uri, undefined] means clear this
                        this._data.get(uri.toString()).length = 0;
                    }
                    else {
                        (_a = this._data.get(uri.toString())).push.apply(_a, diagnostics_1);
                    }
                }
            }
            // compute change and send to main side
            var entries = [];
            for (var _b = 0, toSync_1 = toSync; _b < toSync_1.length; _b++) {
                var uri = toSync_1[_b];
                var marker = void 0;
                var diagnostics_2 = this._data.get(uri.toString());
                if (diagnostics_2) {
                    // no more than 250 diagnostics per file
                    if (diagnostics_2.length > DiagnosticCollection._maxDiagnosticsPerFile) {
                        marker = [];
                        var order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];
                        orderLoop: for (var i = 0; i < 4; i++) {
                            for (var _c = 0, diagnostics_3 = diagnostics_2; _c < diagnostics_3.length; _c++) {
                                var diagnostic = diagnostics_3[_c];
                                if (diagnostic.severity === order[i]) {
                                    var len = marker.push(DiagnosticCollection._toMarkerData(diagnostic));
                                    if (len === DiagnosticCollection._maxDiagnosticsPerFile) {
                                        break orderLoop;
                                    }
                                }
                            }
                        }
                        // add 'signal' marker for showing omitted errors/warnings
                        marker.push({
                            severity: severity_1.default.Error,
                            message: nls_1.localize(0, null, diagnostics_2.length - DiagnosticCollection._maxDiagnosticsPerFile),
                            startLineNumber: marker[marker.length - 1].startLineNumber,
                            startColumn: marker[marker.length - 1].startColumn,
                            endLineNumber: marker[marker.length - 1].endLineNumber,
                            endColumn: marker[marker.length - 1].endColumn
                        });
                    }
                    else {
                        marker = diagnostics_2.map(DiagnosticCollection._toMarkerData);
                    }
                }
                entries.push([uri, marker]);
            }
            this._proxy.$changeMany(this.name, entries);
            var _a;
        };
        DiagnosticCollection.prototype.delete = function (uri) {
            this._checkDisposed();
            this._data.delete(uri.toString());
            this._proxy.$changeMany(this.name, [[uri, undefined]]);
        };
        DiagnosticCollection.prototype.clear = function () {
            this._checkDisposed();
            this._data.clear();
            this._proxy.$clear(this.name);
        };
        DiagnosticCollection.prototype.forEach = function (callback, thisArg) {
            var _this = this;
            this._checkDisposed();
            this._data.forEach(function (value, key) {
                var uri = uri_1.default.parse(key);
                callback.apply(thisArg, [uri, _this.get(uri), _this]);
            });
        };
        DiagnosticCollection.prototype.get = function (uri) {
            this._checkDisposed();
            var result = this._data.get(uri.toString());
            if (Array.isArray(result)) {
                return Object.freeze(result.slice(0));
            }
            return undefined;
        };
        DiagnosticCollection.prototype.has = function (uri) {
            this._checkDisposed();
            return Array.isArray(this._data.get(uri.toString()));
        };
        DiagnosticCollection.prototype._checkDisposed = function () {
            if (this._isDisposed) {
                throw new Error('illegal state - object is disposed');
            }
        };
        DiagnosticCollection._toMarkerData = function (diagnostic) {
            var range = diagnostic.range;
            return {
                startLineNumber: range.start.line + 1,
                startColumn: range.start.character + 1,
                endLineNumber: range.end.line + 1,
                endColumn: range.end.character + 1,
                message: diagnostic.message,
                source: diagnostic.source,
                severity: DiagnosticCollection._convertDiagnosticsSeverity(diagnostic.severity),
                code: String(diagnostic.code)
            };
        };
        DiagnosticCollection._convertDiagnosticsSeverity = function (severity) {
            switch (severity) {
                case 0: return severity_1.default.Error;
                case 1: return severity_1.default.Warning;
                case 2: return severity_1.default.Info;
                case 3: return severity_1.default.Ignore;
                default: return severity_1.default.Error;
            }
        };
        DiagnosticCollection._compareIndexedTuplesByUri = function (a, b) {
            if (a[0].toString() < b[0].toString()) {
                return -1;
            }
            else if (a[0].toString() > b[0].toString()) {
                return 1;
            }
            else {
                return 0;
            }
        };
        DiagnosticCollection._maxDiagnosticsPerFile = 250;
        return DiagnosticCollection;
    }());
    exports.DiagnosticCollection = DiagnosticCollection;
    var ExtHostDiagnostics = (function () {
        function ExtHostDiagnostics(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadDiagnostics);
            this._collections = [];
        }
        ExtHostDiagnostics.prototype.createDiagnosticCollection = function (name) {
            if (!name) {
                name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
            }
            var _a = this, _collections = _a._collections, _proxy = _a._proxy;
            var result = new (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    var _this = _super.call(this, name, _proxy) || this;
                    _collections.push(_this);
                    return _this;
                }
                class_1.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    var idx = _collections.indexOf(this);
                    if (idx !== -1) {
                        _collections.splice(idx, 1);
                    }
                };
                return class_1;
            }(DiagnosticCollection));
            return result;
        };
        ExtHostDiagnostics.prototype.forEach = function (callback) {
            this._collections.forEach(callback);
        };
        ExtHostDiagnostics._idPool = 0;
        return ExtHostDiagnostics;
    }());
    exports.ExtHostDiagnostics = ExtHostDiagnostics;
});

define(__m[145/*vs/workbench/api/node/extHostDialogs*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, uri_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDialogs = (function () {
        function ExtHostDialogs(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadDialogs);
        }
        ExtHostDialogs.prototype.showOpenDialog = function (options) {
            return this._proxy.$showOpenDialog(options).then(function (filepaths) {
                return filepaths && filepaths.map(uri_1.default.file);
            });
        };
        return ExtHostDialogs;
    }());
    exports.ExtHostDialogs = ExtHostDialogs;
});

define(__m[146/*vs/workbench/api/node/extHostDocumentContentProviders*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/errors*/,23/*vs/editor/common/editorCommon*/,5/*vs/workbench/api/node/extHostTypes*/,2/*vs/base/common/winjs.base*/,10/*vs/base/common/async*/,112/*vs/editor/common/model/textSource*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, errors_1, editorCommon, extHostTypes_1, winjs_base_1, async_1, textSource_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentContentProvider = (function () {
        function ExtHostDocumentContentProvider(mainContext, documentsAndEditors) {
            this._documentContentProviders = new Map();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadDocumentContentProviders);
            this._documentsAndEditors = documentsAndEditors;
        }
        ExtHostDocumentContentProvider.prototype.dispose = function () {
            // todo@joh
        };
        ExtHostDocumentContentProvider.prototype.registerTextDocumentContentProvider = function (scheme, provider) {
            var _this = this;
            if (scheme === 'file' || scheme === 'untitled') {
                throw new Error("scheme '" + scheme + "' already registered");
            }
            var handle = ExtHostDocumentContentProvider._handlePool++;
            this._documentContentProviders.set(handle, provider);
            this._proxy.$registerTextContentProvider(handle, scheme);
            var subscription;
            if (typeof provider.onDidChange === 'function') {
                subscription = provider.onDidChange(function (uri) {
                    if (_this._documentsAndEditors.getDocument(uri.toString())) {
                        _this.$provideTextDocumentContent(handle, uri).then(function (value) {
                            var document = _this._documentsAndEditors.getDocument(uri.toString());
                            if (!document) {
                                // disposed in the meantime
                                return;
                            }
                            // create lines and compare
                            var textSource = textSource_1.TextSource.fromString(value, editorCommon.DefaultEndOfLine.CRLF);
                            // broadcast event when content changed
                            if (!document.equalLines(textSource)) {
                                return _this._proxy.$onVirtualDocumentChange(uri, textSource);
                            }
                        }, errors_1.onUnexpectedError);
                    }
                });
            }
            return new extHostTypes_1.Disposable(function () {
                if (_this._documentContentProviders.delete(handle)) {
                    _this._proxy.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            });
        };
        ExtHostDocumentContentProvider.prototype.$provideTextDocumentContent = function (handle, uri) {
            var provider = this._documentContentProviders.get(handle);
            if (!provider) {
                return winjs_base_1.TPromise.wrapError(new Error("unsupported uri-scheme: " + uri.scheme));
            }
            return async_1.asWinJsPromise(function (token) { return provider.provideTextDocumentContent(uri, token); });
        };
        ExtHostDocumentContentProvider._handlePool = 0;
        return ExtHostDocumentContentProvider;
    }());
    exports.ExtHostDocumentContentProvider = ExtHostDocumentContentProvider;
});

define(__m[147/*vs/workbench/api/node/extHostDocuments*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,17/*vs/base/common/lifecycle*/,16/*vs/workbench/api/node/extHostTypeConverters*/,2/*vs/base/common/winjs.base*/,4/*vs/workbench/api/node/extHost.protocol*/,55/*vs/workbench/api/node/extHostDocumentData*/]), function (require, exports, event_1, lifecycle_1, TypeConverters, winjs_base_1, extHost_protocol_1, extHostDocumentData_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocuments = (function () {
        function ExtHostDocuments(mainContext, documentsAndEditors) {
            var _this = this;
            this._onDidAddDocument = new event_1.Emitter();
            this._onDidRemoveDocument = new event_1.Emitter();
            this._onDidChangeDocument = new event_1.Emitter();
            this._onDidSaveDocument = new event_1.Emitter();
            this.onDidAddDocument = this._onDidAddDocument.event;
            this.onDidRemoveDocument = this._onDidRemoveDocument.event;
            this.onDidChangeDocument = this._onDidChangeDocument.event;
            this.onDidSaveDocument = this._onDidSaveDocument.event;
            this._documentLoader = new Map();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadDocuments);
            this._documentsAndEditors = documentsAndEditors;
            this._toDispose = [
                this._documentsAndEditors.onDidRemoveDocuments(function (documents) {
                    for (var _i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                        var data = documents_1[_i];
                        _this._onDidRemoveDocument.fire(data.document);
                    }
                }),
                this._documentsAndEditors.onDidAddDocuments(function (documents) {
                    for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
                        var data = documents_2[_i];
                        _this._onDidAddDocument.fire(data.document);
                    }
                })
            ];
        }
        ExtHostDocuments.prototype.dispose = function () {
            lifecycle_1.dispose(this._toDispose);
        };
        ExtHostDocuments.prototype.getAllDocumentData = function () {
            return this._documentsAndEditors.allDocuments();
        };
        ExtHostDocuments.prototype.getDocumentData = function (resource) {
            if (!resource) {
                return undefined;
            }
            var data = this._documentsAndEditors.getDocument(resource.toString());
            if (data) {
                return data;
            }
            return undefined;
        };
        ExtHostDocuments.prototype.ensureDocumentData = function (uri) {
            var _this = this;
            var cached = this._documentsAndEditors.getDocument(uri.toString());
            if (cached) {
                return winjs_base_1.TPromise.as(cached);
            }
            var promise = this._documentLoader.get(uri.toString());
            if (!promise) {
                promise = this._proxy.$tryOpenDocument(uri).then(function () {
                    _this._documentLoader.delete(uri.toString());
                    return _this._documentsAndEditors.getDocument(uri.toString());
                }, function (err) {
                    _this._documentLoader.delete(uri.toString());
                    return winjs_base_1.TPromise.wrapError(err);
                });
                this._documentLoader.set(uri.toString(), promise);
            }
            return promise;
        };
        ExtHostDocuments.prototype.createDocumentData = function (options) {
            return this._proxy.$tryCreateDocument(options);
        };
        ExtHostDocuments.prototype.$acceptModelModeChanged = function (strURL, oldModeId, newModeId) {
            var data = this._documentsAndEditors.getDocument(strURL);
            // Treat a mode change as a remove + add
            this._onDidRemoveDocument.fire(data.document);
            data._acceptLanguageId(newModeId);
            this._onDidAddDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptModelSaved = function (strURL) {
            var data = this._documentsAndEditors.getDocument(strURL);
            this.$acceptDirtyStateChanged(strURL, false);
            this._onDidSaveDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptDirtyStateChanged = function (strURL, isDirty) {
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: []
            });
        };
        ExtHostDocuments.prototype.$acceptModelChanged = function (strURL, events, isDirty) {
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            data.onEvents(events);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: events.changes.map(function (change) {
                    return {
                        range: TypeConverters.toRange(change.range),
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            });
        };
        ExtHostDocuments.prototype.setWordDefinitionFor = function (modeId, wordDefinition) {
            extHostDocumentData_1.setWordDefinitionFor(modeId, wordDefinition);
        };
        return ExtHostDocuments;
    }());
    exports.ExtHostDocuments = ExtHostDocuments;
});

define(__m[148/*vs/workbench/api/node/extHostDocumentsAndEditors*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,17/*vs/base/common/lifecycle*/,4/*vs/workbench/api/node/extHost.protocol*/,55/*vs/workbench/api/node/extHostDocumentData*/,59/*vs/workbench/api/node/extHostTextEditor*/,72/*assert*/,16/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, event_1, lifecycle_1, extHost_protocol_1, extHostDocumentData_1, extHostTextEditor_1, assert, typeConverters) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentsAndEditors = (function () {
        function ExtHostDocumentsAndEditors(_mainContext, _extHostExtensions) {
            this._mainContext = _mainContext;
            this._extHostExtensions = _extHostExtensions;
            this._editors = new Map();
            this._documents = new Map();
            this._onDidAddDocuments = new event_1.Emitter();
            this._onDidRemoveDocuments = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this.onDidAddDocuments = this._onDidAddDocuments.event;
            this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        }
        ExtHostDocumentsAndEditors.prototype.$acceptDocumentsAndEditorsDelta = function (delta) {
            var removedDocuments = [];
            var addedDocuments = [];
            var removedEditors = [];
            if (delta.removedDocuments) {
                for (var _i = 0, _a = delta.removedDocuments; _i < _a.length; _i++) {
                    var id = _a[_i];
                    var data = this._documents.get(id);
                    this._documents.delete(id);
                    removedDocuments.push(data);
                }
            }
            if (delta.addedDocuments) {
                for (var _b = 0, _c = delta.addedDocuments; _b < _c.length; _b++) {
                    var data = _c[_b];
                    assert.ok(!this._documents.has(data.url.toString()), "document '" + data.url + " already exists!'");
                    var documentData = new extHostDocumentData_1.ExtHostDocumentData(this._mainContext.get(extHost_protocol_1.MainContext.MainThreadDocuments), data.url, data.lines, data.EOL, data.modeId, data.versionId, data.isDirty);
                    this._documents.set(data.url.toString(), documentData);
                    addedDocuments.push(documentData);
                }
            }
            if (delta.removedEditors) {
                for (var _d = 0, _e = delta.removedEditors; _d < _e.length; _d++) {
                    var id = _e[_d];
                    var editor = this._editors.get(id);
                    this._editors.delete(id);
                    removedEditors.push(editor);
                }
            }
            if (delta.addedEditors) {
                for (var _f = 0, _g = delta.addedEditors; _f < _g.length; _f++) {
                    var data = _g[_f];
                    assert.ok(this._documents.has(data.document.toString()), "document '" + data.document + "' does not exist");
                    assert.ok(!this._editors.has(data.id), "editor '" + data.id + "' already exists!");
                    var documentData = this._documents.get(data.document.toString());
                    var editor = new extHostTextEditor_1.ExtHostTextEditor2(this._extHostExtensions, this._mainContext.get(extHost_protocol_1.MainContext.MainThreadTelemetry), this._mainContext.get(extHost_protocol_1.MainContext.MainThreadEditors), data.id, documentData, data.selections.map(typeConverters.toSelection), data.options, typeConverters.toViewColumn(data.editorPosition));
                    this._editors.set(data.id, editor);
                }
            }
            if (delta.newActiveEditor !== undefined) {
                assert.ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), "active editor '" + delta.newActiveEditor + "' does not exist");
                this._activeEditorId = delta.newActiveEditor;
            }
            lifecycle_1.dispose(removedDocuments);
            lifecycle_1.dispose(removedEditors);
            // now that the internal state is complete, fire events
            if (delta.removedDocuments) {
                this._onDidRemoveDocuments.fire(removedDocuments);
            }
            if (delta.addedDocuments) {
                this._onDidAddDocuments.fire(addedDocuments);
            }
            if (delta.removedEditors || delta.addedEditors) {
                this._onDidChangeVisibleTextEditors.fire(this.allEditors());
            }
            if (delta.newActiveEditor !== undefined) {
                this._onDidChangeActiveTextEditor.fire(this.activeEditor());
            }
        };
        ExtHostDocumentsAndEditors.prototype.getDocument = function (strUrl) {
            return this._documents.get(strUrl);
        };
        ExtHostDocumentsAndEditors.prototype.allDocuments = function () {
            var result = [];
            this._documents.forEach(function (data) { return result.push(data); });
            return result;
        };
        ExtHostDocumentsAndEditors.prototype.getEditor = function (id) {
            return this._editors.get(id);
        };
        ExtHostDocumentsAndEditors.prototype.activeEditor = function () {
            if (!this._activeEditorId) {
                return undefined;
            }
            else {
                return this._editors.get(this._activeEditorId);
            }
        };
        ExtHostDocumentsAndEditors.prototype.allEditors = function () {
            var result = [];
            this._editors.forEach(function (data) { return result.push(data); });
            return result;
        };
        return ExtHostDocumentsAndEditors;
    }());
    exports.ExtHostDocumentsAndEditors = ExtHostDocumentsAndEditors;
});

define(__m[149/*vs/workbench/api/node/extHostLanguageFeatures*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,11/*vs/base/common/objects*/,16/*vs/workbench/api/node/extHostTypeConverters*/,5/*vs/workbench/api/node/extHostTypes*/,10/*vs/base/common/async*/,4/*vs/workbench/api/node/extHost.protocol*/,8/*vs/base/common/strings*/,27/*vs/base/common/htmlContent*/,15/*vs/base/common/arrays*/,33/*vs/base/common/functional*/]), function (require, exports, winjs_base_1, objects_1, TypeConverters, extHostTypes_1, async_1, extHost_protocol_1, strings_1, htmlContent_1, arrays_1, functional_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // --- adapter
    var OutlineAdapter = (function () {
        function OutlineAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        OutlineAdapter.prototype.provideDocumentSymbols = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentSymbols(doc, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.fromSymbolInformation);
                }
                return undefined;
            });
        };
        return OutlineAdapter;
    }());
    var CodeLensAdapter = (function () {
        function CodeLensAdapter(documents, commands, heapService, provider) {
            this._documents = documents;
            this._commands = commands;
            this._heapService = heapService;
            this._provider = provider;
        }
        CodeLensAdapter.prototype.provideCodeLenses = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeLenses(doc, token); }).then(function (lenses) {
                if (Array.isArray(lenses)) {
                    return lenses.map(function (lens) {
                        var id = _this._heapService.keep(lens);
                        return extHost_protocol_1.ObjectIdentifier.mixin({
                            range: TypeConverters.fromRange(lens.range),
                            command: _this._commands.toInternal(lens.command)
                        }, id);
                    });
                }
                return undefined;
            });
        };
        CodeLensAdapter.prototype.resolveCodeLens = function (resource, symbol) {
            var _this = this;
            var lens = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(symbol));
            if (!lens) {
                return undefined;
            }
            var resolve;
            if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
                resolve = winjs_base_1.TPromise.as(lens);
            }
            else {
                resolve = async_1.asWinJsPromise(function (token) { return _this._provider.resolveCodeLens(lens, token); });
            }
            return resolve.then(function (newLens) {
                newLens = newLens || lens;
                symbol.command = _this._commands.toInternal(newLens.command || CodeLensAdapter._badCmd);
                return symbol;
            });
        };
        CodeLensAdapter._badCmd = { command: 'missing', title: '<<MISSING COMMAND>>' };
        return CodeLensAdapter;
    }());
    var DefinitionAdapter = (function () {
        function DefinitionAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        DefinitionAdapter.prototype.provideDefinition = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDefinition(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.location.from);
                }
                else if (value) {
                    return TypeConverters.location.from(value);
                }
                return undefined;
            });
        };
        return DefinitionAdapter;
    }());
    var ImplementationAdapter = (function () {
        function ImplementationAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        ImplementationAdapter.prototype.provideImplementation = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideImplementation(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.location.from);
                }
                else if (value) {
                    return TypeConverters.location.from(value);
                }
                return undefined;
            });
        };
        return ImplementationAdapter;
    }());
    var TypeDefinitionAdapter = (function () {
        function TypeDefinitionAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        TypeDefinitionAdapter.prototype.provideTypeDefinition = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideTypeDefinition(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.location.from);
                }
                else if (value) {
                    return TypeConverters.location.from(value);
                }
                return undefined;
            });
        };
        return TypeDefinitionAdapter;
    }());
    var HoverAdapter = (function () {
        function HoverAdapter(_documents, _provider, _telemetryLog) {
            this._documents = _documents;
            this._provider = _provider;
            this._telemetryLog = _telemetryLog;
            //
        }
        HoverAdapter.prototype.provideHover = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideHover(doc, pos, token); }).then(function (value) {
                if (!value || arrays_1.isFalsyOrEmpty(value.contents)) {
                    return undefined;
                }
                if (!value.range) {
                    value.range = doc.getWordRangeAtPosition(pos);
                }
                if (!value.range) {
                    value.range = new extHostTypes_1.Range(pos, pos);
                }
                var result = TypeConverters.fromHover(value);
                // we wanna know which extension uses command links
                // because that is a potential trick-attack on users
                if (result.contents.some(function (h) { return htmlContent_1.containsCommandLink(h.value); })) {
                    _this._telemetryLog('usesCommandLink', { from: 'hover' });
                }
                return result;
            });
        };
        return HoverAdapter;
    }());
    var DocumentHighlightAdapter = (function () {
        function DocumentHighlightAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        DocumentHighlightAdapter.prototype.provideDocumentHighlights = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentHighlights(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(DocumentHighlightAdapter._convertDocumentHighlight);
                }
                return undefined;
            });
        };
        DocumentHighlightAdapter._convertDocumentHighlight = function (documentHighlight) {
            return {
                range: TypeConverters.fromRange(documentHighlight.range),
                kind: documentHighlight.kind
            };
        };
        return DocumentHighlightAdapter;
    }());
    var ReferenceAdapter = (function () {
        function ReferenceAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        ReferenceAdapter.prototype.provideReferences = function (resource, position, context) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideReferences(doc, pos, context, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.location.from);
                }
                return undefined;
            });
        };
        return ReferenceAdapter;
    }());
    var QuickFixAdapter = (function () {
        function QuickFixAdapter(documents, commands, diagnostics, heapService, provider) {
            this._documents = documents;
            this._commands = commands;
            this._diagnostics = diagnostics;
            this._provider = provider;
        }
        QuickFixAdapter.prototype.provideCodeActions = function (resource, range) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var ran = TypeConverters.toRange(range);
            var allDiagnostics = [];
            this._diagnostics.forEach(function (collection) {
                if (collection.has(resource)) {
                    for (var _i = 0, _a = collection.get(resource); _i < _a.length; _i++) {
                        var diagnostic = _a[_i];
                        if (diagnostic.range.intersection(ran)) {
                            allDiagnostics.push(diagnostic);
                        }
                    }
                }
            });
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeActions(doc, ran, { diagnostics: allDiagnostics }, token); }).then(function (commands) {
                if (!Array.isArray(commands)) {
                    return undefined;
                }
                return commands.map(function (command) { return _this._commands.toInternal(command); });
            });
        };
        return QuickFixAdapter;
    }());
    var DocumentFormattingAdapter = (function () {
        function DocumentFormattingAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        DocumentFormattingAdapter.prototype.provideDocumentFormattingEdits = function (resource, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentFormattingEdits(document, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
                return undefined;
            });
        };
        return DocumentFormattingAdapter;
    }());
    var RangeFormattingAdapter = (function () {
        function RangeFormattingAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        RangeFormattingAdapter.prototype.provideDocumentRangeFormattingEdits = function (resource, range, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var ran = TypeConverters.toRange(range);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
                return undefined;
            });
        };
        return RangeFormattingAdapter;
    }());
    var OnTypeFormattingAdapter = (function () {
        function OnTypeFormattingAdapter(documents, provider) {
            this.autoFormatTriggerCharacters = []; // not here
            this._documents = documents;
            this._provider = provider;
        }
        OnTypeFormattingAdapter.prototype.provideOnTypeFormattingEdits = function (resource, position, ch, options) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(TypeConverters.TextEdit.from);
                }
                return undefined;
            });
        };
        return OnTypeFormattingAdapter;
    }());
    var NavigateTypeAdapter = (function () {
        function NavigateTypeAdapter(provider, heapService) {
            this._provider = provider;
            this._heapService = heapService;
        }
        NavigateTypeAdapter.prototype.provideWorkspaceSymbols = function (search) {
            var _this = this;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideWorkspaceSymbols(search, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(function (item) {
                        var id = _this._heapService.keep(item);
                        var result = TypeConverters.fromSymbolInformation(item);
                        return extHost_protocol_1.ObjectIdentifier.mixin(result, id);
                    });
                }
                return undefined;
            });
        };
        NavigateTypeAdapter.prototype.resolveWorkspaceSymbol = function (item) {
            var _this = this;
            if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
                return winjs_base_1.TPromise.as(item);
            }
            var symbolInfo = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(item));
            if (symbolInfo) {
                return async_1.asWinJsPromise(function (token) { return _this._provider.resolveWorkspaceSymbol(symbolInfo, token); }).then(function (value) {
                    return value && TypeConverters.fromSymbolInformation(value);
                });
            }
            return undefined;
        };
        return NavigateTypeAdapter;
    }());
    var RenameAdapter = (function () {
        function RenameAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        RenameAdapter.prototype.provideRenameEdits = function (resource, position, newName) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideRenameEdits(doc, pos, newName, token); }).then(function (value) {
                if (!value) {
                    return undefined;
                }
                var result = {
                    edits: []
                };
                for (var _i = 0, _a = value.entries(); _i < _a.length; _i++) {
                    var entry = _a[_i];
                    var uri = entry[0], textEdits = entry[1];
                    for (var _b = 0, textEdits_1 = textEdits; _b < textEdits_1.length; _b++) {
                        var textEdit = textEdits_1[_b];
                        result.edits.push({
                            resource: uri,
                            newText: textEdit.newText,
                            range: TypeConverters.fromRange(textEdit.range)
                        });
                    }
                }
                return result;
            }, function (err) {
                if (typeof err === 'string') {
                    return {
                        edits: undefined,
                        rejectReason: err
                    };
                }
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        return RenameAdapter;
    }());
    var SuggestAdapter = (function () {
        function SuggestAdapter(documents, commands, heapService, provider) {
            this._documents = documents;
            this._commands = commands;
            this._heapService = heapService;
            this._provider = provider;
        }
        SuggestAdapter.prototype.provideCompletionItems = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideCompletionItems(doc, pos, token); }).then(function (value) {
                var result = {
                    suggestions: [],
                };
                var list;
                if (!value) {
                    // undefined and null are valid results
                    return undefined;
                }
                else if (Array.isArray(value)) {
                    list = new extHostTypes_1.CompletionList(value);
                }
                else {
                    list = value;
                    result.incomplete = list.isIncomplete;
                }
                // the default text edit range
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos))
                    .with({ end: pos });
                for (var _i = 0, _a = list.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    var suggestion = _this._convertCompletionItem(item, pos, wordRangeBeforePos);
                    // bad completion item
                    if (!suggestion) {
                        // converter did warn
                        continue;
                    }
                    extHost_protocol_1.ObjectIdentifier.mixin(suggestion, _this._heapService.keep(item));
                    result.suggestions.push(suggestion);
                }
                return result;
            });
        };
        SuggestAdapter.prototype.resolveCompletionItem = function (resource, position, suggestion) {
            var _this = this;
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(suggestion);
            var item = this._heapService.get(id);
            if (!item) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveCompletionItem(item, token); }).then(function (resolvedItem) {
                if (!resolvedItem) {
                    return suggestion;
                }
                var doc = _this._documents.getDocumentData(resource).document;
                var pos = TypeConverters.toPosition(position);
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos)).with({ end: pos });
                var newSuggestion = _this._convertCompletionItem(resolvedItem, pos, wordRangeBeforePos);
                if (newSuggestion) {
                    objects_1.mixin(suggestion, newSuggestion, true);
                }
                return suggestion;
            });
        };
        SuggestAdapter.prototype._convertCompletionItem = function (item, position, defaultRange) {
            if (typeof item.label !== 'string' || item.label.length === 0) {
                console.warn('INVALID text edit -> must have at least a label');
                return undefined;
            }
            var result = {
                //
                label: item.label,
                type: TypeConverters.CompletionItemKind.from(item.kind),
                detail: item.detail,
                documentation: item.documentation,
                filterText: item.filterText,
                sortText: item.sortText,
                //
                insertText: undefined,
                additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(TypeConverters.TextEdit.from),
                command: this._commands.toInternal(item.command),
                commitCharacters: item.commitCharacters
            };
            // 'insertText'-logic
            if (item.textEdit) {
                result.insertText = item.textEdit.newText;
                result.snippetType = 'internal';
            }
            else if (typeof item.insertText === 'string') {
                result.insertText = item.insertText;
                result.snippetType = 'internal';
            }
            else if (item.insertText instanceof extHostTypes_1.SnippetString) {
                result.insertText = item.insertText.value;
                result.snippetType = 'textmate';
            }
            else {
                result.insertText = item.label;
                result.snippetType = 'internal';
            }
            // 'overwrite[Before|After]'-logic
            var range;
            if (item.textEdit) {
                range = item.textEdit.range;
            }
            else if (item.range) {
                range = item.range;
            }
            else {
                range = defaultRange;
            }
            result.overwriteBefore = position.character - range.start.character;
            result.overwriteAfter = range.end.character - position.character;
            if (!range.isSingleLine || range.start.line !== position.line) {
                console.warn('INVALID text edit -> must be single line and on the same line');
                return undefined;
            }
            return result;
        };
        return SuggestAdapter;
    }());
    var SignatureHelpAdapter = (function () {
        function SignatureHelpAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        SignatureHelpAdapter.prototype.provideSignatureHelp = function (resource, position) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = TypeConverters.toPosition(position);
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideSignatureHelp(doc, pos, token); }).then(function (value) {
                if (value) {
                    return TypeConverters.SignatureHelp.from(value);
                }
                return undefined;
            });
        };
        return SignatureHelpAdapter;
    }());
    var LinkProviderAdapter = (function () {
        function LinkProviderAdapter(documents, heapService, provider) {
            this._documents = documents;
            this._heapService = heapService;
            this._provider = provider;
        }
        LinkProviderAdapter.prototype.provideLinks = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentLinks(doc, token); }).then(function (links) {
                if (!Array.isArray(links)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, links_1 = links; _i < links_1.length; _i++) {
                    var link = links_1[_i];
                    var data = TypeConverters.DocumentLink.from(link);
                    var id = _this._heapService.keep(link);
                    extHost_protocol_1.ObjectIdentifier.mixin(data, id);
                    result.push(data);
                }
                return result;
            });
        };
        LinkProviderAdapter.prototype.resolveLink = function (link) {
            var _this = this;
            if (typeof this._provider.resolveDocumentLink !== 'function') {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(link);
            var item = this._heapService.get(id);
            if (!item) {
                return undefined;
            }
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveDocumentLink(item, token); }).then(function (value) {
                if (value) {
                    return TypeConverters.DocumentLink.from(value);
                }
                return undefined;
            });
        };
        return LinkProviderAdapter;
    }());
    var ColorProviderAdapter = (function () {
        function ColorProviderAdapter(_proxy, _documents, _colorFormatCache, _provider) {
            this._proxy = _proxy;
            this._documents = _documents;
            this._colorFormatCache = _colorFormatCache;
            this._provider = _provider;
        }
        ColorProviderAdapter.prototype.provideColors = function (resource) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentColors(doc, token); }).then(function (colors) {
                if (!Array.isArray(colors)) {
                    return [];
                }
                var newRawColorFormats = [];
                var getFormatId = function (format) {
                    var id = _this._colorFormatCache.get(format);
                    if (typeof id !== 'number') {
                        id = ColorProviderAdapter._colorFormatHandlePool++;
                        _this._colorFormatCache.set(format, id);
                        newRawColorFormats.push([id, format]);
                    }
                    return id;
                };
                var colorInfos = colors.map(function (ci) {
                    var availableFormats = ci.availableFormats.map(function (format) {
                        if (typeof format === 'string') {
                            return getFormatId(format);
                        }
                        else {
                            return [getFormatId(format.opaque), getFormatId(format.transparent)];
                        }
                    });
                    return {
                        color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha],
                        availableFormats: availableFormats,
                        range: TypeConverters.fromRange(ci.range)
                    };
                });
                _this._proxy.$registerColorFormats(newRawColorFormats);
                return colorInfos;
            });
        };
        ColorProviderAdapter._colorFormatHandlePool = 0;
        return ColorProviderAdapter;
    }());
    var ExtHostLanguageFeatures = (function () {
        function ExtHostLanguageFeatures(mainContext, documents, commands, heapMonitor, diagnostics) {
            this._adapter = new Map();
            this._colorFormatCache = new Map();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadLanguageFeatures);
            this._telemetry = mainContext.get(extHost_protocol_1.MainContext.MainThreadTelemetry);
            this._documents = documents;
            this._commands = commands;
            this._heapService = heapMonitor;
            this._diagnostics = diagnostics;
        }
        ExtHostLanguageFeatures.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapter.delete(handle);
                _this._proxy.$unregister(handle);
            });
        };
        ExtHostLanguageFeatures.prototype._nextHandle = function () {
            return ExtHostLanguageFeatures._handlePool++;
        };
        ExtHostLanguageFeatures.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter.get(handle);
            if (!(adapter instanceof ctor)) {
                return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        // --- outline
        ExtHostLanguageFeatures.prototype.registerDocumentSymbolProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new OutlineAdapter(this._documents, provider));
            this._proxy.$registerOutlineSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentSymbols = function (handle, resource) {
            return this._withAdapter(handle, OutlineAdapter, function (adapter) { return adapter.provideDocumentSymbols(resource); });
        };
        // --- code lens
        ExtHostLanguageFeatures.prototype.registerCodeLensProvider = function (selector, provider) {
            var _this = this;
            var handle = this._nextHandle();
            var eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;
            this._adapter.set(handle, new CodeLensAdapter(this._documents, this._commands.converter, this._heapService, provider));
            this._proxy.$registerCodeLensSupport(handle, selector, eventHandle);
            var result = this._createDisposable(handle);
            if (eventHandle !== undefined) {
                var subscription = provider.onDidChangeCodeLenses(function (_) { return _this._proxy.$emitCodeLensEvent(eventHandle); });
                result = extHostTypes_1.Disposable.from(result, subscription);
            }
            return result;
        };
        ExtHostLanguageFeatures.prototype.$provideCodeLenses = function (handle, resource) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.provideCodeLenses(resource); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCodeLens = function (handle, resource, symbol) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.resolveCodeLens(resource, symbol); });
        };
        // --- declaration
        ExtHostLanguageFeatures.prototype.registerDefinitionProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new DefinitionAdapter(this._documents, provider));
            this._proxy.$registerDeclaractionSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDefinition = function (handle, resource, position) {
            return this._withAdapter(handle, DefinitionAdapter, function (adapter) { return adapter.provideDefinition(resource, position); });
        };
        ExtHostLanguageFeatures.prototype.registerImplementationProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new ImplementationAdapter(this._documents, provider));
            this._proxy.$registerImplementationSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideImplementation = function (handle, resource, position) {
            return this._withAdapter(handle, ImplementationAdapter, function (adapter) { return adapter.provideImplementation(resource, position); });
        };
        ExtHostLanguageFeatures.prototype.registerTypeDefinitionProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new TypeDefinitionAdapter(this._documents, provider));
            this._proxy.$registerTypeDefinitionSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideTypeDefinition = function (handle, resource, position) {
            return this._withAdapter(handle, TypeDefinitionAdapter, function (adapter) { return adapter.provideTypeDefinition(resource, position); });
        };
        // --- extra info
        ExtHostLanguageFeatures.prototype.registerHoverProvider = function (selector, provider, extensionId) {
            var _this = this;
            var handle = this._nextHandle();
            this._adapter.set(handle, new HoverAdapter(this._documents, provider, functional_1.once(function (name, data) {
                data['extension'] = extensionId;
                _this._telemetry.$publicLog(name, data);
            })));
            this._proxy.$registerHoverProvider(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideHover = function (handle, resource, position) {
            return this._withAdapter(handle, HoverAdapter, function (adpater) { return adpater.provideHover(resource, position); });
        };
        // --- occurrences
        ExtHostLanguageFeatures.prototype.registerDocumentHighlightProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new DocumentHighlightAdapter(this._documents, provider));
            this._proxy.$registerDocumentHighlightProvider(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentHighlights = function (handle, resource, position) {
            return this._withAdapter(handle, DocumentHighlightAdapter, function (adapter) { return adapter.provideDocumentHighlights(resource, position); });
        };
        // --- references
        ExtHostLanguageFeatures.prototype.registerReferenceProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new ReferenceAdapter(this._documents, provider));
            this._proxy.$registerReferenceSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideReferences = function (handle, resource, position, context) {
            return this._withAdapter(handle, ReferenceAdapter, function (adapter) { return adapter.provideReferences(resource, position, context); });
        };
        // --- quick fix
        ExtHostLanguageFeatures.prototype.registerCodeActionProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new QuickFixAdapter(this._documents, this._commands.converter, this._diagnostics, this._heapService, provider));
            this._proxy.$registerQuickFixSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCodeActions = function (handle, resource, range) {
            return this._withAdapter(handle, QuickFixAdapter, function (adapter) { return adapter.provideCodeActions(resource, range); });
        };
        // --- formatting
        ExtHostLanguageFeatures.prototype.registerDocumentFormattingEditProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new DocumentFormattingAdapter(this._documents, provider));
            this._proxy.$registerDocumentFormattingSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentFormattingEdits = function (handle, resource, options) {
            return this._withAdapter(handle, DocumentFormattingAdapter, function (adapter) { return adapter.provideDocumentFormattingEdits(resource, options); });
        };
        ExtHostLanguageFeatures.prototype.registerDocumentRangeFormattingEditProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new RangeFormattingAdapter(this._documents, provider));
            this._proxy.$registerRangeFormattingSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentRangeFormattingEdits = function (handle, resource, range, options) {
            return this._withAdapter(handle, RangeFormattingAdapter, function (adapter) { return adapter.provideDocumentRangeFormattingEdits(resource, range, options); });
        };
        ExtHostLanguageFeatures.prototype.registerOnTypeFormattingEditProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new OnTypeFormattingAdapter(this._documents, provider));
            this._proxy.$registerOnTypeFormattingSupport(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideOnTypeFormattingEdits = function (handle, resource, position, ch, options) {
            return this._withAdapter(handle, OnTypeFormattingAdapter, function (adapter) { return adapter.provideOnTypeFormattingEdits(resource, position, ch, options); });
        };
        // --- navigate types
        ExtHostLanguageFeatures.prototype.registerWorkspaceSymbolProvider = function (provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new NavigateTypeAdapter(provider, this._heapService));
            this._proxy.$registerNavigateTypeSupport(handle);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideWorkspaceSymbols = function (handle, search) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.provideWorkspaceSymbols(search); });
        };
        ExtHostLanguageFeatures.prototype.$resolveWorkspaceSymbol = function (handle, symbol) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.resolveWorkspaceSymbol(symbol); });
        };
        // --- rename
        ExtHostLanguageFeatures.prototype.registerRenameProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new RenameAdapter(this._documents, provider));
            this._proxy.$registerRenameSupport(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideRenameEdits = function (handle, resource, position, newName) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.provideRenameEdits(resource, position, newName); });
        };
        // --- suggestion
        ExtHostLanguageFeatures.prototype.registerCompletionItemProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new SuggestAdapter(this._documents, this._commands.converter, this._heapService, provider));
            this._proxy.$registerSuggestSupport(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCompletionItems = function (handle, resource, position) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.provideCompletionItems(resource, position); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCompletionItem = function (handle, resource, position, suggestion) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.resolveCompletionItem(resource, position, suggestion); });
        };
        // --- parameter hints
        ExtHostLanguageFeatures.prototype.registerSignatureHelpProvider = function (selector, provider, triggerCharacters) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new SignatureHelpAdapter(this._documents, provider));
            this._proxy.$registerSignatureHelpProvider(handle, selector, triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideSignatureHelp = function (handle, resource, position) {
            return this._withAdapter(handle, SignatureHelpAdapter, function (adapter) { return adapter.provideSignatureHelp(resource, position); });
        };
        // --- links
        ExtHostLanguageFeatures.prototype.registerDocumentLinkProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new LinkProviderAdapter(this._documents, this._heapService, provider));
            this._proxy.$registerDocumentLinkProvider(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentLinks = function (handle, resource) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.provideLinks(resource); });
        };
        ExtHostLanguageFeatures.prototype.$resolveDocumentLink = function (handle, link) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.resolveLink(link); });
        };
        ExtHostLanguageFeatures.prototype.registerColorProvider = function (selector, provider) {
            var handle = this._nextHandle();
            this._adapter.set(handle, new ColorProviderAdapter(this._proxy, this._documents, this._colorFormatCache, provider));
            this._proxy.$registerDocumentColorProvider(handle, selector);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentColors = function (handle, resource) {
            return this._withAdapter(handle, ColorProviderAdapter, function (adapter) { return adapter.provideColors(resource); });
        };
        // --- configuration
        ExtHostLanguageFeatures.prototype.setLanguageConfiguration = function (languageId, configuration) {
            var wordPattern = configuration.wordPattern;
            // check for a valid word pattern
            if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {
                throw new Error("Invalid language configuration: wordPattern '" + wordPattern + "' is not allowed to match the empty string.");
            }
            // word definition
            if (wordPattern) {
                this._documents.setWordDefinitionFor(languageId, wordPattern);
            }
            else {
                this._documents.setWordDefinitionFor(languageId, null);
            }
            var handle = this._nextHandle();
            this._proxy.$setLanguageConfiguration(handle, languageId, configuration);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures._handlePool = 0;
        return ExtHostLanguageFeatures;
    }());
    exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;
});

define(__m[150/*vs/workbench/api/node/extHostLanguages*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostLanguages = (function () {
        function ExtHostLanguages(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadLanguages);
        }
        ExtHostLanguages.prototype.getLanguages = function () {
            return this._proxy.$getLanguages();
        };
        return ExtHostLanguages;
    }());
    exports.ExtHostLanguages = ExtHostLanguages;
});

define(__m[151/*vs/workbench/api/node/extHostMessageService*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMessageItem(item) {
        return item && item.title;
    }
    var ExtHostMessageService = (function () {
        function ExtHostMessageService(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadMessageService);
        }
        ExtHostMessageService.prototype.showMessage = function (extension, severity, message, optionsOrFirstItem, rest) {
            var options = { extension: extension };
            var items;
            if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {
                items = [optionsOrFirstItem].concat(rest);
            }
            else {
                options.modal = optionsOrFirstItem && optionsOrFirstItem.modal;
                items = rest;
            }
            var commands = [];
            for (var handle = 0; handle < items.length; handle++) {
                var command = items[handle];
                if (typeof command === 'string') {
                    commands.push({ title: command, handle: handle, isCloseAffordance: false });
                }
                else if (typeof command === 'object') {
                    var title = command.title, isCloseAffordance = command.isCloseAffordance;
                    commands.push({ title: title, isCloseAffordance: isCloseAffordance, handle: handle });
                }
                else {
                    console.warn('Invalid message item:', command);
                }
            }
            return this._proxy.$showMessage(severity, message, options, commands).then(function (handle) {
                if (typeof handle === 'number') {
                    return items[handle];
                }
                return undefined;
            });
        };
        return ExtHostMessageService;
    }());
    exports.ExtHostMessageService = ExtHostMessageService;
});

define(__m[152/*vs/workbench/api/node/extHostOutputService*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostOutputChannel = (function () {
        function ExtHostOutputChannel(name, proxy) {
            this._name = name;
            this._id = 'extension-output-#' + (ExtHostOutputChannel._idPool++);
            this._proxy = proxy;
        }
        Object.defineProperty(ExtHostOutputChannel.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostOutputChannel.prototype.dispose = function () {
            var _this = this;
            if (!this._disposed) {
                this._proxy.$dispose(this._id, this._name).then(function () {
                    _this._disposed = true;
                });
            }
        };
        ExtHostOutputChannel.prototype.append = function (value) {
            this._proxy.$append(this._id, this._name, value);
        };
        ExtHostOutputChannel.prototype.appendLine = function (value) {
            this.append(value + '\n');
        };
        ExtHostOutputChannel.prototype.clear = function () {
            this._proxy.$clear(this._id, this._name);
        };
        ExtHostOutputChannel.prototype.show = function (columnOrPreserveFocus, preserveFocus) {
            if (typeof columnOrPreserveFocus === 'boolean') {
                preserveFocus = columnOrPreserveFocus;
            }
            this._proxy.$reveal(this._id, this._name, preserveFocus);
        };
        ExtHostOutputChannel.prototype.hide = function () {
            this._proxy.$close(this._id);
        };
        ExtHostOutputChannel._idPool = 1;
        return ExtHostOutputChannel;
    }());
    exports.ExtHostOutputChannel = ExtHostOutputChannel;
    var ExtHostOutputService = (function () {
        function ExtHostOutputService(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadOutputService);
        }
        ExtHostOutputService.prototype.createOutputChannel = function (name) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            else {
                return new ExtHostOutputChannel(name, this._proxy);
            }
        };
        return ExtHostOutputService;
    }());
    exports.ExtHostOutputService = ExtHostOutputService;
});

define(__m[153/*vs/workbench/api/node/extHostQuickOpen*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,10/*vs/base/common/async*/,29/*vs/base/common/cancellation*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, winjs_base_1, async_1, cancellation_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostQuickOpen = (function () {
        function ExtHostQuickOpen(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadQuickOpen);
        }
        ExtHostQuickOpen.prototype.showQuickPick = function (itemsOrItemsPromise, options, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // clear state from last invocation
            this._onDidSelectItem = undefined;
            var itemsPromise = winjs_base_1.TPromise.wrap(itemsOrItemsPromise);
            var quickPickWidget = this._proxy.$show({
                autoFocus: { autoFocusFirstEntry: true },
                placeHolder: options && options.placeHolder,
                matchOnDescription: options && options.matchOnDescription,
                matchOnDetail: options && options.matchOnDetail,
                ignoreFocusLost: options && options.ignoreFocusOut
            });
            var promise = winjs_base_1.TPromise.any([quickPickWidget, itemsPromise]).then(function (values) {
                if (values.key === '0') {
                    return undefined;
                }
                return itemsPromise.then(function (items) {
                    var pickItems = [];
                    for (var handle = 0; handle < items.length; handle++) {
                        var item = items[handle];
                        var label = void 0;
                        var description = void 0;
                        var detail = void 0;
                        if (typeof item === 'string') {
                            label = item;
                        }
                        else {
                            label = item.label;
                            description = item.description;
                            detail = item.detail;
                        }
                        pickItems.push({
                            label: label,
                            description: description,
                            handle: handle,
                            detail: detail
                        });
                    }
                    // handle selection changes
                    if (options && typeof options.onDidSelectItem === 'function') {
                        _this._onDidSelectItem = function (handle) {
                            options.onDidSelectItem(items[handle]);
                        };
                    }
                    // show items
                    _this._proxy.$setItems(pickItems);
                    return quickPickWidget.then(function (handle) {
                        if (typeof handle === 'number') {
                            return items[handle];
                        }
                        return undefined;
                    });
                }, function (err) {
                    _this._proxy.$setError(err);
                    return winjs_base_1.TPromise.wrapError(err);
                });
            });
            return async_1.wireCancellationToken(token, promise, true);
        };
        ExtHostQuickOpen.prototype.$onItemSelected = function (handle) {
            if (this._onDidSelectItem) {
                this._onDidSelectItem(handle);
            }
        };
        // ---- input
        ExtHostQuickOpen.prototype.showInput = function (options, token) {
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // global validate fn used in callback below
            this._validateInput = options && options.validateInput;
            var promise = this._proxy.$input(options, typeof this._validateInput === 'function');
            return async_1.wireCancellationToken(token, promise, true);
        };
        ExtHostQuickOpen.prototype.$validateInput = function (input) {
            if (this._validateInput) {
                return winjs_base_1.TPromise.as(this._validateInput(input));
            }
            return undefined;
        };
        return ExtHostQuickOpen;
    }());
    exports.ExtHostQuickOpen = ExtHostQuickOpen;
});

define(__m[154/*vs/workbench/api/node/extHostSCM*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,10/*vs/base/common/async*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, uri_1, winjs_base_1, event_1, async_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getIconPath(decorations) {
        if (!decorations) {
            return undefined;
        }
        else if (typeof decorations.iconPath === 'string') {
            return uri_1.default.file(decorations.iconPath).toString();
        }
        else if (decorations.iconPath) {
            return "" + decorations.iconPath;
        }
        return undefined;
    }
    var ExtHostSCMInputBox = (function () {
        function ExtHostSCMInputBox(_proxy, _sourceControlHandle) {
            this._proxy = _proxy;
            this._sourceControlHandle = _sourceControlHandle;
            this._value = '';
            this._onDidChange = new event_1.Emitter();
            // noop
        }
        Object.defineProperty(ExtHostSCMInputBox.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._proxy.$setInputBoxValue(this._sourceControlHandle, value);
                this.updateValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSCMInputBox.prototype.$onInputBoxValueChange = function (value) {
            this.updateValue(value);
        };
        ExtHostSCMInputBox.prototype.updateValue = function (value) {
            this._value = value;
            this._onDidChange.fire(value);
        };
        return ExtHostSCMInputBox;
    }());
    exports.ExtHostSCMInputBox = ExtHostSCMInputBox;
    var ExtHostSourceControlResourceGroup = (function () {
        function ExtHostSourceControlResourceGroup(_proxy, _commands, _sourceControlHandle, _id, _label) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._sourceControlHandle = _sourceControlHandle;
            this._id = _id;
            this._label = _label;
            this._resourceHandlePool = 0;
            this._resourceStates = [];
            this._resourceStatesRollingDisposables = [];
            this._resourceStatesMap = new Map();
            this._hideWhenEmpty = undefined;
            this._handle = ExtHostSourceControlResourceGroup._handlePool++;
            this._proxy.$registerGroup(_sourceControlHandle, this._handle, _id, _label);
        }
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (label) {
                this._label = label;
                this._proxy.$updateGroupLabel(this._sourceControlHandle, this._handle, label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "hideWhenEmpty", {
            get: function () {
                return this._hideWhenEmpty;
            },
            set: function (hideWhenEmpty) {
                this._hideWhenEmpty = hideWhenEmpty;
                this._proxy.$updateGroup(this._sourceControlHandle, this._handle, { hideWhenEmpty: hideWhenEmpty });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "resourceStates", {
            get: function () {
                return this._resourceStates.slice();
            },
            set: function (resources) {
                var _this = this;
                this._resourceStates = resources.slice();
                var handles = [];
                var rawResources = resources.map(function (r) {
                    var handle = _this._resourceHandlePool++;
                    _this._resourceStatesMap.set(handle, r);
                    handles.push(handle);
                    var sourceUri = r.resourceUri.toString();
                    var command = _this._commands.toInternal(r.command);
                    var iconPath = getIconPath(r.decorations);
                    var lightIconPath = r.decorations && getIconPath(r.decorations.light) || iconPath;
                    var darkIconPath = r.decorations && getIconPath(r.decorations.dark) || iconPath;
                    var icons = [];
                    if (lightIconPath || darkIconPath) {
                        icons.push(lightIconPath);
                    }
                    if (darkIconPath !== lightIconPath) {
                        icons.push(darkIconPath);
                    }
                    var tooltip = (r.decorations && r.decorations.tooltip) || '';
                    var strikeThrough = r.decorations && !!r.decorations.strikeThrough;
                    var faded = r.decorations && !!r.decorations.faded;
                    return [handle, sourceUri, command, icons, tooltip, strikeThrough, faded];
                });
                var disposable = function () { return handles.forEach(function (handle) { return _this._resourceStatesMap.delete(handle); }); };
                this._resourceStatesRollingDisposables.push(disposable);
                while (this._resourceStatesRollingDisposables.length >= 10) {
                    this._resourceStatesRollingDisposables.shift()();
                }
                this._proxy.$updateGroupResourceStates(this._sourceControlHandle, this._handle, rawResources);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "handle", {
            get: function () {
                return this._handle;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControlResourceGroup.prototype.getResourceState = function (handle) {
            return this._resourceStatesMap.get(handle);
        };
        ExtHostSourceControlResourceGroup.prototype.dispose = function () {
            this._proxy.$unregisterGroup(this._sourceControlHandle, this._handle);
        };
        ExtHostSourceControlResourceGroup._handlePool = 0;
        return ExtHostSourceControlResourceGroup;
    }());
    var ExtHostSourceControl = (function () {
        function ExtHostSourceControl(_proxy, _commands, _id, _label) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._id = _id;
            this._label = _label;
            this._groups = new Map();
            this._count = undefined;
            this._quickDiffProvider = undefined;
            this._commitTemplate = undefined;
            this._acceptInputCommand = undefined;
            this._statusBarCommands = undefined;
            this._handle = ExtHostSourceControl._handlePool++;
            this._inputBox = new ExtHostSCMInputBox(this._proxy, this._handle);
            this._proxy.$registerSourceControl(this._handle, _id, _label);
        }
        Object.defineProperty(ExtHostSourceControl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "inputBox", {
            get: function () { return this._inputBox; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "count", {
            get: function () {
                return this._count;
            },
            set: function (count) {
                this._count = count;
                this._proxy.$updateSourceControl(this._handle, { count: count });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "quickDiffProvider", {
            get: function () {
                return this._quickDiffProvider;
            },
            set: function (quickDiffProvider) {
                this._quickDiffProvider = quickDiffProvider;
                this._proxy.$updateSourceControl(this._handle, { hasQuickDiffProvider: !!quickDiffProvider });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "commitTemplate", {
            get: function () {
                return this._commitTemplate;
            },
            set: function (commitTemplate) {
                this._commitTemplate = commitTemplate;
                this._proxy.$updateSourceControl(this._handle, { commitTemplate: commitTemplate });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "acceptInputCommand", {
            get: function () {
                return this._acceptInputCommand;
            },
            set: function (acceptInputCommand) {
                this._acceptInputCommand = acceptInputCommand;
                var internal = this._commands.toInternal(acceptInputCommand);
                this._proxy.$updateSourceControl(this._handle, { acceptInputCommand: internal });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "statusBarCommands", {
            get: function () {
                return this._statusBarCommands;
            },
            set: function (statusBarCommands) {
                var _this = this;
                this._statusBarCommands = statusBarCommands;
                var internal = (statusBarCommands || []).map(function (c) { return _this._commands.toInternal(c); });
                this._proxy.$updateSourceControl(this._handle, { statusBarCommands: internal });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControl.prototype.createResourceGroup = function (id, label) {
            var group = new ExtHostSourceControlResourceGroup(this._proxy, this._commands, this._handle, id, label);
            this._groups.set(group.handle, group);
            return group;
        };
        ExtHostSourceControl.prototype.getResourceGroup = function (handle) {
            return this._groups.get(handle);
        };
        ExtHostSourceControl.prototype.dispose = function () {
            this._proxy.$unregisterSourceControl(this._handle);
        };
        ExtHostSourceControl._handlePool = 0;
        return ExtHostSourceControl;
    }());
    var ExtHostSCM = (function () {
        function ExtHostSCM(mainContext, _commands) {
            var _this = this;
            this._commands = _commands;
            this._sourceControls = new Map();
            this._sourceControlsByExtension = new Map();
            this._onDidChangeActiveProvider = new event_1.Emitter();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadSCM);
            _commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$mid === 3) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        var group = sourceControl.getResourceGroup(arg.groupHandle);
                        if (!group) {
                            return arg;
                        }
                        return group.getResourceState(arg.handle);
                    }
                    else if (arg && arg.$mid === 4) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl.getResourceGroup(arg.groupHandle);
                    }
                    else if (arg && arg.$mid === 5) {
                        var sourceControl = _this._sourceControls.get(arg.handle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl;
                    }
                    return arg;
                }
            });
        }
        Object.defineProperty(ExtHostSCM.prototype, "onDidChangeActiveProvider", {
            get: function () { return this._onDidChangeActiveProvider.event; },
            enumerable: true,
            configurable: true
        });
        ExtHostSCM.prototype.createSourceControl = function (extension, id, label) {
            var handle = ExtHostSCM._handlePool++;
            var sourceControl = new ExtHostSourceControl(this._proxy, this._commands.converter, id, label);
            this._sourceControls.set(handle, sourceControl);
            var sourceControls = this._sourceControlsByExtension.get(extension.id) || [];
            sourceControls.push(sourceControl);
            this._sourceControlsByExtension.set(extension.id, sourceControls);
            return sourceControl;
        };
        // Deprecated
        ExtHostSCM.prototype.getLastInputBox = function (extension) {
            var sourceControls = this._sourceControlsByExtension.get(extension.id);
            var sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
            var inputBox = sourceControl && sourceControl.inputBox;
            return inputBox;
        };
        ExtHostSCM.prototype.$provideOriginalResource = function (sourceControlHandle, uri) {
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl || !sourceControl.quickDiffProvider) {
                return winjs_base_1.TPromise.as(null);
            }
            return async_1.asWinJsPromise(function (token) {
                var result = sourceControl.quickDiffProvider.provideOriginalResource(uri, token);
                return result && uri_1.default.parse(result.toString());
            });
        };
        ExtHostSCM.prototype.$onInputBoxValueChange = function (sourceControlHandle, value) {
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl || !sourceControl.quickDiffProvider) {
                return winjs_base_1.TPromise.as(null);
            }
            sourceControl.inputBox.$onInputBoxValueChange(value);
            return winjs_base_1.TPromise.as(null);
        };
        ExtHostSCM._handlePool = 0;
        return ExtHostSCM;
    }());
    exports.ExtHostSCM = ExtHostSCM;
});

define(__m[155/*vs/workbench/api/node/extHostStatusBar*/], __M([1/*require*/,0/*exports*/,105/*vs/platform/statusbar/common/statusbar*/,5/*vs/workbench/api/node/extHostTypes*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, statusbar_1, extHostTypes_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStatusBarEntry = (function () {
        function ExtHostStatusBarEntry(proxy, extensionId, alignment, priority) {
            if (alignment === void 0) { alignment = extHostTypes_1.StatusBarAlignment.Left; }
            this._id = ExtHostStatusBarEntry.ID_GEN++;
            this._proxy = proxy;
            this._alignment = alignment;
            this._priority = priority;
            this._extensionId = extensionId;
        }
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "alignment", {
            get: function () {
                return this._alignment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "priority", {
            get: function () {
                return this._priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (tooltip) {
                this._tooltip = tooltip;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this._color = color;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (command) {
                this._command = command;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostStatusBarEntry.prototype.show = function () {
            this._visible = true;
            this.update();
        };
        ExtHostStatusBarEntry.prototype.hide = function () {
            clearTimeout(this._timeoutHandle);
            this._visible = false;
            this._proxy.$dispose(this.id);
        };
        ExtHostStatusBarEntry.prototype.update = function () {
            var _this = this;
            if (this._disposed || !this._visible) {
                return;
            }
            clearTimeout(this._timeoutHandle);
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = undefined;
                // Set to status bar
                _this._proxy.$setEntry(_this.id, _this._extensionId, _this.text, _this.tooltip, _this.command, _this.color, _this._alignment === extHostTypes_1.StatusBarAlignment.Left ? statusbar_1.StatusbarAlignment.LEFT : statusbar_1.StatusbarAlignment.RIGHT, _this._priority);
            }, 0);
        };
        ExtHostStatusBarEntry.prototype.dispose = function () {
            this.hide();
            this._disposed = true;
        };
        ExtHostStatusBarEntry.ID_GEN = 0;
        return ExtHostStatusBarEntry;
    }());
    exports.ExtHostStatusBarEntry = ExtHostStatusBarEntry;
    var StatusBarMessage = (function () {
        function StatusBarMessage(statusBar) {
            this._messages = [];
            this._item = statusBar.createStatusBarEntry(void 0, extHostTypes_1.StatusBarAlignment.Left, Number.MIN_VALUE);
        }
        StatusBarMessage.prototype.dispose = function () {
            this._messages.length = 0;
            this._item.dispose();
        };
        StatusBarMessage.prototype.setMessage = function (message) {
            var _this = this;
            var data = { message: message }; // use object to not confuse equal strings
            this._messages.unshift(data);
            this._update();
            return new extHostTypes_1.Disposable(function () {
                var idx = _this._messages.indexOf(data);
                if (idx >= 0) {
                    _this._messages.splice(idx, 1);
                    _this._update();
                }
            });
        };
        StatusBarMessage.prototype._update = function () {
            if (this._messages.length > 0) {
                this._item.text = this._messages[0].message;
                this._item.show();
            }
            else {
                this._item.hide();
            }
        };
        return StatusBarMessage;
    }());
    var ExtHostStatusBar = (function () {
        function ExtHostStatusBar(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadStatusBar);
            this._statusMessage = new StatusBarMessage(this);
        }
        ExtHostStatusBar.prototype.createStatusBarEntry = function (extensionId, alignment, priority) {
            return new ExtHostStatusBarEntry(this._proxy, extensionId, alignment, priority);
        };
        ExtHostStatusBar.prototype.setStatusBarMessage = function (text, timeoutOrThenable) {
            var d = this._statusMessage.setMessage(text);
            var handle;
            if (typeof timeoutOrThenable === 'number') {
                handle = setTimeout(function () { return d.dispose(); }, timeoutOrThenable);
            }
            else if (typeof timeoutOrThenable !== 'undefined') {
                timeoutOrThenable.then(function () { return d.dispose(); }, function () { return d.dispose(); });
            }
            return new extHostTypes_1.Disposable(function () {
                d.dispose();
                clearTimeout(handle);
            });
        };
        return ExtHostStatusBar;
    }());
    exports.ExtHostStatusBar = ExtHostStatusBar;
});

define(__m[156/*vs/workbench/api/node/extHostStorage*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStorage = (function () {
        function ExtHostStorage(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadStorage);
        }
        ExtHostStorage.prototype.getValue = function (shared, key, defaultValue) {
            return this._proxy.$getValue(shared, key).then(function (value) { return value || defaultValue; });
        };
        ExtHostStorage.prototype.setValue = function (shared, key, value) {
            return this._proxy.$setValue(shared, key, value);
        };
        return ExtHostStorage;
    }());
    exports.ExtHostStorage = ExtHostStorage;
});

define(__m[157/*vs/workbench/api/node/extHostTask*/], __M([1/*require*/,0/*exports*/,62/*vs/nls!vs/workbench/api/node/extHostTask*/,2/*vs/base/common/winjs.base*/,11/*vs/base/common/objects*/,10/*vs/base/common/async*/,117/*vs/workbench/parts/tasks/common/tasks*/,4/*vs/workbench/api/node/extHost.protocol*/,5/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, nls, winjs_base_1, Objects, async_1, TaskSystem, extHost_protocol_1, types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    namespace ProblemPattern {
        export function from(value: vscode.ProblemPattern | vscode.MultiLineProblemPattern): Problems.ProblemPattern | Problems.MultiLineProblemPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (Array.isArray(value)) {
                let result: Problems.ProblemPattern[] = [];
                for (let pattern of value) {
                    let converted = fromSingle(pattern);
                    if (!converted) {
                        return undefined;
                    }
                    result.push(converted);
                }
                return result;
            } else {
                return fromSingle(value);
            }
        }
    
        function copyProperty(target: Problems.ProblemPattern, source: vscode.ProblemPattern, tk: keyof Problems.ProblemPattern) {
            let sk: keyof vscode.ProblemPattern = tk;
            let value = source[sk];
            if (typeof value === 'number') {
                target[tk] = value;
            }
        }
    
        function getValue(value: number, defaultValue: number): number {
            if (value !== void 0 && value === null) {
                return value;
            }
            return defaultValue;
        }
    
        function fromSingle(problemPattern: vscode.ProblemPattern): Problems.ProblemPattern {
            if (problemPattern === void 0 || problemPattern === null || !(problemPattern.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.ProblemPattern = {
                regexp: problemPattern.regexp
            };
            copyProperty(result, problemPattern, 'file');
            copyProperty(result, problemPattern, 'location');
            copyProperty(result, problemPattern, 'line');
            copyProperty(result, problemPattern, 'character');
            copyProperty(result, problemPattern, 'endLine');
            copyProperty(result, problemPattern, 'endCharacter');
            copyProperty(result, problemPattern, 'severity');
            copyProperty(result, problemPattern, 'code');
            copyProperty(result, problemPattern, 'message');
            if (problemPattern.loop === true || problemPattern.loop === false) {
                result.loop = problemPattern.loop;
            }
            if (result.location) {
                result.file = getValue(result.file, 1);
                result.message = getValue(result.message, 0);
            } else {
                result.file = getValue(result.file, 1);
                result.line = getValue(result.line, 2);
                result.character = getValue(result.character, 3);
                result.message = getValue(result.message, 0);
            }
            return result;
        }
    }
    
    namespace ApplyTo {
        export function from(value: vscode.ApplyToKind): Problems.ApplyToKind {
            if (value === void 0 || value === null) {
                return Problems.ApplyToKind.allDocuments;
            }
            switch (value) {
                case types.ApplyToKind.OpenDocuments:
                    return Problems.ApplyToKind.openDocuments;
                case types.ApplyToKind.ClosedDocuments:
                    return Problems.ApplyToKind.closedDocuments;
            }
            return Problems.ApplyToKind.allDocuments;
        }
    }
    
    namespace FileLocation {
        export function from(value: vscode.FileLocationKind | string): { kind: Problems.FileLocationKind; prefix?: string } {
            if (value === void 0 || value === null) {
                return { kind: Problems.FileLocationKind.Auto };
            }
            if (typeof value === 'string') {
                return { kind: Problems.FileLocationKind.Relative, prefix: value };
            }
            switch (value) {
                case types.FileLocationKind.Absolute:
                    return { kind: Problems.FileLocationKind.Absolute };
                case types.FileLocationKind.Relative:
                    return { kind: Problems.FileLocationKind.Relative, prefix: '${workspaceRoot}' };
            }
            return { kind: Problems.FileLocationKind.Auto };
        }
    }
    
    namespace WatchingPattern {
        export function from(value: RegExp | vscode.BackgroundPattern): Problems.WatchingPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (value instanceof RegExp) {
                return { regexp: value };
            }
            if (!(value.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.WatchingPattern = {
                regexp: value.regexp
            };
            if (typeof value.file === 'number') {
                result.file = value.file;
            }
            return result;
        }
    }
    
    namespace BackgroundMonitor {
        export function from(value: vscode.BackgroundMonitor): Problems.WatchingMatcher {
            if (value === void 0 || value === null) {
                return undefined;
            }
            let result: Problems.WatchingMatcher = {
                activeOnStart: !!value.activeOnStart,
                beginsPattern: WatchingPattern.from(value.beginsPattern),
                endsPattern: WatchingPattern.from(value.endsPattern)
            };
            return result;
        }
    }
    
    namespace ProblemMatcher {
        export function from(values: (string | vscode.ProblemMatcher)[]): (string | Problems.ProblemMatcher)[] {
            if (values === void 0 || values === null) {
                return undefined;
            }
            let result: (string | Problems.ProblemMatcher)[] = [];
            for (let value of values) {
                let converted = typeof value === 'string' ? value : fromSingle(value);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
    
        function fromSingle(problemMatcher: vscode.ProblemMatcher): Problems.ProblemMatcher {
            if (problemMatcher === void 0 || problemMatcher === null) {
                return undefined;
            }
    
            let location = FileLocation.from(problemMatcher.fileLocation);
            let result: Problems.ProblemMatcher = {
                owner: typeof problemMatcher.owner === 'string' ? problemMatcher.owner : UUID.generateUuid(),
                applyTo: ApplyTo.from(problemMatcher.applyTo),
                fileLocation: location.kind,
                filePrefix: location.prefix,
                pattern: ProblemPattern.from(problemMatcher.pattern),
                severity: fromDiagnosticSeverity(problemMatcher.severity),
            };
            return result;
        }
    }
    */
    var TaskRevealKind;
    (function (TaskRevealKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return TaskSystem.RevealKind.Always;
            }
            switch (value) {
                case types.TaskRevealKind.Silent:
                    return TaskSystem.RevealKind.Silent;
                case types.TaskRevealKind.Never:
                    return TaskSystem.RevealKind.Never;
            }
            return TaskSystem.RevealKind.Always;
        }
        TaskRevealKind.from = from;
    })(TaskRevealKind || (TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return TaskSystem.PanelKind.Shared;
            }
            switch (value) {
                case types.TaskPanelKind.Dedicated:
                    return TaskSystem.PanelKind.Dedicated;
                case types.TaskPanelKind.New:
                    return TaskSystem.PanelKind.New;
                default:
                    return TaskSystem.PanelKind.Shared;
            }
        }
        TaskPanelKind.from = from;
    })(TaskPanelKind || (TaskPanelKind = {}));
    var PresentationOptions;
    (function (PresentationOptions) {
        function from(value) {
            if (value === void 0 || value === null) {
                return { reveal: TaskSystem.RevealKind.Always, echo: true, focus: false, panel: TaskSystem.PanelKind.Shared };
            }
            return {
                reveal: TaskRevealKind.from(value.reveal),
                echo: value.echo === void 0 ? true : !!value.echo,
                focus: !!value.focus,
                panel: TaskPanelKind.from(value.panel)
            };
        }
        PresentationOptions.from = from;
    })(PresentationOptions || (PresentationOptions = {}));
    var Strings;
    (function (Strings) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var element = value_1[_i];
                if (typeof element !== 'string') {
                    return [];
                }
            }
            return value;
        }
        Strings.from = from;
    })(Strings || (Strings = {}));
    var CommandOptions;
    (function (CommandOptions) {
        function isShellConfiguration(value) {
            return value && typeof value.executable === 'string';
        }
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {};
            if (typeof value.cwd === 'string') {
                result.cwd = value.cwd;
            }
            if (value.env) {
                result.env = Object.create(null);
                Object.keys(value.env).forEach(function (key) {
                    var envValue = value.env[key];
                    if (typeof envValue === 'string') {
                        result.env[key] = envValue;
                    }
                });
            }
            if (isShellConfiguration(value)) {
                result.shell = ShellConfiguration.from(value);
            }
            return result;
        }
        CommandOptions.from = from;
    })(CommandOptions || (CommandOptions = {}));
    var ShellConfiguration;
    (function (ShellConfiguration) {
        function from(value) {
            if (value === void 0 || value === null || !value.executable) {
                return undefined;
            }
            var result = {
                executable: value.executable,
                args: Strings.from(value.shellArgs)
            };
            return result;
        }
        ShellConfiguration.from = from;
    })(ShellConfiguration || (ShellConfiguration = {}));
    var Tasks;
    (function (Tasks) {
        function from(tasks, extension) {
            if (tasks === void 0 || tasks === null) {
                return [];
            }
            var result = [];
            for (var _i = 0, tasks_1 = tasks; _i < tasks_1.length; _i++) {
                var task = tasks_1[_i];
                var converted = fromSingle(task, extension);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
        Tasks.from = from;
        function fromSingle(task, extension) {
            if (typeof task.name !== 'string') {
                return undefined;
            }
            var command;
            var execution = task.execution;
            if (execution instanceof types.ProcessExecution) {
                command = getProcessCommand(execution);
            }
            else if (execution instanceof types.ShellExecution) {
                command = getShellCommand(execution);
            }
            else {
                return undefined;
            }
            if (command === void 0) {
                return undefined;
            }
            command.presentation = PresentationOptions.from(task.presentationOptions);
            var source = {
                kind: TaskSystem.TaskSourceKind.Extension,
                label: typeof task.source === 'string' ? task.source : extension.name,
                extension: extension.id
            };
            var label = nls.localize(0, null, source.label, task.name);
            var key = task.definitionKey;
            var kind = task.definition;
            var id = extension.id + "." + key;
            var taskKind = {
                _key: key,
                type: kind.type
            };
            Objects.assign(taskKind, kind);
            var result = {
                _id: id,
                _source: source,
                _label: label,
                type: kind.type,
                defines: taskKind,
                name: task.name,
                identifier: label,
                group: task.group ? task.group.id : undefined,
                command: command,
                isBackground: !!task.isBackground,
                problemMatchers: task.problemMatchers.slice(),
                hasDefinedMatchers: task.hasDefinedMatchers
            };
            return result;
        }
        function getProcessCommand(value) {
            if (typeof value.process !== 'string') {
                return undefined;
            }
            var result = {
                name: value.process,
                args: Strings.from(value.args),
                runtime: TaskSystem.RuntimeType.Process,
                suppressTaskName: true,
                presentation: undefined
            };
            if (value.options) {
                result.options = CommandOptions.from(value.options);
            }
            return result;
        }
        function getShellCommand(value) {
            if (typeof value.commandLine !== 'string') {
                return undefined;
            }
            var result = {
                name: value.commandLine,
                runtime: TaskSystem.RuntimeType.Shell,
                presentation: undefined
            };
            if (value.options) {
                result.options = CommandOptions.from(value.options);
            }
            return result;
        }
    })(Tasks || (Tasks = {}));
    var ExtHostTask = (function () {
        function ExtHostTask(mainContext) {
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadTask);
            this._handleCounter = 0;
            this._handlers = new Map();
        }
        ;
        ExtHostTask.prototype.registerTaskProvider = function (extension, provider) {
            var _this = this;
            if (!provider) {
                return new types.Disposable(function () { });
            }
            var handle = this.nextHandle();
            this._handlers.set(handle, { provider: provider, extension: extension });
            this._proxy.$registerTaskProvider(handle);
            return new types.Disposable(function () {
                _this._handlers.delete(handle);
                _this._proxy.$unregisterTaskProvider(handle);
            });
        };
        ExtHostTask.prototype.$provideTasks = function (handle) {
            var handler = this._handlers.get(handle);
            if (!handler) {
                return winjs_base_1.TPromise.wrapError(new Error('no handler found'));
            }
            return async_1.asWinJsPromise(function (token) { return handler.provider.provideTasks(token); }).then(function (value) {
                return {
                    tasks: Tasks.from(value, handler.extension),
                    extension: handler.extension
                };
            });
        };
        ExtHostTask.prototype.nextHandle = function () {
            return this._handleCounter++;
        };
        return ExtHostTask;
    }());
    exports.ExtHostTask = ExtHostTask;
});

define(__m[158/*vs/workbench/api/node/extHostTerminalService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/event*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, winjs_base_1, event_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostTerminal = (function () {
        function ExtHostTerminal(proxy, name, shellPath, shellArgs, waitOnExit) {
            var _this = this;
            this._name = name;
            this._queuedRequests = [];
            this._proxy = proxy;
            this._pidPromise = new winjs_base_1.TPromise(function (c) {
                _this._pidPromiseComplete = c;
            });
            this._proxy.$createTerminal(name, shellPath, shellArgs, waitOnExit).then(function (id) {
                _this._id = id;
                _this._queuedRequests.forEach(function (r) {
                    r.run(_this._proxy, _this._id);
                });
                _this._queuedRequests = [];
            });
        }
        Object.defineProperty(ExtHostTerminal.prototype, "name", {
            get: function () {
                this._checkDisposed();
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminal.prototype, "processId", {
            get: function () {
                this._checkDisposed();
                return this._pidPromise;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminal.prototype.sendText = function (text, addNewLine) {
            if (addNewLine === void 0) { addNewLine = true; }
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$sendText, [text, addNewLine]);
        };
        ExtHostTerminal.prototype.show = function (preserveFocus) {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$show, [preserveFocus]);
        };
        ExtHostTerminal.prototype.hide = function () {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$hide, []);
        };
        ExtHostTerminal.prototype.dispose = function () {
            if (!this._disposed) {
                this._disposed = true;
                this._queueApiRequest(this._proxy.$dispose, []);
            }
        };
        ExtHostTerminal.prototype._setProcessId = function (processId) {
            this._pidPromiseComplete(processId);
            this._pidPromiseComplete = null;
        };
        ExtHostTerminal.prototype._queueApiRequest = function (callback, args) {
            var request = new ApiRequest(callback, args);
            if (!this._id) {
                this._queuedRequests.push(request);
                return;
            }
            request.run(this._proxy, this._id);
        };
        ExtHostTerminal.prototype._checkDisposed = function () {
            if (this._disposed) {
                throw new Error('Terminal has already been disposed');
            }
        };
        return ExtHostTerminal;
    }());
    exports.ExtHostTerminal = ExtHostTerminal;
    var ExtHostTerminalService = (function () {
        function ExtHostTerminalService(mainContext) {
            this._onDidCloseTerminal = new event_1.Emitter();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadTerminalService);
            this._terminals = [];
        }
        ExtHostTerminalService.prototype.createTerminal = function (name, shellPath, shellArgs) {
            var terminal = new ExtHostTerminal(this._proxy, name, shellPath, shellArgs);
            this._terminals.push(terminal);
            return terminal;
        };
        ExtHostTerminalService.prototype.createTerminalFromOptions = function (options) {
            var terminal = new ExtHostTerminal(this._proxy, options.name, options.shellPath, options.shellArgs /*, options.waitOnExit*/);
            this._terminals.push(terminal);
            return terminal;
        };
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidCloseTerminal", {
            get: function () {
                return this._onDidCloseTerminal && this._onDidCloseTerminal.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminalService.prototype.$acceptTerminalClosed = function (id) {
            var index = this._getTerminalIndexById(id);
            if (index === null) {
                // The terminal was not created by the terminal API, ignore it
                return;
            }
            var terminal = this._terminals.splice(index, 1)[0];
            this._onDidCloseTerminal.fire(terminal);
        };
        ExtHostTerminalService.prototype.$acceptTerminalProcessId = function (id, processId) {
            var terminal = this._getTerminalById(id);
            terminal._setProcessId(processId);
        };
        ExtHostTerminalService.prototype._getTerminalById = function (id) {
            var index = this._getTerminalIndexById(id);
            return index !== null ? this._terminals[index] : null;
        };
        ExtHostTerminalService.prototype._getTerminalIndexById = function (id) {
            var index = null;
            this._terminals.some(function (terminal, i) {
                var thisId = terminal._id;
                if (thisId === id) {
                    index = i;
                    return true;
                }
                return false;
            });
            return index;
        };
        return ExtHostTerminalService;
    }());
    exports.ExtHostTerminalService = ExtHostTerminalService;
    var ApiRequest = (function () {
        function ApiRequest(callback, args) {
            this._callback = callback;
            this._args = args;
        }
        ApiRequest.prototype.run = function (proxy, id) {
            this._callback.apply(proxy, [id].concat(this._args));
        };
        return ApiRequest;
    }());
});

define(__m[159/*vs/workbench/api/node/extHostTextEditors*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,10/*vs/base/common/async*/,5/*vs/workbench/api/node/extHostTypes*/,16/*vs/workbench/api/node/extHostTypeConverters*/,59/*vs/workbench/api/node/extHostTextEditor*/,48/*vs/platform/editor/common/editor*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, event_1, async_1, extHostTypes_1, TypeConverters, extHostTextEditor_1, editor_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostEditors = (function () {
        function ExtHostEditors(mainContext, extHostDocumentsAndEditors) {
            var _this = this;
            this._onDidChangeTextEditorSelection = new event_1.Emitter();
            this._onDidChangeTextEditorOptions = new event_1.Emitter();
            this._onDidChangeTextEditorViewColumn = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
            this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
            this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadEditors);
            this._extHostDocumentsAndEditors = extHostDocumentsAndEditors;
            this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors(function (e) { return _this._onDidChangeVisibleTextEditors.fire(e); });
            this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor(function (e) { return _this._onDidChangeActiveTextEditor.fire(e); });
        }
        ExtHostEditors.prototype.getActiveTextEditor = function () {
            return this._extHostDocumentsAndEditors.activeEditor();
        };
        ExtHostEditors.prototype.getVisibleTextEditors = function () {
            return this._extHostDocumentsAndEditors.allEditors();
        };
        ExtHostEditors.prototype.showTextDocument = function (document, columnOrOptions, preserveFocus) {
            var _this = this;
            var options;
            if (typeof columnOrOptions === 'number') {
                options = {
                    position: TypeConverters.fromViewColumn(columnOrOptions),
                    preserveFocus: preserveFocus
                };
            }
            else if (typeof columnOrOptions === 'object') {
                options = {
                    position: TypeConverters.fromViewColumn(columnOrOptions.viewColumn),
                    preserveFocus: columnOrOptions.preserveFocus,
                    selection: typeof columnOrOptions.selection === 'object' ? TypeConverters.fromRange(columnOrOptions.selection) : undefined,
                    pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined
                };
            }
            else {
                options = {
                    position: editor_1.Position.ONE,
                    preserveFocus: false
                };
            }
            return this._proxy.$tryShowTextDocument(document.uri, options).then(function (id) {
                var editor = _this._extHostDocumentsAndEditors.getEditor(id);
                if (editor) {
                    return editor;
                }
                else {
                    throw new Error("Failed to show text document " + document.uri.toString() + ", should show in editor #" + id);
                }
            });
        };
        ExtHostEditors.prototype.createTextEditorDecorationType = function (options) {
            return new extHostTextEditor_1.TextEditorDecorationType(this._proxy, options);
        };
        // --- called from main thread
        ExtHostEditors.prototype.$acceptOptionsChanged = function (id, opts) {
            var editor = this._extHostDocumentsAndEditors.getEditor(id);
            editor._acceptOptions(opts);
            this._onDidChangeTextEditorOptions.fire({
                textEditor: editor,
                options: opts
            });
        };
        ExtHostEditors.prototype.$acceptSelectionsChanged = function (id, event) {
            var kind = extHostTypes_1.TextEditorSelectionChangeKind.fromValue(event.source);
            var selections = event.selections.map(TypeConverters.toSelection);
            var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
            textEditor._acceptSelections(selections);
            this._onDidChangeTextEditorSelection.fire({
                textEditor: textEditor,
                selections: selections,
                kind: kind
            });
        };
        ExtHostEditors.prototype.$acceptEditorPositionData = function (data) {
            for (var id in data) {
                var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
                var viewColumn = TypeConverters.toViewColumn(data[id]);
                if (textEditor.viewColumn !== viewColumn) {
                    textEditor._acceptViewColumn(viewColumn);
                    this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor, viewColumn: viewColumn });
                }
            }
        };
        ExtHostEditors.prototype.getDiffInformation = function (id) {
            return async_1.toThenable(this._proxy.$getDiffInformation(id));
        };
        return ExtHostEditors;
    }());
    exports.ExtHostEditors = ExtHostEditors;
});









define(__m[160/*vs/workbench/api/node/extHostWindow*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, event_1, extHost_protocol_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostWindow = (function () {
        function ExtHostWindow(threadService) {
            var _this = this;
            this._onDidChangeWindowState = new event_1.Emitter();
            this.onDidChangeWindowState = this._onDidChangeWindowState.event;
            this._state = ExtHostWindow.InitialState;
            this._proxy = threadService.get(extHost_protocol_1.MainContext.MainThreadWindow);
            this._proxy.$getWindowVisibility().then(function (isFocused) { return _this.$onDidChangeWindowFocus(isFocused); });
        }
        Object.defineProperty(ExtHostWindow.prototype, "state", {
            get: function () { return this._state; },
            enumerable: true,
            configurable: true
        });
        ExtHostWindow.prototype.$onDidChangeWindowFocus = function (focused) {
            if (focused === this._state.focused) {
                return;
            }
            this._state = __assign({}, this._state, { focused: focused });
            this._onDidChangeWindowState.fire(this._state);
        };
        ExtHostWindow.InitialState = {
            focused: true
        };
        return ExtHostWindow;
    }());
    exports.ExtHostWindow = ExtHostWindow;
});











define(__m[161/*vs/workbench/api/node/extHostWorkspace*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,3/*vs/base/common/event*/,13/*vs/base/common/paths*/,15/*vs/base/common/arrays*/,20/*path*/,31/*vs/platform/workspace/common/workspace*/,2/*vs/base/common/winjs.base*/,16/*vs/workbench/api/node/extHostTypeConverters*/,4/*vs/workbench/api/node/extHost.protocol*/,8/*vs/base/common/strings*/,10/*vs/base/common/async*/,5/*vs/workbench/api/node/extHostTypes*/,21/*vs/base/common/map*/,29/*vs/base/common/cancellation*/,50/*vs/platform/progress/common/progress*/]), function (require, exports, uri_1, event_1, paths_1, arrays_1, path_1, workspace_1, winjs_base_1, extHostTypeConverters_1, extHost_protocol_1, strings_1, async_1, extHostTypes_1, map_1, cancellation_1, progress_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Workspace2 = (function (_super) {
        __extends(Workspace2, _super);
        function Workspace2(data) {
            var _this = _super.call(this, data.id, data.name, data.roots) || this;
            _this._folder = [];
            _this._structure = new map_1.TrieMap(function (s) { return s.split('/'); });
            // setup the workspace folder data structure
            _this.roots.forEach(function (uri, index) {
                var folder = {
                    name: path_1.basename(uri.fsPath),
                    uri: uri,
                    index: index
                };
                _this._folder.push(folder);
                _this._structure.insert(folder.uri.toString(), folder);
            });
            return _this;
        }
        Workspace2.fromData = function (data) {
            return data ? new Workspace2(data) : null;
        };
        Object.defineProperty(Workspace2.prototype, "folders", {
            get: function () {
                return this._folder.slice(0);
            },
            enumerable: true,
            configurable: true
        });
        Workspace2.prototype.getWorkspaceFolder = function (uri) {
            var str = uri.toString();
            var folder = this._structure.lookUp(str);
            if (folder) {
                // `uri` is a workspace folder so we
                var parts = str.split('/');
                while (parts.length) {
                    if (parts.pop()) {
                        break;
                    }
                }
                str = parts.join('/');
            }
            return this._structure.findSubstr(str);
        };
        return Workspace2;
    }(workspace_1.Workspace));
    var ExtHostWorkspace = (function () {
        function ExtHostWorkspace(mainContext, data) {
            this._onDidChangeWorkspace = new event_1.Emitter();
            this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
            // --- EXPERIMENT: workspace resolver
            this._handlePool = 0;
            this._fsProvider = new Map();
            this._searchSession = new Map();
            this._proxy = mainContext.get(extHost_protocol_1.MainContext.MainThreadWorkspace);
            this._workspace = Workspace2.fromData(data);
        }
        Object.defineProperty(ExtHostWorkspace.prototype, "workspace", {
            // --- workspace ---
            get: function () {
                return this._workspace;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWorkspace.prototype.getWorkspaceFolders = function () {
            if (!this._workspace) {
                return undefined;
            }
            else {
                return this._workspace.folders.slice(0);
            }
        };
        ExtHostWorkspace.prototype.getWorkspaceFolder = function (uri) {
            if (!this._workspace) {
                return undefined;
            }
            return this._workspace.getWorkspaceFolder(uri);
        };
        ExtHostWorkspace.prototype.getPath = function () {
            // this is legacy from the days before having
            // multi-root and we keep it only alive if there
            // is just one workspace folder.
            if (!this._workspace) {
                return undefined;
            }
            var roots = this._workspace.roots;
            if (roots.length === 0) {
                return undefined;
            }
            return roots[0].fsPath;
        };
        ExtHostWorkspace.prototype.getRelativePath = function (pathOrUri, includeWorkspace) {
            var path;
            if (typeof pathOrUri === 'string') {
                path = pathOrUri;
            }
            else if (typeof pathOrUri !== 'undefined') {
                path = pathOrUri.fsPath;
            }
            if (!path) {
                return path;
            }
            var folder = this.getWorkspaceFolder(typeof pathOrUri === 'string'
                ? uri_1.default.file(pathOrUri)
                : pathOrUri);
            if (!folder) {
                return paths_1.normalize(path);
            }
            if (typeof includeWorkspace === 'undefined') {
                includeWorkspace = this.workspace.roots.length > 1;
            }
            var result = path_1.relative(folder.uri.fsPath, path);
            if (includeWorkspace) {
                result = folder.name + "/" + result;
            }
            return paths_1.normalize(result);
        };
        ExtHostWorkspace.prototype.$acceptWorkspaceData = function (data) {
            // keep old workspace folder, build new workspace, and
            // capture new workspace folders. Compute delta between
            // them send that as event
            var oldRoots = this._workspace ? this._workspace.folders.sort(ExtHostWorkspace._compareWorkspaceFolder) : [];
            this._workspace = Workspace2.fromData(data);
            var newRoots = this._workspace ? this._workspace.folders.sort(ExtHostWorkspace._compareWorkspaceFolder) : [];
            var _a = arrays_1.delta(oldRoots, newRoots, ExtHostWorkspace._compareWorkspaceFolder), added = _a.added, removed = _a.removed;
            // {{SQL CARBON EDIT}} - fix build break  Argument of type 'Readonly<...
            this._onDidChangeWorkspace.fire({
                added: added,
                removed: removed
            });
        };
        ExtHostWorkspace._compareWorkspaceFolder = function (a, b) {
            return strings_1.compare(a.uri.toString(), b.uri.toString());
        };
        // --- search ---
        ExtHostWorkspace.prototype.findFiles = function (include, exclude, maxResults, token) {
            var _this = this;
            var requestId = ExtHostWorkspace._requestIdPool++;
            var result = this._proxy.$startSearch(include, exclude, maxResults, requestId);
            if (token) {
                token.onCancellationRequested(function () { return _this._proxy.$cancelSearch(requestId); });
            }
            return result;
        };
        ExtHostWorkspace.prototype.saveAll = function (includeUntitled) {
            return this._proxy.$saveAll(includeUntitled);
        };
        ExtHostWorkspace.prototype.appyEdit = function (edit) {
            var resourceEdits = [];
            var entries = edit.entries();
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                var uri = entry[0], edits = entry[1];
                for (var _a = 0, edits_1 = edits; _a < edits_1.length; _a++) {
                    var edit_1 = edits_1[_a];
                    resourceEdits.push({
                        resource: uri,
                        newText: edit_1.newText,
                        newEol: extHostTypeConverters_1.EndOfLine.from(edit_1.newEol),
                        range: edit_1.range && extHostTypeConverters_1.fromRange(edit_1.range)
                    });
                }
            }
            return this._proxy.$applyWorkspaceEdit(resourceEdits);
        };
        ExtHostWorkspace.prototype.registerFileSystemProvider = function (authority, provider) {
            var _this = this;
            var handle = ++this._handlePool;
            this._fsProvider.set(handle, provider);
            var reg = provider.onDidChange(function (e) { return _this._proxy.$onFileSystemChange(handle, e); });
            this._proxy.$registerFileSystemProvider(handle, authority);
            return new extHostTypes_1.Disposable(function () {
                _this._fsProvider.delete(handle);
                reg.dispose();
            });
        };
        ExtHostWorkspace.prototype.$resolveFile = function (handle, resource) {
            var provider = this._fsProvider.get(handle);
            return async_1.asWinJsPromise(function (token) { return provider.resolveContents(resource); });
        };
        ExtHostWorkspace.prototype.$storeFile = function (handle, resource, content) {
            var provider = this._fsProvider.get(handle);
            return async_1.asWinJsPromise(function (token) { return provider.writeContents(resource, content); });
        };
        ExtHostWorkspace.prototype.$startSearch = function (handle, session, query) {
            var _this = this;
            var provider = this._fsProvider.get(handle);
            var source = new cancellation_1.CancellationTokenSource();
            var progress = new progress_1.Progress(function (chunk) { return _this._proxy.$updateSearchSession(session, chunk); });
            this._searchSession.set(session, source);
            winjs_base_1.TPromise.wrap(provider.findFiles(query, progress, source.token)).then(function () {
                _this._proxy.$finishSearchSession(session);
            }, function (err) {
                _this._proxy.$finishSearchSession(session, err);
            });
        };
        ExtHostWorkspace.prototype.$cancelSearch = function (handle, session) {
            if (this._searchSession.has(session)) {
                this._searchSession.get(session).cancel();
                this._searchSession.delete(session);
            }
        };
        ExtHostWorkspace._requestIdPool = 0;
        return ExtHostWorkspace;
    }());
    exports.ExtHostWorkspace = ExtHostWorkspace;
});

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[162/*vs/workbench/api/node/extHost.api.impl*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,41/*vs/editor/common/modes/languageSelector*/,9/*vs/base/common/platform*/,12/*vs/base/common/errors*/,100/*vs/platform/node/product*/,99/*vs/platform/node/package*/,113/*vs/workbench/api/node/extHostFileSystemEventService*/,148/*vs/workbench/api/node/extHostDocumentsAndEditors*/,147/*vs/workbench/api/node/extHostDocuments*/,146/*vs/workbench/api/node/extHostDocumentContentProviders*/,129/*vs/workbench/api/node/extHostDocumentSaveParticipant*/,120/*vs/workbench/api/node/extHostConfiguration*/,144/*vs/workbench/api/node/extHostDiagnostics*/,114/*vs/workbench/api/node/extHostTreeViews*/,161/*vs/workbench/api/node/extHostWorkspace*/,153/*vs/workbench/api/node/extHostQuickOpen*/,130/*vs/workbench/api/node/extHostProgress*/,154/*vs/workbench/api/node/extHostSCM*/,109/*vs/workbench/api/node/extHostHeapService*/,155/*vs/workbench/api/node/extHostStatusBar*/,142/*vs/workbench/api/node/extHostCommands*/,152/*vs/workbench/api/node/extHostOutputService*/,158/*vs/workbench/api/node/extHostTerminalService*/,151/*vs/workbench/api/node/extHostMessageService*/,159/*vs/workbench/api/node/extHostTextEditors*/,150/*vs/workbench/api/node/extHostLanguages*/,149/*vs/workbench/api/node/extHostLanguageFeatures*/,128/*vs/workbench/api/node/extHostApiCommands*/,157/*vs/workbench/api/node/extHostTask*/,143/*vs/workbench/api/node/extHostCredentials*/,160/*vs/workbench/api/node/extHostWindow*/,5/*vs/workbench/api/node/extHostTypes*/,6/*vs/base/common/uri*/,25/*vs/base/common/severity*/,23/*vs/editor/common/editorCommon*/,2/*vs/base/common/winjs.base*/,29/*vs/base/common/cancellation*/,13/*vs/base/common/paths*/,4/*vs/workbench/api/node/extHost.protocol*/,24/*vs/editor/common/modes/languageConfiguration*/,82/*vs/editor/common/config/editorOptions*/,145/*vs/workbench/api/node/extHostDialogs*/,27/*vs/base/common/htmlContent*/]), function (require, exports, event_1, languageSelector_1, Platform, errors, product_1, package_1, extHostFileSystemEventService_1, extHostDocumentsAndEditors_1, extHostDocuments_1, extHostDocumentContentProviders_1, extHostDocumentSaveParticipant_1, extHostConfiguration_1, extHostDiagnostics_1, extHostTreeViews_1, extHostWorkspace_1, extHostQuickOpen_1, extHostProgress_1, extHostSCM_1, extHostHeapService_1, extHostStatusBar_1, extHostCommands_1, extHostOutputService_1, extHostTerminalService_1, extHostMessageService_1, extHostTextEditors_1, extHostLanguages_1, extHostLanguageFeatures_1, extHostApiCommands_1, extHostTask_1, extHostCredentials_1, extHostWindow_1, extHostTypes, uri_1, severity_1, EditorCommon, winjs_base_1, cancellation_1, paths, extHost_protocol_1, languageConfiguration, editorOptions_1, extHostDialogs_1, htmlContent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function proposedApiFunction(extension, fn) {
        if (extension.enableProposedApi) {
            return fn;
        }
        else {
            return (function () {
                throw new Error("[" + extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + extension.id);
            });
        }
    }
    /**
     * This method instantiates and returns the extension API surface
     */
    function createApiFactory(initData, threadService, extensionService) {
        var mainThreadTelemetry = threadService.get(extHost_protocol_1.MainContext.MainThreadTelemetry);
        // Addressable instances
        var extHostHeapService = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostHeapService, new extHostHeapService_1.ExtHostHeapService());
        var extHostDocumentsAndEditors = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentsAndEditors, new extHostDocumentsAndEditors_1.ExtHostDocumentsAndEditors(threadService, extensionService));
        var extHostDocuments = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostDocuments, new extHostDocuments_1.ExtHostDocuments(threadService, extHostDocumentsAndEditors));
        var extHostDocumentContentProviders = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentContentProviders, new extHostDocumentContentProviders_1.ExtHostDocumentContentProvider(threadService, extHostDocumentsAndEditors));
        var extHostDocumentSaveParticipant = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentSaveParticipant, new extHostDocumentSaveParticipant_1.ExtHostDocumentSaveParticipant(extHostDocuments, threadService.get(extHost_protocol_1.MainContext.MainThreadWorkspace)));
        var extHostEditors = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostEditors, new extHostTextEditors_1.ExtHostEditors(threadService, extHostDocumentsAndEditors));
        var extHostCommands = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostCommands, new extHostCommands_1.ExtHostCommands(threadService, extHostHeapService));
        var extHostTreeViews = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostTreeViews, new extHostTreeViews_1.ExtHostTreeViews(threadService.get(extHost_protocol_1.MainContext.MainThreadTreeViews), extHostCommands));
        var extHostWorkspace = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostWorkspace, new extHostWorkspace_1.ExtHostWorkspace(threadService, initData.workspace));
        // {{SQL CARBON EDIT}}
        // const extHostDebugService = threadService.set(ExtHostContext.ExtHostDebugService, new ExtHostDebugService(threadService, extHostWorkspace));
        var extHostConfiguration = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostConfiguration, new extHostConfiguration_1.ExtHostConfiguration(threadService.get(extHost_protocol_1.MainContext.MainThreadConfiguration), extHostWorkspace, initData.configuration));
        var extHostDiagnostics = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostDiagnostics, new extHostDiagnostics_1.ExtHostDiagnostics(threadService));
        var languageFeatures = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostLanguageFeatures, new extHostLanguageFeatures_1.ExtHostLanguageFeatures(threadService, extHostDocuments, extHostCommands, extHostHeapService, extHostDiagnostics));
        var extHostFileSystemEvent = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostFileSystemEventService, new extHostFileSystemEventService_1.ExtHostFileSystemEventService());
        var extHostQuickOpen = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostQuickOpen, new extHostQuickOpen_1.ExtHostQuickOpen(threadService));
        var extHostTerminalService = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostTerminalService, new extHostTerminalService_1.ExtHostTerminalService(threadService));
        var extHostSCM = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostSCM, new extHostSCM_1.ExtHostSCM(threadService, extHostCommands));
        var extHostTask = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostTask, new extHostTask_1.ExtHostTask(threadService));
        var extHostCredentials = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostCredentials, new extHostCredentials_1.ExtHostCredentials(threadService));
        var extHostWindow = threadService.set(extHost_protocol_1.ExtHostContext.ExtHostWindow, new extHostWindow_1.ExtHostWindow(threadService));
        threadService.set(extHost_protocol_1.ExtHostContext.ExtHostExtensionService, extensionService);
        // Check that no named customers are missing
        var expected = Object.keys(extHost_protocol_1.ExtHostContext).map(function (key) { return extHost_protocol_1.ExtHostContext[key]; });
        threadService.assertRegistered(expected);
        // Other instances
        var extHostMessageService = new extHostMessageService_1.ExtHostMessageService(threadService);
        var extHostDialogs = new extHostDialogs_1.ExtHostDialogs(threadService);
        var extHostStatusBar = new extHostStatusBar_1.ExtHostStatusBar(threadService);
        var extHostProgress = new extHostProgress_1.ExtHostProgress(threadService.get(extHost_protocol_1.MainContext.MainThreadProgress));
        var extHostOutputService = new extHostOutputService_1.ExtHostOutputService(threadService);
        var extHostLanguages = new extHostLanguages_1.ExtHostLanguages(threadService);
        // Register API-ish commands
        extHostApiCommands_1.ExtHostApiCommands.register(extHostCommands);
        return function (extension) {
            var _this = this;
            if (extension.enableProposedApi && !extension.isBuiltin) {
                if (!initData.environment.enableProposedApiForAll &&
                    initData.environment.enableProposedApiFor.indexOf(extension.id) < 0) {
                    extension.enableProposedApi = false;
                    console.error("Extension '" + extension.id + " cannot use PROPOSED API (must started out of dev or enabled via --enable-proposed-api)");
                }
                else {
                    // proposed api is available when developing or when an extension was explicitly
                    // spelled out via a command line argument
                    console.warn("Extension '" + extension.id + "' uses PROPOSED API which is subject to change and removal without notice.");
                }
            }
            var apiUsage = new (function () {
                function class_1() {
                    this._seen = new Set();
                }
                class_1.prototype.publicLog = function (apiName) {
                    if (this._seen.has(apiName)) {
                        return undefined;
                    }
                    this._seen.add(apiName);
                    return mainThreadTelemetry.$publicLog('apiUsage', {
                        name: apiName,
                        extension: extension.id
                    });
                };
                return class_1;
            }());
            // namespace: commands
            var commands = {
                registerCommand: function (id, command, thisArgs) {
                    return extHostCommands.registerCommand(id, command, thisArgs);
                },
                registerTextEditorCommand: function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var activeTextEditor = extHostEditors.getActiveTextEditor();
                        if (!activeTextEditor) {
                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return undefined;
                        }
                        return activeTextEditor.edit(function (edit) {
                            args.unshift(activeTextEditor, edit);
                            callback.apply(thisArg, args);
                        }).then(function (result) {
                            if (!result) {
                                console.warn('Edits from command ' + id + ' were not applied.');
                            }
                        }, function (err) {
                            console.warn('An error occurred while running command ' + id, err);
                        });
                    });
                },
                registerDiffInformationCommand: proposedApiFunction(extension, function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return __awaiter(_this, void 0, void 0, function () {
                            var activeTextEditor, diff;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        activeTextEditor = extHostEditors.getActiveTextEditor();
                                        if (!activeTextEditor) {
                                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                                            return [2 /*return*/, undefined];
                                        }
                                        return [4 /*yield*/, extHostEditors.getDiffInformation(activeTextEditor.id)];
                                    case 1:
                                        diff = _a.sent();
                                        callback.apply(thisArg, [diff].concat(args));
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                }),
                executeCommand: function (id) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return extHostCommands.executeCommand.apply(extHostCommands, [id].concat(args));
                },
                getCommands: function (filterInternal) {
                    if (filterInternal === void 0) { filterInternal = false; }
                    return extHostCommands.getCommands(filterInternal);
                }
            };
            // namespace: env
            var env = Object.freeze({
                get machineId() { return initData.telemetryInfo.machineId; },
                get sessionId() { return initData.telemetryInfo.sessionId; },
                get language() { return Platform.language; },
                get appName() { return product_1.default.nameLong; },
                get appRoot() { return initData.environment.appRoot; },
            });
            // namespace: extensions
            var extensions = {
                getExtension: function (extensionId) {
                    var desc = extensionService.getExtensionDescription(extensionId);
                    if (desc) {
                        return new Extension(extensionService, desc);
                    }
                    return undefined;
                },
                get all() {
                    return extensionService.getAllExtensionDescriptions().map(function (desc) { return new Extension(extensionService, desc); });
                }
            };
            // namespace: languages
            var languages = {
                createDiagnosticCollection: function (name) {
                    return extHostDiagnostics.createDiagnosticCollection(name);
                },
                getLanguages: function () {
                    return extHostLanguages.getLanguages();
                },
                match: function (selector, document) {
                    return languageSelector_1.score(selector, document.uri, document.languageId);
                },
                registerCodeActionsProvider: function (selector, provider) {
                    return languageFeatures.registerCodeActionProvider(selector, provider);
                },
                registerCodeLensProvider: function (selector, provider) {
                    return languageFeatures.registerCodeLensProvider(selector, provider);
                },
                registerDefinitionProvider: function (selector, provider) {
                    return languageFeatures.registerDefinitionProvider(selector, provider);
                },
                registerImplementationProvider: function (selector, provider) {
                    return languageFeatures.registerImplementationProvider(selector, provider);
                },
                registerTypeDefinitionProvider: function (selector, provider) {
                    return languageFeatures.registerTypeDefinitionProvider(selector, provider);
                },
                registerHoverProvider: function (selector, provider) {
                    return languageFeatures.registerHoverProvider(selector, provider, extension.id);
                },
                registerDocumentHighlightProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentHighlightProvider(selector, provider);
                },
                registerReferenceProvider: function (selector, provider) {
                    return languageFeatures.registerReferenceProvider(selector, provider);
                },
                registerRenameProvider: function (selector, provider) {
                    return languageFeatures.registerRenameProvider(selector, provider);
                },
                registerDocumentSymbolProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentSymbolProvider(selector, provider);
                },
                registerWorkspaceSymbolProvider: function (provider) {
                    return languageFeatures.registerWorkspaceSymbolProvider(provider);
                },
                registerDocumentFormattingEditProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentFormattingEditProvider(selector, provider);
                },
                registerDocumentRangeFormattingEditProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentRangeFormattingEditProvider(selector, provider);
                },
                registerOnTypeFormattingEditProvider: function (selector, provider, firstTriggerCharacter) {
                    var moreTriggerCharacters = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        moreTriggerCharacters[_i - 3] = arguments[_i];
                    }
                    return languageFeatures.registerOnTypeFormattingEditProvider(selector, provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
                },
                registerSignatureHelpProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return languageFeatures.registerSignatureHelpProvider(selector, provider, triggerCharacters);
                },
                registerCompletionItemProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return languageFeatures.registerCompletionItemProvider(selector, provider, triggerCharacters);
                },
                registerDocumentLinkProvider: function (selector, provider) {
                    return languageFeatures.registerDocumentLinkProvider(selector, provider);
                },
                setLanguageConfiguration: function (language, configuration) {
                    return languageFeatures.setLanguageConfiguration(language, configuration);
                },
                // proposed API
                registerColorProvider: proposedApiFunction(extension, function (selector, provider) {
                    return languageFeatures.registerColorProvider(selector, provider);
                })
            };
            // namespace: window
            var window = {
                get activeTextEditor() {
                    return extHostEditors.getActiveTextEditor();
                },
                get visibleTextEditors() {
                    return extHostEditors.getVisibleTextEditors();
                },
                showTextDocument: function (documentOrUri, columnOrOptions, preserveFocus) {
                    var documentPromise;
                    if (uri_1.default.isUri(documentOrUri)) {
                        documentPromise = winjs_base_1.TPromise.wrap(workspace.openTextDocument(documentOrUri));
                    }
                    else {
                        documentPromise = winjs_base_1.TPromise.wrap(documentOrUri);
                    }
                    return documentPromise.then(function (document) {
                        return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
                    });
                },
                createTextEditorDecorationType: function (options) {
                    return extHostEditors.createTextEditorDecorationType(options);
                },
                onDidChangeActiveTextEditor: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
                },
                onDidChangeVisibleTextEditors: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
                },
                onDidChangeTextEditorSelection: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorOptions: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorViewColumn: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
                },
                onDidCloseTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidCloseTerminal(listener, thisArg, disposables);
                },
                get state() {
                    return extHostWindow.state;
                },
                onDidChangeWindowState: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostWindow.onDidChangeWindowState(listener, thisArg, disposables);
                }),
                showInformationMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, message, first, rest);
                },
                showWarningMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Warning, message, first, rest);
                },
                showErrorMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Error, message, first, rest);
                },
                showQuickPick: function (items, options, token) {
                    return extHostQuickOpen.showQuickPick(items, options, token);
                },
                showInputBox: function (options, token) {
                    return extHostQuickOpen.showInput(options, token);
                },
                createStatusBarItem: function (position, priority) {
                    return extHostStatusBar.createStatusBarEntry(extension.id, position, priority);
                },
                setStatusBarMessage: function (text, timeoutOrThenable) {
                    return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
                },
                withScmProgress: function (task) {
                    console.warn("[Deprecation Warning] function 'withScmProgress' is deprecated and should no longer be used. Use 'withProgress' instead.");
                    return extHostProgress.withProgress(extension, { location: extHostTypes.ProgressLocation.SourceControl }, function (progress, token) { return task({ report: function (n) { } }); });
                },
                withProgress: function (options, task) {
                    return extHostProgress.withProgress(extension, options, task);
                },
                createOutputChannel: function (name) {
                    return extHostOutputService.createOutputChannel(name);
                },
                createTerminal: function (nameOrOptions, shellPath, shellArgs) {
                    if (typeof nameOrOptions === 'object') {
                        return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
                    }
                    return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
                },
                registerTreeDataProvider: function (viewId, treeDataProvider) {
                    return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider);
                },
                // proposed API
                sampleFunction: proposedApiFunction(extension, function () {
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, 'Hello Proposed Api!', {}, []);
                }),
                showOpenDialog: proposedApiFunction(extension, function (options) {
                    return extHostDialogs.showOpenDialog(options);
                })
            };
            // namespace: workspace
            var workspace = {
                get rootPath() {
                    apiUsage.publicLog('workspace#rootPath');
                    return extHostWorkspace.getPath();
                },
                set rootPath(value) {
                    throw errors.readonly();
                },
                getWorkspaceFolder: function (resource) {
                    return extHostWorkspace.getWorkspaceFolder(resource);
                },
                get workspaceFolders() {
                    apiUsage.publicLog('workspace#workspaceFolders');
                    return extHostWorkspace.getWorkspaceFolders();
                },
                onDidChangeWorkspaceFolders: function (listener, thisArgs, disposables) {
                    apiUsage.publicLog('workspace#onDidChangeWorkspaceFolders');
                    return extHostWorkspace.onDidChangeWorkspace(listener, thisArgs, disposables);
                },
                asRelativePath: function (pathOrUri, includeWorkspace) {
                    return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
                },
                findFiles: function (include, exclude, maxResults, token) {
                    return extHostWorkspace.findFiles(include, exclude, maxResults, token);
                },
                saveAll: function (includeUntitled) {
                    return extHostWorkspace.saveAll(includeUntitled);
                },
                applyEdit: function (edit) {
                    return extHostWorkspace.appyEdit(edit);
                },
                createFileSystemWatcher: function (pattern, ignoreCreate, ignoreChange, ignoreDelete) {
                    return extHostFileSystemEvent.createFileSystemWatcher(pattern, ignoreCreate, ignoreChange, ignoreDelete);
                },
                get textDocuments() {
                    return extHostDocuments.getAllDocumentData().map(function (data) { return data.document; });
                },
                set textDocuments(value) {
                    throw errors.readonly();
                },
                openTextDocument: function (uriOrFileNameOrOptions) {
                    var uriPromise;
                    var options = uriOrFileNameOrOptions;
                    if (!options || typeof options.language === 'string') {
                        uriPromise = extHostDocuments.createDocumentData(options);
                    }
                    else if (typeof uriOrFileNameOrOptions === 'string') {
                        uriPromise = winjs_base_1.TPromise.as(uri_1.default.file(uriOrFileNameOrOptions));
                    }
                    else if (uriOrFileNameOrOptions instanceof uri_1.default) {
                        uriPromise = winjs_base_1.TPromise.as(uriOrFileNameOrOptions);
                    }
                    else {
                        throw new Error('illegal argument - uriOrFileNameOrOptions');
                    }
                    return uriPromise.then(function (uri) {
                        return extHostDocuments.ensureDocumentData(uri).then(function () {
                            var data = extHostDocuments.getDocumentData(uri);
                            return data && data.document;
                        });
                    });
                },
                onDidOpenTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidAddDocument(listener, thisArgs, disposables);
                },
                onDidCloseTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidRemoveDocument(listener, thisArgs, disposables);
                },
                onDidChangeTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidChangeDocument(listener, thisArgs, disposables);
                },
                onDidSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidSaveDocument(listener, thisArgs, disposables);
                },
                onWillSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocumentSaveParticipant.onWillSaveTextDocumentEvent(listener, thisArgs, disposables);
                },
                onDidChangeConfiguration: function (listener, thisArgs, disposables) {
                    return extHostConfiguration.onDidChangeConfiguration(listener, thisArgs, disposables);
                },
                getConfiguration: function (section, resource) {
                    return extHostConfiguration.getConfiguration(section, resource);
                },
                registerTextDocumentContentProvider: function (scheme, provider) {
                    return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
                },
                registerTaskProvider: function (type, provider) {
                    return extHostTask.registerTaskProvider(extension, provider);
                },
                registerFileSystemProvider: proposedApiFunction(extension, function (authority, provider) {
                    return extHostWorkspace.registerFileSystemProvider(authority, provider);
                })
            };
            // namespace: scm
            var scm = {
                get inputBox() {
                    return extHostSCM.getLastInputBox(extension);
                },
                createSourceControl: function (id, label) {
                    mainThreadTelemetry.$publicLog('registerSCMProvider', {
                        extensionId: extension.id,
                        providerId: id,
                        providerLabel: label
                    });
                    return extHostSCM.createSourceControl(extension, id, label);
                }
            };
            // {{SQL CARBON EDIT}}
            // delete namespace: debug
            // namespace: credentials
            var credentials = {
                readSecret: function (service, account) {
                    return extHostCredentials.readSecret(service, account);
                },
                writeSecret: function (service, account, secret) {
                    return extHostCredentials.writeSecret(service, account, secret);
                },
                deleteSecret: function (service, account) {
                    return extHostCredentials.deleteSecret(service, account);
                }
            };
            var api = {
                version: package_1.default.version,
                // namespaces
                commands: commands,
                env: env,
                extensions: extensions,
                languages: languages,
                window: window,
                workspace: workspace,
                scm: scm,
                // {{SQL CARBON EDIT}}
                // debug,
                // types
                CancellationTokenSource: cancellation_1.CancellationTokenSource,
                CodeLens: extHostTypes.CodeLens,
                Color: extHostTypes.Color,
                ColorRange: extHostTypes.ColorRange,
                EndOfLine: extHostTypes.EndOfLine,
                CompletionItem: extHostTypes.CompletionItem,
                CompletionItemKind: extHostTypes.CompletionItemKind,
                CompletionList: extHostTypes.CompletionList,
                Diagnostic: extHostTypes.Diagnostic,
                DiagnosticSeverity: extHostTypes.DiagnosticSeverity,
                Disposable: extHostTypes.Disposable,
                DocumentHighlight: extHostTypes.DocumentHighlight,
                DocumentHighlightKind: extHostTypes.DocumentHighlightKind,
                DocumentLink: extHostTypes.DocumentLink,
                EventEmitter: event_1.Emitter,
                Hover: extHostTypes.Hover,
                IndentAction: languageConfiguration.IndentAction,
                Location: extHostTypes.Location,
                MarkdownString: htmlContent_1.MarkdownString,
                OverviewRulerLane: EditorCommon.OverviewRulerLane,
                ParameterInformation: extHostTypes.ParameterInformation,
                Position: extHostTypes.Position,
                Range: extHostTypes.Range,
                Selection: extHostTypes.Selection,
                SignatureHelp: extHostTypes.SignatureHelp,
                SignatureInformation: extHostTypes.SignatureInformation,
                SnippetString: extHostTypes.SnippetString,
                StatusBarAlignment: extHostTypes.StatusBarAlignment,
                SymbolInformation: extHostTypes.SymbolInformation,
                SymbolKind: extHostTypes.SymbolKind,
                TextDocumentSaveReason: extHostTypes.TextDocumentSaveReason,
                TextEdit: extHostTypes.TextEdit,
                TextEditorCursorStyle: editorOptions_1.TextEditorCursorStyle,
                TextEditorLineNumbersStyle: extHostTypes.TextEditorLineNumbersStyle,
                TextEditorRevealType: extHostTypes.TextEditorRevealType,
                TextEditorSelectionChangeKind: extHostTypes.TextEditorSelectionChangeKind,
                DecorationRangeBehavior: extHostTypes.DecorationRangeBehavior,
                Uri: uri_1.default,
                ViewColumn: extHostTypes.ViewColumn,
                WorkspaceEdit: extHostTypes.WorkspaceEdit,
                ProgressLocation: extHostTypes.ProgressLocation,
                TreeItemCollapsibleState: extHostTypes.TreeItemCollapsibleState,
                TreeItem: extHostTypes.TreeItem,
                ThemeColor: extHostTypes.ThemeColor,
                // functions
                TaskRevealKind: extHostTypes.TaskRevealKind,
                TaskPanelKind: extHostTypes.TaskPanelKind,
                TaskGroup: extHostTypes.TaskGroup,
                ProcessExecution: extHostTypes.ProcessExecution,
                ShellExecution: extHostTypes.ShellExecution,
                Task: extHostTypes.Task,
                ConfigurationTarget: extHostTypes.ConfigurationTarget
            };
            if (extension.enableProposedApi && extension.isBuiltin) {
                api['credentials'] = credentials;
            }
            return api;
        };
    }
    exports.createApiFactory = createApiFactory;
    var Extension = (function () {
        function Extension(extensionService, description) {
            this._extensionService = extensionService;
            this.id = description.id;
            this.extensionPath = paths.normalize(description.extensionFolderPath, true);
            this.packageJSON = description;
        }
        Object.defineProperty(Extension.prototype, "isActive", {
            get: function () {
                return this._extensionService.isActivated(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Extension.prototype, "exports", {
            get: function () {
                return this._extensionService.getExtensionExports(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Extension.prototype.activate = function () {
            var _this = this;
            return this._extensionService.activateById(this.id, false).then(function () { return _this.exports; });
        };
        return Extension;
    }());
    function initializeExtensionApi(extensionService, apiFactory) {
        return extensionService.getExtensionPathIndex().then(function (trie) { return defineAPI(apiFactory, trie); });
    }
    exports.initializeExtensionApi = initializeExtensionApi;
    function defineAPI(factory, extensionPaths) {
        // each extension is meant to get its own api implementation
        var extApiImpl = new Map();
        var defaultApiImpl;
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        node_module._load = function load(request, parent, isMain) {
            if (request !== 'vscode') {
                return original.apply(this, arguments);
            }
            // get extension id from filename and api for extension
            var ext = extensionPaths.findSubstr(parent.filename);
            if (ext) {
                var apiImpl = extApiImpl.get(ext.id);
                if (!apiImpl) {
                    apiImpl = factory(ext);
                    extApiImpl.set(ext.id, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!defaultApiImpl) {
                defaultApiImpl = factory(nullExtensionDescription);
            }
            return defaultApiImpl;
        };
    }
    var nullExtensionDescription = {
        id: 'nullExtensionDescription',
        name: 'Null Extension Description',
        publisher: 'vscode',
        activationEvents: undefined,
        contributes: undefined,
        enableProposedApi: false,
        engines: undefined,
        extensionDependencies: undefined,
        extensionFolderPath: undefined,
        isBuiltin: false,
        main: undefined,
        version: undefined
    };
});

define(__m[163/*sql/workbench/api/node/sqlExtHost.api.impl*/], __M([1/*require*/,0/*exports*/,162/*vs/workbench/api/node/extHost.api.impl*/,21/*vs/base/common/map*/,2/*vs/base/common/winjs.base*/,32/*fs*/,22/*sql/workbench/api/node/sqlExtHost.protocol*/,136/*sql/workbench/api/node/extHostAccountManagement*/,137/*sql/workbench/api/node/extHostCredentialManagement*/,138/*sql/workbench/api/node/extHostDataProtocol*/,140/*sql/workbench/api/node/extHostSerializationProvider*/,139/*sql/workbench/api/node/extHostResourceProvider*/,115/*sql/workbench/api/node/sqlExtHostTypes*/]), function (require, exports, extHostApi, map_1, winjs_base_1, fs_1, sqlExtHost_protocol_1, extHostAccountManagement_1, extHostCredentialManagement_1, extHostDataProtocol_1, extHostSerializationProvider_1, extHostResourceProvider_1, sqlExtHostTypes) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This method instantiates and returns the extension API surface. This overrides the default ApiFactory by extending it to add Carbon-related functions
     */
    function createApiFactory(initData, threadService, extensionService) {
        var vsCodeFactory = extHostApi.createApiFactory(initData, threadService, extensionService);
        // Addressable instances
        var extHostAccountManagement = threadService.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostAccountManagement, new extHostAccountManagement_1.ExtHostAccountManagement(threadService));
        var extHostCredentialManagement = threadService.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostCredentialManagement, new extHostCredentialManagement_1.ExtHostCredentialManagement(threadService));
        var extHostDataProvider = threadService.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostDataProtocol, new extHostDataProtocol_1.ExtHostDataProtocol(threadService));
        var extHostSerializationProvider = threadService.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostSerializationProvider, new extHostSerializationProvider_1.ExtHostSerializationProvider(threadService));
        var extHostResourceProvider = threadService.set(sqlExtHost_protocol_1.SqlExtHostContext.ExtHostResourceProvider, new extHostResourceProvider_1.ExtHostResourceProvider(threadService));
        return {
            vsCodeFactory: vsCodeFactory,
            dataFactory: function (extension) {
                // namespace: accounts
                var accounts = {
                    performOAuthAuthorization: function (url, silent) {
                        return extHostAccountManagement.$performOAuthAuthorization(url, silent);
                    },
                    registerAccountProvider: function (providerMetadata, provider) {
                        return extHostAccountManagement.$registerAccountProvider(providerMetadata, provider);
                    },
                };
                // namespace: credentials
                var credentials = {
                    registerProvider: function (provider) {
                        return extHostCredentialManagement.$registerCredentialProvider(provider);
                    },
                    getProvider: function (namespaceId) {
                        return extHostCredentialManagement.$getCredentialProvider(namespaceId);
                    }
                };
                // namespace: serialization
                var serialization = {
                    registerProvider: function (provider) {
                        return extHostSerializationProvider.$registerSerializationProvider(provider);
                    },
                };
                // namespace: serialization
                var resources = {
                    registerResourceProvider: function (providerMetadata, provider) {
                        return extHostResourceProvider.$registerResourceProvider(providerMetadata, provider);
                    }
                };
                // namespace: dataprotocol
                var dataprotocol = {
                    registerProvider: function (provider) {
                        // Connection callbacks
                        provider.connectionProvider.registerOnConnectionComplete(function (connSummary) {
                            extHostDataProvider.$onConnectComplete(provider.handle, connSummary);
                        });
                        provider.connectionProvider.registerOnIntelliSenseCacheComplete(function (connectionUri) {
                            extHostDataProvider.$onIntelliSenseCacheComplete(provider.handle, connectionUri);
                        });
                        provider.connectionProvider.registerOnConnectionChanged(function (changedConnInfo) {
                            extHostDataProvider.$onConnectionChanged(provider.handle, changedConnInfo);
                        });
                        // Query callbacks
                        provider.queryProvider.registerOnQueryComplete(function (result) {
                            extHostDataProvider.$onQueryComplete(provider.handle, result);
                        });
                        provider.queryProvider.registerOnBatchStart(function (batchInfo) {
                            extHostDataProvider.$onBatchStart(provider.handle, batchInfo);
                        });
                        provider.queryProvider.registerOnBatchComplete(function (batchInfo) {
                            extHostDataProvider.$onBatchComplete(provider.handle, batchInfo);
                        });
                        provider.queryProvider.registerOnResultSetComplete(function (resultSetInfo) {
                            extHostDataProvider.$onResultSetComplete(provider.handle, resultSetInfo);
                        });
                        provider.queryProvider.registerOnMessage(function (message) {
                            extHostDataProvider.$onQueryMessage(provider.handle, message);
                        });
                        //OE callbacks
                        provider.objectExplorerProvider.registerOnSessionCreated(function (response) {
                            extHostDataProvider.$onObjectExplorerSessionCreated(provider.handle, response);
                        });
                        provider.objectExplorerProvider.registerOnExpandCompleted(function (response) {
                            extHostDataProvider.$onObjectExplorerNodeExpanded(provider.handle, response);
                        });
                        //Tasks callbacks
                        provider.taskServicesProvider.registerOnTaskCreated(function (response) {
                            extHostDataProvider.$onTaskCreated(provider.handle, response);
                        });
                        provider.taskServicesProvider.registerOnTaskStatusChanged(function (response) {
                            extHostDataProvider.$onTaskStatusChanged(provider.handle, response);
                        });
                        // Edit Data callbacks
                        provider.queryProvider.registerOnEditSessionReady(function (ownerUri, success, message) {
                            extHostDataProvider.$onEditSessionReady(provider.handle, ownerUri, success, message);
                        });
                        // File browser callbacks
                        provider.fileBrowserProvider.registerOnFileBrowserOpened(function (response) {
                            extHostDataProvider.$onFileBrowserOpened(provider.handle, response);
                        });
                        provider.fileBrowserProvider.registerOnFolderNodeExpanded(function (response) {
                            extHostDataProvider.$onFolderNodeExpanded(provider.handle, response);
                        });
                        provider.fileBrowserProvider.registerOnFilePathsValidated(function (response) {
                            extHostDataProvider.$onFilePathsValidated(provider.handle, response);
                        });
                        // Scripting callbacks
                        provider.scriptingProvider.registerOnScriptingComplete(function (response) {
                            extHostDataProvider.$onScriptingComplete(provider.handle, response);
                        });
                        // Complete registration
                        return extHostDataProvider.$registerProvider(provider);
                    },
                    onDidChangeLanguageFlavor: function (listener, thisArgs, disposables) {
                        return extHostDataProvider.onDidChangeLanguageFlavor(listener, thisArgs, disposables);
                    }
                };
                return {
                    accounts: accounts,
                    credentials: credentials,
                    resources: resources,
                    serialization: serialization,
                    dataprotocol: dataprotocol,
                    ServiceOptionType: sqlExtHostTypes.ServiceOptionType,
                    ConnectionOptionSpecialType: sqlExtHostTypes.ConnectionOptionSpecialType,
                    EditRowState: sqlExtHostTypes.EditRowState,
                    MetadataType: sqlExtHostTypes.MetadataType,
                    TaskStatus: sqlExtHostTypes.TaskStatus,
                    TaskExecutionMode: sqlExtHostTypes.TaskExecutionMode
                };
            }
        };
    }
    exports.createApiFactory = createApiFactory;
    function initializeExtensionApi(extensionService, apiFactory) {
        return createExtensionPathIndex(extensionService).then(function (trie) { return defineAPI(apiFactory, trie); });
    }
    exports.initializeExtensionApi = initializeExtensionApi;
    function createExtensionPathIndex(extensionService) {
        // create trie to enable fast 'filename -> extension id' look up
        var trie = new map_1.TrieMap(map_1.TrieMap.PathSplitter);
        var extensions = extensionService.getAllExtensionDescriptions().map(function (ext) {
            if (!ext.main) {
                return undefined;
            }
            return new winjs_base_1.TPromise(function (resolve, reject) {
                fs_1.realpath(ext.extensionFolderPath, function (err, path) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        trie.insert(path, ext);
                        resolve(void 0);
                    }
                });
            });
        });
        return winjs_base_1.TPromise.join(extensions).then(function () { return trie; });
    }
    function defineAPI(factory, extensionPaths) {
        // each extension is meant to get its own api implementation
        var extApiImpl = new Map();
        var dataExtApiImpl = new Map();
        var defaultApiImpl;
        var defaultDataApiImpl;
        // The module factory looks for an entry in the API map for an extension. If found, it reuses this.
        // If not, it loads it & saves it in the map
        var getModuleFactory = function (apiMap, createApi, defaultImpl, setDefaultApiImpl, parent) {
            // get extension id from filename and api for extension
            var ext = extensionPaths.findSubstr(parent.filename);
            if (ext) {
                var apiImpl = apiMap.get(ext.id);
                if (!apiImpl) {
                    apiImpl = createApi(ext);
                    apiMap.set(ext.id, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!defaultImpl) {
                defaultImpl = createApi(nullExtensionDescription);
                setDefaultApiImpl(defaultImpl);
            }
            return defaultImpl;
        };
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        // TODO look into de-duplicating this code
        node_module._load = function load(request, parent, isMain) {
            if (request === 'vscode') {
                return getModuleFactory(extApiImpl, function (ext) { return factory.vsCodeFactory(ext); }, defaultApiImpl, function (impl) { return defaultApiImpl = impl; }, parent);
            }
            else if (request === 'data') {
                return getModuleFactory(dataExtApiImpl, function (ext) { return factory.dataFactory(ext); }, defaultDataApiImpl, function (impl) { return defaultDataApiImpl = impl; }, parent);
            }
            else {
                // Allow standard node_module load to occur
                return original.apply(this, arguments);
            }
        };
    }
    var nullExtensionDescription = {
        id: 'nullExtensionDescription',
        name: 'Null Extension Description',
        publisher: 'vscode',
        activationEvents: undefined,
        contributes: undefined,
        enableProposedApi: false,
        engines: undefined,
        extensionDependencies: undefined,
        extensionFolderPath: undefined,
        isBuiltin: false,
        main: undefined,
        version: undefined
    };
});

define(__m[164/*vs/workbench/api/node/extHostExtensionService*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/lifecycle*/,20/*path*/,47/*vs/base/node/pfs*/,25/*vs/base/common/severity*/,2/*vs/base/common/winjs.base*/,122/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/,156/*vs/workbench/api/node/extHostStorage*/,163/*sql/workbench/api/node/sqlExtHost.api.impl*/,4/*vs/workbench/api/node/extHost.protocol*/,108/*vs/workbench/api/node/extHostExtensionActivator*/,121/*vs/workbench/services/extensions/node/barrier*/,32/*fs*/,21/*vs/base/common/map*/]), function (require, exports, lifecycle_1, path_1, pfs_1, severity_1, winjs_base_1, extensionDescriptionRegistry_1, extHostStorage_1, sqlExtHost_api_impl_1, extHost_protocol_1, extHostExtensionActivator_1, barrier_1, fs_1, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtensionMemento = (function () {
        function ExtensionMemento(id, global, storage) {
            var _this = this;
            this._id = id;
            this._shared = global;
            this._storage = storage;
            this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(function (value) {
                _this._value = value;
                return _this;
            });
        }
        Object.defineProperty(ExtensionMemento.prototype, "whenReady", {
            get: function () {
                return this._init;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionMemento.prototype.get = function (key, defaultValue) {
            var value = this._value[key];
            if (typeof value === 'undefined') {
                value = defaultValue;
            }
            return value;
        };
        ExtensionMemento.prototype.update = function (key, value) {
            this._value[key] = value;
            return this._storage
                .setValue(this._shared, this._id, this._value)
                .then(function () { return true; });
        };
        return ExtensionMemento;
    }());
    var ExtensionStoragePath = (function () {
        function ExtensionStoragePath(workspace, environment) {
            var _this = this;
            this._workspace = workspace;
            this._environment = environment;
            this._ready = this._getOrCreateWorkspaceStoragePath().then(function (value) { return _this._value = value; });
        }
        Object.defineProperty(ExtensionStoragePath.prototype, "whenReady", {
            get: function () {
                return this._ready;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionStoragePath.prototype.value = function (extension) {
            if (this._value) {
                return path_1.join(this._value, extension.id);
            }
            return undefined;
        };
        ExtensionStoragePath.prototype._getOrCreateWorkspaceStoragePath = function () {
            if (!this._workspace) {
                return winjs_base_1.TPromise.as(undefined);
            }
            var storageName = this._workspace.id;
            var storagePath = path_1.join(this._environment.appSettingsHome, 'workspaceStorage', storageName);
            return pfs_1.dirExists(storagePath).then(function (exists) {
                if (exists) {
                    return storagePath;
                }
                return pfs_1.mkdirp(storagePath).then(function (success) {
                    return storagePath;
                }, function (err) {
                    return undefined;
                });
            });
        };
        return ExtensionStoragePath;
    }());
    var ExtHostExtensionService = (function () {
        /**
         * This class is constructed manually because it is a service, so it doesn't use any ctor injection
         */
        function ExtHostExtensionService(initData, threadService) {
            var _this = this;
            this._barrier = new barrier_1.Barrier();
            this._registry = new extensionDescriptionRegistry_1.ExtensionDescriptionRegistry(initData.extensions);
            this._threadService = threadService;
            this._mainThreadTelemetry = threadService.get(extHost_protocol_1.MainContext.MainThreadTelemetry);
            this._storage = new extHostStorage_1.ExtHostStorage(threadService);
            this._storagePath = new ExtensionStoragePath(initData.workspace, initData.environment);
            this._proxy = this._threadService.get(extHost_protocol_1.MainContext.MainThreadExtensionService);
            this._activator = null;
            // initialize API first (i.e. do not release barrier until the API is initialized)
            var apiFactory = sqlExtHost_api_impl_1.createApiFactory(initData, threadService, this);
            sqlExtHost_api_impl_1.initializeExtensionApi(this, apiFactory).then(function () {
                _this._activator = new extHostExtensionActivator_1.ExtensionsActivator(_this._registry, {
                    showMessage: function (severity, message) {
                        _this._proxy.$localShowMessage(severity, message);
                        switch (severity) {
                            case severity_1.default.Error:
                                console.error(message);
                                break;
                            case severity_1.default.Warning:
                                console.warn(message);
                                break;
                            default:
                                console.log(message);
                        }
                    },
                    actualActivateExtension: function (extensionDescription, startup) {
                        return _this._activateExtension(extensionDescription, startup);
                    }
                });
                _this._barrier.open();
            });
        }
        ExtHostExtensionService.prototype.onExtensionAPIReady = function () {
            return this._barrier.wait();
        };
        ExtHostExtensionService.prototype.isActivated = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.isActivated(extensionId);
            }
            return false;
        };
        ExtHostExtensionService.prototype.activateByEvent = function (activationEvent, startup) {
            var _this = this;
            if (this._barrier.isOpen()) {
                return this._activator.activateByEvent(activationEvent, startup);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateByEvent(activationEvent, startup); });
            }
        };
        ExtHostExtensionService.prototype.activateById = function (extensionId, startup) {
            var _this = this;
            if (this._barrier.isOpen()) {
                return this._activator.activateById(extensionId, startup);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateById(extensionId, startup); });
            }
        };
        ExtHostExtensionService.prototype.getAllExtensionDescriptions = function () {
            return this._registry.getAllExtensionDescriptions();
        };
        ExtHostExtensionService.prototype.getExtensionDescription = function (extensionId) {
            return this._registry.getExtensionDescription(extensionId);
        };
        ExtHostExtensionService.prototype.getExtensionExports = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.getActivatedExtension(extensionId).exports;
            }
            else {
                return null;
            }
        };
        // create trie to enable fast 'filename -> extension id' look up
        ExtHostExtensionService.prototype.getExtensionPathIndex = function () {
            if (!this._extensionPathIndex) {
                var trie_1 = new map_1.TrieMap();
                var extensions = this.getAllExtensionDescriptions().map(function (ext) {
                    if (!ext.main) {
                        return undefined;
                    }
                    return new winjs_base_1.TPromise(function (resolve, reject) {
                        fs_1.realpath(ext.extensionFolderPath, function (err, path) {
                            if (err) {
                                reject(err);
                            }
                            else {
                                trie_1.insert(path, ext);
                                resolve(void 0);
                            }
                        });
                    });
                });
                this._extensionPathIndex = winjs_base_1.TPromise.join(extensions).then(function () { return trie_1; });
            }
            return this._extensionPathIndex;
        };
        ExtHostExtensionService.prototype.deactivate = function (extensionId) {
            var result = winjs_base_1.TPromise.as(void 0);
            if (!this._barrier.isOpen()) {
                return result;
            }
            if (!this._activator.isActivated(extensionId)) {
                return result;
            }
            var extension = this._activator.getActivatedExtension(extensionId);
            if (!extension) {
                return result;
            }
            // call deactivate if available
            try {
                if (typeof extension.module.deactivate === 'function') {
                    result = winjs_base_1.TPromise.wrap(extension.module.deactivate()).then(null, function (err) {
                        // TODO: Do something with err if this is not the shutdown case
                        return winjs_base_1.TPromise.as(void 0);
                    });
                }
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            // clean up subscriptions
            try {
                lifecycle_1.dispose(extension.subscriptions);
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            return result;
        };
        // --- impl
        ExtHostExtensionService.prototype._activateExtension = function (extensionDescription, startup) {
            var _this = this;
            return this._doActivateExtension(extensionDescription, startup).then(function (activatedExtension) {
                var activationTimes = activatedExtension.activationTimes;
                _this._proxy.$onExtensionActivated(extensionDescription.id, activationTimes.startup, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime);
                return activatedExtension;
            }, function (err) {
                _this._proxy.$onExtensionActivationFailed(extensionDescription.id);
                throw err;
            });
        };
        ExtHostExtensionService.prototype._doActivateExtension = function (extensionDescription, startup) {
            var event = getTelemetryActivationEvent(extensionDescription);
            this._mainThreadTelemetry.$publicLog('activatePlugin', event);
            if (!extensionDescription.main) {
                // Treat the extension as being empty => NOT AN ERROR CASE
                return winjs_base_1.TPromise.as(new extHostExtensionActivator_1.EmptyExtension(extHostExtensionActivator_1.ExtensionActivationTimes.NONE));
            }
            var activationTimesBuilder = new extHostExtensionActivator_1.ExtensionActivationTimesBuilder(startup);
            return winjs_base_1.TPromise.join([
                loadCommonJSModule(extensionDescription.main, activationTimesBuilder),
                this._loadExtensionContext(extensionDescription)
            ]).then(function (values) {
                return ExtHostExtensionService._callActivate(values[0], values[1], activationTimesBuilder);
            }, function (errors) {
                // Avoid failing with an array of errors, fail with a single error
                if (errors[0]) {
                    return winjs_base_1.TPromise.wrapError(errors[0]);
                }
                if (errors[1]) {
                    return winjs_base_1.TPromise.wrapError(errors[1]);
                }
                return undefined;
            });
        };
        ExtHostExtensionService.prototype._loadExtensionContext = function (extensionDescription) {
            var _this = this;
            var globalState = new ExtensionMemento(extensionDescription.id, true, this._storage);
            var workspaceState = new ExtensionMemento(extensionDescription.id, false, this._storage);
            return winjs_base_1.TPromise.join([
                globalState.whenReady,
                workspaceState.whenReady,
                this._storagePath.whenReady
            ]).then(function () {
                return Object.freeze({
                    globalState: globalState,
                    workspaceState: workspaceState,
                    subscriptions: [],
                    get extensionPath() { return extensionDescription.extensionFolderPath; },
                    storagePath: _this._storagePath.value(extensionDescription),
                    asAbsolutePath: function (relativePath) { return path_1.join(extensionDescription.extensionFolderPath, relativePath); }
                });
            });
        };
        ExtHostExtensionService._callActivate = function (extensionModule, context, activationTimesBuilder) {
            // Make sure the extension's surface is not undefined
            extensionModule = extensionModule || {
                activate: undefined,
                deactivate: undefined
            };
            return this._callActivateOptional(extensionModule, context, activationTimesBuilder).then(function (extensionExports) {
                return new extHostExtensionActivator_1.ActivatedExtension(false, activationTimesBuilder.build(), extensionModule, extensionExports, context.subscriptions);
            });
        };
        ExtHostExtensionService._callActivateOptional = function (extensionModule, context, activationTimesBuilder) {
            if (typeof extensionModule.activate === 'function') {
                try {
                    activationTimesBuilder.activateCallStart();
                    var activateResult = extensionModule.activate.apply(global, [context]);
                    activationTimesBuilder.activateCallStop();
                    activationTimesBuilder.activateResolveStart();
                    return winjs_base_1.TPromise.as(activateResult).then(function (value) {
                        activationTimesBuilder.activateResolveStop();
                        return value;
                    });
                }
                catch (err) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            }
            else {
                // No activate found => the module is the extension's exports
                return winjs_base_1.TPromise.as(extensionModule);
            }
        };
        // -- called by main thread
        ExtHostExtensionService.prototype.$activateByEvent = function (activationEvent) {
            return this.activateByEvent(activationEvent, false);
        };
        return ExtHostExtensionService;
    }());
    exports.ExtHostExtensionService = ExtHostExtensionService;
    function loadCommonJSModule(modulePath, activationTimesBuilder) {
        var r = null;
        activationTimesBuilder.codeLoadingStart();
        try {
            r = require.__$__nodeRequire(modulePath);
        }
        catch (e) {
            return winjs_base_1.TPromise.wrapError(e);
        }
        finally {
            activationTimesBuilder.codeLoadingStop();
        }
        return winjs_base_1.TPromise.as(r);
    }
    function getTelemetryActivationEvent(extensionDescription) {
        var event = {
            id: extensionDescription.id,
            name: extensionDescription.name,
            publisherDisplayName: extensionDescription.publisher,
            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
            isBuiltin: extensionDescription.isBuiltin
        };
        for (var contribution in extensionDescription.contributes) {
            var contributionDetails = extensionDescription.contributes[contribution];
            if (!contributionDetails) {
                continue;
            }
            switch (contribution) {
                case 'debuggers':
                    var types = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['type'] : c['type']; }, '');
                    event['contribution.debuggers'] = types;
                    break;
                case 'grammars':
                    var grammers = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['language'] : c['language']; }, '');
                    event['contribution.grammars'] = grammers;
                    break;
                case 'languages':
                    var languages = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['id'] : c['id']; }, '');
                    event['contribution.languages'] = languages;
                    break;
                case 'tmSnippets':
                    var tmSnippets = contributionDetails.reduce(function (p, c) { return p ? p + ',' + c['languageId'] : c['languageId']; }, '');
                    event['contribution.tmSnippets'] = tmSnippets;
                    break;
                default:
                    event["contribution." + contribution] = true;
            }
        }
        return event;
    }
});

define(__m[111/*vs/workbench/services/thread/node/abstractThreadService*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractThreadService = (function () {
        function AbstractThreadService(rpcProtocol, isMain) {
            this._proxies = Object.create(null);
            this._rpcProtocol = rpcProtocol;
            this._isMain = isMain;
            this._locals = Object.create(null);
            this._proxies = Object.create(null);
            this._rpcProtocol.setDispatcher(this);
        }
        AbstractThreadService.prototype.dispose = function () {
            this._rpcProtocol.dispose();
        };
        AbstractThreadService.prototype.invoke = function (proxyId, methodName, args) {
            if (!this._locals[proxyId]) {
                throw new Error('Unknown actor ' + proxyId);
            }
            var actor = this._locals[proxyId];
            var method = actor[methodName];
            if (typeof method !== 'function') {
                throw new Error('Unknown method ' + methodName + ' on actor ' + proxyId);
            }
            return method.apply(actor, args);
        };
        AbstractThreadService.prototype.get = function (identifier) {
            if (!this._proxies[identifier.id]) {
                this._proxies[identifier.id] = this._createProxy(identifier.id);
            }
            return this._proxies[identifier.id];
        };
        AbstractThreadService.prototype._createProxy = function (proxyId) {
            var _this = this;
            var handler = {
                get: function (target, name) {
                    if (!target[name]) {
                        target[name] = function () {
                            var myArgs = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                myArgs[_i] = arguments[_i];
                            }
                            return _this._callOnRemote(proxyId, name, myArgs);
                        };
                    }
                    return target[name];
                }
            };
            return new Proxy(Object.create(null), handler);
        };
        AbstractThreadService.prototype.set = function (identifier, value) {
            if (identifier.isMain !== this._isMain) {
                throw new Error('Mismatch in object registration!');
            }
            this._locals[identifier.id] = value;
            return value;
        };
        AbstractThreadService.prototype.assertRegistered = function (identifiers) {
            for (var i = 0, len = identifiers.length; i < len; i++) {
                var identifier = identifiers[i];
                if (!this._locals[identifier.id]) {
                    throw new Error("Missing actor " + identifier.id + " (isMain: " + identifier.isMain + ")");
                }
            }
        };
        AbstractThreadService.prototype._callOnRemote = function (proxyId, methodName, args) {
            return this._rpcProtocol.callOnRemote(proxyId, methodName, args);
        };
        return AbstractThreadService;
    }());
    exports.AbstractThreadService = AbstractThreadService;
});











define(__m[79/*vs/workbench/services/thread/node/extHostThreadService*/], __M([1/*require*/,0/*exports*/,111/*vs/workbench/services/thread/node/abstractThreadService*/]), function (require, exports, abstractThreadService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostThreadService = (function (_super) {
        __extends(ExtHostThreadService, _super);
        function ExtHostThreadService(rpcProtocol) {
            return _super.call(this, rpcProtocol, false) || this;
        }
        return ExtHostThreadService;
    }(abstractThreadService_1.AbstractThreadService));
    exports.ExtHostThreadService = ExtHostThreadService;
});










define(__m[63/*vs/workbench/services/untitled/common/untitledEditorService*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,7/*vs/platform/instantiation/common/instantiation*/,15/*vs/base/common/arrays*/,133/*vs/workbench/common/editor/untitledEditorInput*/,26/*vs/platform/configuration/common/configuration*/,3/*vs/base/common/event*/,21/*vs/base/common/map*/,110/*vs/base/common/network*/]), function (require, exports, uri_1, instantiation_1, arrays, untitledEditorInput_1, configuration_1, event_1, map_1, network_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IUntitledEditorService = instantiation_1.createDecorator('untitledEditorService');
    exports.UNTITLED_SCHEMA = 'untitled';
    var UntitledEditorService = (function () {
        function UntitledEditorService(instantiationService, configurationService) {
            this.instantiationService = instantiationService;
            this.configurationService = configurationService;
            this.mapResourceToInput = new map_1.ResourceMap();
            this.mapResourceToAssociatedFilePath = new map_1.ResourceMap();
            this._onDidChangeContent = new event_1.Emitter();
            this._onDidChangeDirty = new event_1.Emitter();
            this._onDidChangeEncoding = new event_1.Emitter();
            this._onDidDisposeModel = new event_1.Emitter();
        }
        Object.defineProperty(UntitledEditorService.prototype, "onDidDisposeModel", {
            get: function () {
                return this._onDidDisposeModel.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeContent", {
            get: function () {
                return this._onDidChangeContent.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeDirty", {
            get: function () {
                return this._onDidChangeDirty.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeEncoding", {
            get: function () {
                return this._onDidChangeEncoding.event;
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorService.prototype.get = function (resource) {
            return this.mapResourceToInput.get(resource);
        };
        // {{SQL CARBON EDIT}}
        UntitledEditorService.prototype.getAll = function (resources) {
            var _this = this;
            if (resources) {
                return arrays.coalesce(resources.map(function (r) { return _this.get(r); }));
            }
            return this.mapResourceToInput.values();
        };
        UntitledEditorService.prototype.exists = function (resource) {
            return this.mapResourceToInput.has(resource);
        };
        UntitledEditorService.prototype.revertAll = function (resources, force) {
            var reverted = [];
            var untitledInputs = this.getAll(resources);
            untitledInputs.forEach(function (input) {
                if (input) {
                    input.revert();
                    input.dispose();
                    reverted.push(input.getResource());
                }
            });
            return reverted;
        };
        UntitledEditorService.prototype.isDirty = function (resource) {
            var input = this.get(resource);
            return input && input.isDirty();
        };
        UntitledEditorService.prototype.getDirty = function (resources) {
            var _this = this;
            var inputs;
            if (resources) {
                inputs = resources.map(function (r) { return _this.get(r); }).filter(function (i) { return !!i; });
            }
            else {
                inputs = this.mapResourceToInput.values();
            }
            return inputs
                .filter(function (i) { return i.isDirty(); })
                .map(function (i) { return i.getResource(); });
        };
        UntitledEditorService.prototype.loadOrCreate = function (options) {
            if (options === void 0) { options = Object.create(null); }
            return this.createOrGet(options.resource, options.modeId, options.initialValue, options.encoding).resolve();
        };
        UntitledEditorService.prototype.createOrGet = function (resource, modeId, initialValue, encoding) {
            // Massage resource if it comes with a file:// scheme
            var hasAssociatedFilePath = false;
            if (resource) {
                hasAssociatedFilePath = (resource.scheme === network_1.Schemas.file);
                resource = resource.with({ scheme: exports.UNTITLED_SCHEMA }); // ensure we have the right scheme
                if (hasAssociatedFilePath) {
                    this.mapResourceToAssociatedFilePath.set(resource, true); // remember for future lookups
                }
            }
            // Return existing instance if asked for it
            if (resource && this.mapResourceToInput.has(resource)) {
                return this.mapResourceToInput.get(resource);
            }
            // Create new otherwise
            return this.doCreate(resource, hasAssociatedFilePath, modeId, initialValue, encoding);
        };
        UntitledEditorService.prototype.doCreate = function (resource, hasAssociatedFilePath, modeId, initialValue, encoding) {
            var _this = this;
            if (!resource) {
                // Create new taking a resource URI that is not already taken
                var counter = this.mapResourceToInput.size + 1;
                do {
                    resource = uri_1.default.from({ scheme: exports.UNTITLED_SCHEMA, path: "Untitled-" + counter });
                    counter++;
                } while (this.mapResourceToInput.has(resource));
            }
            // Look up default language from settings if any
            if (!modeId && !hasAssociatedFilePath) {
                var configuration = this.configurationService.getConfiguration();
                if (configuration.files && configuration.files.defaultLanguage) {
                    modeId = configuration.files.defaultLanguage;
                }
            }
            var input = this.instantiationService.createInstance(untitledEditorInput_1.UntitledEditorInput, resource, hasAssociatedFilePath, modeId, initialValue, encoding);
            var contentListener = input.onDidModelChangeContent(function () {
                _this._onDidChangeContent.fire(resource);
            });
            var dirtyListener = input.onDidChangeDirty(function () {
                _this._onDidChangeDirty.fire(resource);
            });
            var encodingListener = input.onDidModelChangeEncoding(function () {
                _this._onDidChangeEncoding.fire(resource);
            });
            var disposeListener = input.onDispose(function () {
                _this._onDidDisposeModel.fire(resource);
            });
            // Remove from cache on dispose
            var onceDispose = event_1.once(input.onDispose);
            onceDispose(function () {
                _this.mapResourceToInput.delete(input.getResource());
                _this.mapResourceToAssociatedFilePath.delete(input.getResource());
                contentListener.dispose();
                dirtyListener.dispose();
                encodingListener.dispose();
                disposeListener.dispose();
            });
            // Add to cache
            this.mapResourceToInput.set(resource, input);
            return input;
        };
        UntitledEditorService.prototype.hasAssociatedFilePath = function (resource) {
            return this.mapResourceToAssociatedFilePath.has(resource);
        };
        UntitledEditorService.prototype.suggestFileName = function (resource) {
            var input = this.get(resource);
            return input ? input.suggestFileName() : void 0;
        };
        UntitledEditorService.prototype.getEncoding = function (resource) {
            var input = this.get(resource);
            return input ? input.getEncoding() : void 0;
        };
        UntitledEditorService.prototype.dispose = function () {
            this._onDidChangeContent.dispose();
            this._onDidChangeDirty.dispose();
            this._onDidChangeEncoding.dispose();
            this._onDidDisposeModel.dispose();
        };
        UntitledEditorService = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, configuration_1.IConfigurationService)
        ], UntitledEditorService);
        return UntitledEditorService;
    }());
    exports.UntitledEditorService = UntitledEditorService;
});










define(__m[89/*vs/workbench/services/search/node/searchService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,6/*vs/base/common/uri*/,11/*vs/base/common/objects*/,76/*vs/base/common/scorer*/,8/*vs/base/common/strings*/,35/*vs/base/parts/ipc/common/ipc*/,80/*vs/base/parts/ipc/node/ipc.cp*/,52/*vs/platform/search/common/search*/,63/*vs/workbench/services/untitled/common/untitledEditorService*/,36/*vs/editor/common/services/modelService*/,31/*vs/platform/workspace/common/workspace*/,26/*vs/platform/configuration/common/configuration*/,125/*vs/workbench/services/search/node/searchIpc*/,49/*vs/platform/environment/common/environment*/,21/*vs/base/common/map*/]), function (require, exports, winjs_base_1, uri_1, objects, scorer, strings, ipc_1, ipc_cp_1, search_1, untitledEditorService_1, modelService_1, workspace_1, configuration_1, searchIpc_1, environment_1, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the Source EULA. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchService = (function () {
        function SearchService(modelService, untitledEditorService, environmentService, contextService, configurationService) {
            this.modelService = modelService;
            this.untitledEditorService = untitledEditorService;
            this.contextService = contextService;
            this.configurationService = configurationService;
            this.searchProvider = [];
            this.diskSearch = new DiskSearch(!environmentService.isBuilt || environmentService.verbose);
            this.registerSearchResultProvider(this.diskSearch);
        }
        SearchService.prototype.registerSearchResultProvider = function (provider) {
            var _this = this;
            this.searchProvider.push(provider);
            return {
                dispose: function () {
                    var idx = _this.searchProvider.indexOf(provider);
                    if (idx >= 0) {
                        _this.searchProvider.splice(idx, 1);
                    }
                }
            };
        };
        SearchService.prototype.extendQuery = function (query) {
            var configuration = this.configurationService.getConfiguration();
            // Configuration: Encoding
            if (!query.fileEncoding) {
                var fileEncoding = configuration && configuration.files && configuration.files.encoding;
                query.fileEncoding = fileEncoding;
            }
            // Configuration: File Excludes
            if (!query.disregardExcludeSettings) {
                var fileExcludes = configuration && configuration.files && configuration.files.exclude;
                if (fileExcludes) {
                    if (!query.excludePattern) {
                        query.excludePattern = fileExcludes;
                    }
                    else {
                        objects.mixin(query.excludePattern, fileExcludes, false /* no overwrite */);
                    }
                }
            }
        };
        SearchService.prototype.search = function (query) {
            var _this = this;
            var combinedPromise;
            return new winjs_base_1.PPromise(function (onComplete, onError, onProgress) {
                // Get local results from dirty/untitled
                var localResults = _this.getLocalResults(query);
                // Allow caller to register progress callback
                process.nextTick(function () { return localResults.values().filter(function (res) { return !!res; }).forEach(onProgress); });
                var providerPromises = _this.searchProvider.map(function (provider) { return winjs_base_1.TPromise.wrap(provider.search(query)).then(function (e) { return e; }, function (err) {
                    // TODO@joh
                    // single provider fail. fail all?
                    onError(err);
                }, function (progress) {
                    if (progress.resource) {
                        // Match
                        if (!localResults.has(progress.resource)) {
                            onProgress(progress);
                        }
                    }
                    else {
                        // Progress
                        onProgress(progress);
                    }
                }); });
                combinedPromise = winjs_base_1.TPromise.join(providerPromises).then(function (values) {
                    var result = {
                        limitHit: false,
                        results: [],
                        stats: undefined
                    };
                    // TODO@joh
                    // sorting, disjunct results
                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                        var value = values_1[_i];
                        if (!value) {
                            continue;
                        }
                        // TODO@joh individual stats/limit
                        result.stats = value.stats || result.stats;
                        result.limitHit = value.limitHit || result.limitHit;
                        for (var _a = 0, _b = value.results; _a < _b.length; _a++) {
                            var match = _b[_a];
                            if (!localResults.has(match.resource)) {
                                result.results.push(match);
                            }
                        }
                    }
                    return result;
                }).then(onComplete, onError);
            }, function () { return combinedPromise && combinedPromise.cancel(); });
        };
        SearchService.prototype.getLocalResults = function (query) {
            var _this = this;
            var localResults = new map_1.ResourceMap();
            if (query.type === search_1.QueryType.Text) {
                var models = this.modelService.getModels();
                models.forEach(function (model) {
                    var resource = model.uri;
                    if (!resource) {
                        return;
                    }
                    // Support untitled files
                    if (resource.scheme === 'untitled') {
                        if (!_this.untitledEditorService.exists(resource)) {
                            return;
                        }
                    }
                    else if (resource.scheme !== 'file') {
                        return;
                    }
                    if (!_this.matches(resource, query)) {
                        return; // respect user filters
                    }
                    // Use editor API to find matches
                    var matches = model.findMatches(query.contentPattern.pattern, false, query.contentPattern.isRegExp, query.contentPattern.isCaseSensitive, query.contentPattern.isWordMatch ? query.contentPattern.wordSeparators : null, false, query.maxResults);
                    if (matches.length) {
                        var fileMatch_1 = new search_1.FileMatch(resource);
                        localResults.set(resource, fileMatch_1);
                        matches.forEach(function (match) {
                            fileMatch_1.lineMatches.push(new search_1.LineMatch(model.getLineContent(match.range.startLineNumber), match.range.startLineNumber - 1, [[match.range.startColumn - 1, match.range.endColumn - match.range.startColumn]]));
                        });
                    }
                    else {
                        localResults.set(resource, null);
                    }
                });
            }
            return localResults;
        };
        SearchService.prototype.matches = function (resource, query) {
            // file pattern
            if (query.filePattern) {
                if (resource.scheme !== 'file') {
                    return false; // if we match on file pattern, we have to ignore non file resources
                }
                if (!scorer.matches(resource.fsPath, strings.stripWildcards(query.filePattern).toLowerCase())) {
                    return false;
                }
            }
            // includes
            if (query.includePattern) {
                if (resource.scheme !== 'file') {
                    return false; // if we match on file patterns, we have to ignore non file resources
                }
            }
            return search_1.pathIncludedInQuery(query, resource.fsPath);
        };
        SearchService.prototype.clearCache = function (cacheKey) {
            return this.diskSearch.clearCache(cacheKey);
        };
        SearchService = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, untitledEditorService_1.IUntitledEditorService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, configuration_1.IConfigurationService)
        ], SearchService);
        return SearchService;
    }());
    exports.SearchService = SearchService;
    var DiskSearch = (function () {
        function DiskSearch(verboseLogging, timeout) {
            if (timeout === void 0) { timeout = 60 * 60 * 1000; }
            var client = new ipc_cp_1.Client(uri_1.default.parse(require.toUrl('bootstrap')).fsPath, {
                serverName: 'Search',
                timeout: timeout,
                args: ['--type=searchService'],
                // See https://github.com/Microsoft/vscode/issues/27665
                // Pass in fresh execArgv to the forked process such that it doesn't inherit them from `process.execArgv`.
                // e.g. Launching the extension host process with `--inspect-brk=xxx` and then forking a process from the extension host
                // results in the forked process inheriting `--inspect-brk=xxx`.
                freshExecArgv: true,
                env: {
                    AMD_ENTRYPOINT: 'vs/workbench/services/search/node/searchApp',
                    PIPE_LOGGING: 'true',
                    VERBOSE_LOGGING: verboseLogging
                }
            });
            var channel = ipc_1.getNextTickChannel(client.getChannel('search'));
            this.raw = new searchIpc_1.SearchChannelClient(channel);
        }
        DiskSearch.prototype.search = function (query) {
            var request;
            var rawSearch = {
                folderQueries: query.folderQueries ? query.folderQueries.map(function (q) {
                    return {
                        excludePattern: q.excludePattern,
                        includePattern: q.includePattern,
                        fileEncoding: q.fileEncoding,
                        folder: q.folder.fsPath
                    };
                }) : [],
                extraFiles: query.extraFileResources ? query.extraFileResources.map(function (r) { return r.fsPath; }) : [],
                filePattern: query.filePattern,
                excludePattern: query.excludePattern,
                includePattern: query.includePattern,
                maxResults: query.maxResults,
                sortByScore: query.sortByScore,
                cacheKey: query.cacheKey,
                useRipgrep: query.useRipgrep,
                disregardIgnoreFiles: query.disregardIgnoreFiles
            };
            if (query.type === search_1.QueryType.Text) {
                rawSearch.contentPattern = query.contentPattern;
            }
            if (query.type === search_1.QueryType.File) {
                request = this.raw.fileSearch(rawSearch);
            }
            else {
                request = this.raw.textSearch(rawSearch);
            }
            return DiskSearch.collectResults(request);
        };
        DiskSearch.collectResults = function (request) {
            var _this = this;
            var result = [];
            return new winjs_base_1.PPromise(function (c, e, p) {
                request.done(function (complete) {
                    c({
                        limitHit: complete.limitHit,
                        results: result,
                        stats: complete.stats
                    });
                }, e, function (data) {
                    // Matches
                    if (Array.isArray(data)) {
                        var fileMatches = data.map(function (d) { return _this.createFileMatch(d); });
                        result = result.concat(fileMatches);
                        fileMatches.forEach(p);
                    }
                    else if (data.path) {
                        var fileMatch = _this.createFileMatch(data);
                        result.push(fileMatch);
                        p(fileMatch);
                    }
                    else {
                        p(data);
                    }
                });
            }, function () { return request.cancel(); });
        };
        DiskSearch.createFileMatch = function (data) {
            var fileMatch = new search_1.FileMatch(uri_1.default.file(data.path));
            if (data.lineMatches) {
                for (var j = 0; j < data.lineMatches.length; j++) {
                    fileMatch.lineMatches.push(new search_1.LineMatch(data.lineMatches[j].preview, data.lineMatches[j].lineNumber, data.lineMatches[j].offsetAndLengths));
                }
            }
            return fileMatch;
        };
        DiskSearch.prototype.clearCache = function (cacheKey) {
            return this.raw.clearCache(cacheKey);
        };
        return DiskSearch;
    }());
    exports.DiskSearch = DiskSearch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/








var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[95/*vs/workbench/node/extensionHostMain*/], __M([1/*require*/,0/*exports*/,88/*vs/nls!vs/workbench/node/extensionHostMain*/,47/*vs/base/node/pfs*/,2/*vs/base/common/winjs.base*/,20/*path*/,164/*vs/workbench/api/node/extHostExtensionService*/,79/*vs/workbench/services/thread/node/extHostThreadService*/,52/*vs/platform/search/common/search*/,89/*vs/workbench/services/search/node/searchService*/,4/*vs/workbench/api/node/extHost.protocol*/,12/*vs/base/common/errors*/,170/*native-watchdog*/]), function (require, exports, nls, pfs, winjs_base_1, path_1, extHostExtensionService_1, extHostThreadService_1, search_1, searchService_1, extHost_protocol_1, errors, watchdog) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // const nativeExit = process.exit.bind(process);
    process.exit = function () {
        var err = new Error('An extension called process.exit() and this was prevented.');
        console.warn(err.stack);
    };
    function exit(code) {
        //nativeExit(code);
        // TODO@electron
        // See https://github.com/Microsoft/vscode/issues/32990
        // calling process.exit() does not exit the process when the process is being debugged
        // It waits for the debugger to disconnect, but in our version, the debugger does not
        // receive an event that the process desires to exit such that it can disconnect.
        // Do exactly what node.js would have done, minus the wait for the debugger part
        if (code || code === 0) {
            process.exitCode = code;
        }
        if (!process._exiting) {
            process._exiting = true;
            process.emit('exit', process.exitCode || 0);
        }
        watchdog.exit(process.exitCode || 0);
    }
    exports.exit = exit;
    var ExtensionHostMain = (function () {
        function ExtensionHostMain(rpcProtocol, initData) {
            this._isTerminating = false;
            this._environment = initData.environment;
            this._workspace = initData.workspace;
            // services
            var threadService = new extHostThreadService_1.ExtHostThreadService(rpcProtocol);
            this._extensionService = new extHostExtensionService_1.ExtHostExtensionService(initData, threadService);
            // error forwarding and stack trace scanning
            var extensionErrors = new WeakMap();
            this._extensionService.getExtensionPathIndex().then(function (map) {
                Error.prepareStackTrace = function (error, stackTrace) {
                    var stackTraceMessage = '';
                    var extension;
                    var fileName;
                    for (var _i = 0, stackTrace_1 = stackTrace; _i < stackTrace_1.length; _i++) {
                        var call = stackTrace_1[_i];
                        stackTraceMessage += "\n\tat " + call.toString();
                        fileName = call.getFileName();
                        if (!extension && fileName) {
                            extension = map.findSubstr(fileName);
                        }
                    }
                    extensionErrors.set(error, extension);
                    return (error.name || 'Error') + ": " + (error.message || '') + stackTraceMessage;
                };
            });
            var mainThreadErrors = threadService.get(extHost_protocol_1.MainContext.MainThreadErrors);
            errors.setUnexpectedErrorHandler(function (err) {
                var data = errors.transformErrorForSerialization(err);
                var extension = extensionErrors.get(err);
                mainThreadErrors.$onUnexpectedError(data, extension && extension.id);
            });
            // Configure the watchdog to kill our process if the JS event loop is unresponsive for more than 10s
            // if (!initData.environment.isExtensionDevelopmentDebug) {
            // 	watchdog.start(10000);
            // }
        }
        ExtensionHostMain.prototype.start = function () {
            var _this = this;
            return this._extensionService.onExtensionAPIReady()
                .then(function () { return _this.handleEagerExtensions(); })
                .then(function () { return _this.handleExtensionTests(); });
        };
        ExtensionHostMain.prototype.terminate = function () {
            var _this = this;
            if (this._isTerminating) {
                // we are already shutting down...
                return;
            }
            this._isTerminating = true;
            errors.setUnexpectedErrorHandler(function (err) {
                // TODO: write to log once we have one
            });
            var allPromises = [];
            try {
                var allExtensions = this._extensionService.getAllExtensionDescriptions();
                var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
                var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
                allPromises = activatedExtensions.map(function (extensionId) {
                    return _this._extensionService.deactivate(extensionId);
                });
            }
            catch (err) {
                // TODO: write to log once we have one
            }
            var extensionsDeactivated = winjs_base_1.TPromise.join(allPromises).then(function () { return void 0; });
            // Give extensions 1 second to wrap up any async dispose, then exit
            setTimeout(function () {
                winjs_base_1.TPromise.any([winjs_base_1.TPromise.timeout(4000), extensionsDeactivated]).then(function () { return exit(); }, function () { return exit(); });
            }, 1000);
        };
        // Handle "eager" activation extensions
        ExtensionHostMain.prototype.handleEagerExtensions = function () {
            this._extensionService.activateByEvent('*', true).then(null, function (err) {
                console.error(err);
            });
            return this.handleWorkspaceContainsEagerExtensions();
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
            var _this = this;
            if (!this._workspace || this._workspace.roots.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            var desiredFilesMap = {};
            this._extensionService.getAllExtensionDescriptions().forEach(function (desc) {
                var activationEvents = desc.activationEvents;
                if (!activationEvents) {
                    return;
                }
                for (var i = 0; i < activationEvents.length; i++) {
                    if (/^workspaceContains:/.test(activationEvents[i])) {
                        var fileName = activationEvents[i].substr('workspaceContains:'.length);
                        desiredFilesMap[fileName] = true;
                    }
                }
            });
            var matchingPatterns = Object.keys(desiredFilesMap).map(function (p) {
                // TODO: This is a bit hacky -- maybe this should be implemented by using something like
                // `workspaceGlob` or something along those lines?
                if (p.indexOf('*') > -1 || p.indexOf('?') > -1) {
                    if (!_this._diskSearch) {
                        // Shut down this search process after 1s
                        _this._diskSearch = new searchService_1.DiskSearch(false, 1000);
                    }
                    var query = {
                        folderQueries: _this._workspace.roots.map(function (root) { return ({ folder: root }); }),
                        type: search_1.QueryType.File,
                        maxResults: 1,
                        includePattern: (_a = {}, _a[p] = true, _a)
                    };
                    return _this._diskSearch.search(query).then(function (result) { return result.results.length ? p : undefined; });
                }
                else {
                    // find exact path
                    return (function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                        var _i, _a, fsPath;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _i = 0, _a = this._workspace.roots;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                                    fsPath = _a[_i].fsPath;
                                    return [4 /*yield*/, pfs.exists(path_1.join(fsPath, p))];
                                case 2:
                                    if (_b.sent()) {
                                        return [2 /*return*/, p];
                                    }
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3 /*break*/, 1];
                                case 4: return [2 /*return*/, undefined];
                            }
                        });
                    }); })();
                }
                var _a;
            });
            return winjs_base_1.TPromise.join(matchingPatterns).then(function (patterns) {
                patterns
                    .filter(function (p) { return p !== undefined; })
                    .forEach(function (p) {
                    var activationEvent = "workspaceContains:" + p;
                    _this._extensionService.activateByEvent(activationEvent, true)
                        .done(null, function (err) { return console.error(err); });
                });
            });
        };
        ExtensionHostMain.prototype.handleExtensionTests = function () {
            var _this = this;
            if (!this._environment.extensionTestsPath || !this._environment.extensionDevelopmentPath) {
                return winjs_base_1.TPromise.as(null);
            }
            // Require the test runner via node require from the provided path
            var testRunner;
            var requireError;
            try {
                testRunner = require.__$__nodeRequire(this._environment.extensionTestsPath);
            }
            catch (error) {
                requireError = error;
            }
            // Execute the runner if it follows our spec
            if (testRunner && typeof testRunner.run === 'function') {
                return new winjs_base_1.TPromise(function (c, e) {
                    testRunner.run(_this._environment.extensionTestsPath, function (error, failures) {
                        if (error) {
                            e(error.toString());
                        }
                        else {
                            c(null);
                        }
                        // after tests have run, we shutdown the host
                        _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                    });
                });
            }
            else {
                this.gracefulExit(1 /* ERROR */);
            }
            return winjs_base_1.TPromise.wrapError(new Error(requireError ? requireError.toString() : nls.localize(0, null, this._environment.extensionTestsPath)));
        };
        ExtensionHostMain.prototype.gracefulExit = function (code) {
            // to give the PH process a chance to flush any outstanding console
            // messages to the main process, we delay the exit() by some time
            setTimeout(function () { return exit(code); }, 500);
        };
        return ExtensionHostMain;
    }());
    exports.ExtensionHostMain = ExtensionHostMain;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the Source EULA. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[171/*vs/workbench/node/extensionHostProcess*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/errors*/,2/*vs/base/common/winjs.base*/,95/*vs/workbench/node/extensionHostMain*/,124/*vs/workbench/services/extensions/node/rpcProtocol*/,61/*vs/base/common/marshalling*/,101/*vs/base/parts/ipc/node/ipc.net*/,44/*net*/,3/*vs/base/common/event*/]), function (require, exports, errors_1, winjs_base_1, extensionHostMain_1, rpcProtocol_1, marshalling_1, ipc_net_1, net_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // This calls exit directly in case the initialization is not finished and we need to exit
    // Otherwise, if initialization completed we go to extensionHostMain.terminate()
    var onTerminate = function () {
        extensionHostMain_1.exit();
    };
    function createExtHostProtocol() {
        var pipeName = process.env.VSCODE_IPC_HOOK_EXTHOST;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var socket = net_1.createConnection(pipeName, function () {
                socket.removeListener('error', reject);
                resolve(new ipc_net_1.Protocol(socket));
            });
            socket.once('error', reject);
        }).then(function (protocol) {
            return new (function () {
                function class_1() {
                    var _this = this;
                    this._terminating = false;
                    this.onMessage = event_1.filterEvent(protocol.onMessage, function (msg) {
                        if (msg.type !== '__$terminate') {
                            return true;
                        }
                        _this._terminating = true;
                        onTerminate();
                        return false;
                    });
                }
                class_1.prototype.send = function (msg) {
                    if (!this._terminating) {
                        protocol.send(msg);
                    }
                };
                return class_1;
            }());
        });
    }
    function connectToRenderer(protocol) {
        return new winjs_base_1.TPromise(function (c, e) {
            // Listen init data message
            var first = protocol.onMessage(function (raw) {
                first.dispose();
                var initData = marshalling_1.parse(raw);
                var rpcProtocol = new rpcProtocol_1.RPCProtocol(protocol);
                // Print a console message when rejection isn't handled within N seconds. For details:
                // see https://nodejs.org/api/process.html#process_event_unhandledrejection
                // and https://nodejs.org/api/process.html#process_event_rejectionhandled
                var unhandledPromises = [];
                process.on('unhandledRejection', function (reason, promise) {
                    unhandledPromises.push(promise);
                    setTimeout(function () {
                        var idx = unhandledPromises.indexOf(promise);
                        if (idx >= 0) {
                            unhandledPromises.splice(idx, 1);
                            console.warn('rejected promise not handled within 1 second');
                            errors_1.onUnexpectedError(reason);
                        }
                    }, 1000);
                });
                process.on('rejectionHandled', function (promise) {
                    var idx = unhandledPromises.indexOf(promise);
                    if (idx >= 0) {
                        unhandledPromises.splice(idx, 1);
                    }
                });
                // Print a console message when an exception isn't handled.
                process.on('uncaughtException', function (err) {
                    errors_1.onUnexpectedError(err);
                });
                // Kill oneself if one's parent dies. Much drama.
                setInterval(function () {
                    try {
                        process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
                    }
                    catch (e) {
                        onTerminate();
                    }
                }, 5000);
                // Tell the outside that we are initialized
                protocol.send('initialized');
                c({ rpcProtocol: rpcProtocol, initData: initData });
            });
            // Tell the outside that we are ready to receive messages
            protocol.send('ready');
        });
    }
    createExtHostProtocol().then(function (protocol) {
        // connect to main side
        return connectToRenderer(protocol);
    }).then(function (renderer) {
        // setup things
        var extensionHostMain = new extensionHostMain_1.ExtensionHostMain(renderer.rpcProtocol, renderer.initData);
        onTerminate = function () { return extensionHostMain.terminate(); };
        return extensionHostMain.start();
    }).done(null, function (err) { return console.error(err); });
});

}).call(this);
//# sourceMappingURL=extensionHostProcess.js.map
