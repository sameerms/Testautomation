import { RequestType, NotificationType } from 'dataprotocol-jsonrpc';
import { TextDocumentContentChangeEvent, Range, Position, Location, Diagnostic, Command, TextEdit, WorkspaceEdit, TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem, CompletionItem, CompletionList, Hover, SignatureHelp, Definition, ReferenceContext, DocumentHighlight, SymbolInformation, CodeLens, CodeActionContext, FormattingOptions, DocumentLink, ConnectionDetails, ConnectionSummary, ConnectionCompleteParams, IntelliSenseReadyParams, ColumnMetadata, IDbColumn, CapabiltiesDiscoveryResult, MetadataQueryParams, MetadataQueryResult, ScriptingParams, ScriptingResult, ScriptingCompleteParams, BatchSummary, QueryExecuteBatchNotificationParams, ResultSetSummary, IResultMessage, ISelectionData, DbCellValue, EditCell, EditRow, CreateSessionResponse, SessionCreatedParameters, ExpandParams, ExpandResponse, CloseSessionParams, CloseSessionResponse, BackupParams, BackupResponse, RestoreParams, RestoreResponse, RestorePlanResponse, RestoreConfigInfoRequestParams, RestoreConfigInfoResponse, CreateLoginParams, CreateLoginResponse, GetDatabaseInfoParams, GetDatabaseInfoResponse, CreateDatabaseParams, CreateDatabaseResponse, TaskInfo, ListTasksParams, ListTasksResponse, CancelTaskParams, TaskProgressInfo, DefaultDatabaseInfoParams, DefaultDatabaseInfoResponse, BackupConfigInfoResponse, FileBrowserOpenParams, FileBrowserOpenedParams, FileBrowserCloseParams, FileBrowserExpandParams, FileBrowserValidateParams, FileBrowserCloseResponse, FileBrowserExpandedParams, FileBrowserValidatedParams } from 'dataprotocol-languageserver-types';
/**
 * A parameter literal used in requests to pass a text document and a position inside that
 * document.
 */
export interface TextDocumentPositionParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position inside the text document.
     */
    position: Position;
}
/**
 * Defines the capabilities provided by the client.
 */
export interface ClientCapabilities {
}
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
export declare enum TextDocumentSyncKind {
    /**
     * Documents should not be synced at all.
     */
    None = 0,
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    Full = 1,
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    Incremental = 2,
}
/**
 * Completion options.
 */
export interface CompletionOptions {
    /**
     * The server provides support to resolve additional
     * information for a completion item.
     */
    resolveProvider?: boolean;
    /**
     * The characters that trigger completion automatically.
     */
    triggerCharacters?: string[];
}
/**
 * Signature help options.
 */
export interface SignatureHelpOptions {
    /**
     * The characters that trigger signature help
     * automatically.
     */
    triggerCharacters?: string[];
}
/**
 * Code Lens options.
 */
export interface CodeLensOptions {
    /**
     * Code lens has a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * Format document on type options
 */
export interface DocumentOnTypeFormattingOptions {
    /**
     * A character on which formatting should be triggered, like `}`.
     */
    firstTriggerCharacter: string;
    /**
     * More trigger characters.
     */
    moreTriggerCharacter?: string[];
}
/**
 * Document link options
 */
export interface DocumentLinkOptions {
    /**
     * Document links have a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * Defines the capabilities provided by a language
 * server.
 */
export interface ServerCapabilities {
    /**
     * Defines how text documents are synced.
     */
    textDocumentSync?: number;
    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean;
    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions;
    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions;
    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean;
    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean;
    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean;
    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean;
    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean;
    /**
     * The server provides code actions.
     */
    codeActionProvider?: boolean;
    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions;
    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean;
    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean;
    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
    /**
     * The server provides rename support.
     */
    renameProvider?: boolean;
    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions;
    connectionProvider?: boolean;
}
/**
 * The initialize method is sent from the client to the server.
 * It is send once as the first method after starting up the
 * worker. The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
export declare namespace InitializeRequest {
    const type: RequestType<InitializeParams, InitializeResult, InitializeError>;
}
/**
 * The initialize parameters
 */
export interface InitializeParams {
    /**
     * The process Id of the parent process that started
     * the server.
     */
    processId: number;
    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     */
    rootPath: string;
    /**
     * The capabilities provided by the client (editor)
     */
    capabilities: ClientCapabilities;
    /**
     * User provided initialization options.
     */
    initializationOptions?: any;
    /**
     * The initial trace setting. If omitted trace is disabled ('off').
     */
    trace?: 'off' | 'messages' | 'verbose';
}
/**
 * The result returned from an initilize request.
 */
export interface InitializeResult {
    /**
     * The capabilities the language server provides.
     */
    capabilities: ServerCapabilities;
}
/**
 * The data type of the ResponseError if the
 * initialize request fails.
 */
export interface InitializeError {
    /**
     * Indicates whether the client should retry to send the
     * initilize request after showing the message provided
     * in the {@link ResponseError}
     */
    retry: boolean;
}
/**
 * A shutdown request is sent from the client to the server.
 * It is send once when the client descides to shutdown the
 * server. The only notification that is sent after a shudown request
 * is the exit event.
 */
export declare namespace ShutdownRequest {
    const type: RequestType<void, void, void>;
}
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
export declare namespace ExitNotification {
    const type: NotificationType<void>;
}
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
export declare namespace DidChangeConfigurationNotification {
    const type: NotificationType<DidChangeConfigurationParams>;
}
/**
 * The parameters of a change configuration notification.
 */
export interface DidChangeConfigurationParams {
    /**
     * The actual changed settings
     */
    settings: any;
}
/**
 * The message type
 */
export declare enum MessageType {
    /**
     * An error message.
     */
    Error = 1,
    /**
     * A warning message.
     */
    Warning = 2,
    /**
     * An information message.
     */
    Info = 3,
    /**
     * A log message.
     */
    Log = 4,
}
/**
 * The parameters of a notification message.
 */
export interface ShowMessageParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: number;
    /**
     * The actual message
     */
    message: string;
}
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
export declare namespace ShowMessageNotification {
    const type: NotificationType<ShowMessageParams>;
}
export interface MessageActionItem {
    /**
     * A short title like 'Retry', 'Open Log' etc.
     */
    title: string;
}
export interface ShowMessageRequestParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: number;
    /**
     * The actual message
     */
    message: string;
    /**
     * The message action items to present.
     */
    actions?: MessageActionItem[];
}
/**
 * The show message request is send from the server to the clinet to show a message
 * and a set of options actions to the user.
 */
export declare namespace ShowMessageRequest {
    const type: RequestType<ShowMessageRequestParams, MessageActionItem, void>;
}
/**
 * The log message notification is send from the server to the client to ask
 * the client to log a particular message.
 */
export declare namespace LogMessageNotification {
    let type: NotificationType<LogMessageParams>;
}
/**
 * The log message parameters.
 */
export interface LogMessageParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: number;
    /**
     * The actual message
     */
    message: string;
}
/**
 * The telemetry event notification is send from the server to the client to ask
 * the client to log telemetry data.
 */
export declare namespace TelemetryEventNotification {
    let type: NotificationType<any>;
}
/**
 * The parameters send in a open text document notification
 */
export interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem;
}
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri.
 */
export declare namespace DidOpenTextDocumentNotification {
    const type: NotificationType<DidOpenTextDocumentParams>;
}
/**
 * An event describing a change to a text document. If range and rangeLength are omitted
 * the new text is considered to be the full content of the document.
 */
export interface TextDocumentContentChangeEvent {
    /**
     * The range of the document that changed.
     */
    range?: Range;
    /**
     * The length of the range that got replaced.
     */
    rangeLength?: number;
    /**
     * The new text of the document.
     */
    text: string;
}
/**
 * The change text document notification's parameters.
 */
export interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier;
    /**
     * The actual content changes.
     */
    contentChanges: TextDocumentContentChangeEvent[];
}
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
export declare namespace DidChangeTextDocumentNotification {
    const type: NotificationType<DidChangeTextDocumentParams>;
}
/**
 * The parameters send in a close text document notification
 */
export interface DidCloseTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists
 * where the document's uri points to (e.g. if the document's uri is a file uri
 * the truth now exists on disk).
 */
export declare namespace DidCloseTextDocumentNotification {
    const type: NotificationType<DidCloseTextDocumentParams>;
}
/**
 * The parameters send in a save text document notification
 */
export interface DidSaveTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
export declare namespace DidSaveTextDocumentNotification {
    const type: NotificationType<DidSaveTextDocumentParams>;
}
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the lanaguage client.
 */
export declare namespace DidChangeWatchedFilesNotification {
    const type: NotificationType<DidChangeWatchedFilesParams>;
}
/**
 * The watched files change notification's parameters.
 */
export interface DidChangeWatchedFilesParams {
    /**
     * The actual file events.
     */
    changes: FileEvent[];
}
/**
 * The file event type
 */
export declare enum FileChangeType {
    /**
     * The file got created.
     */
    Created = 1,
    /**
     * The file got changed.
     */
    Changed = 2,
    /**
     * The file got deleted.
     */
    Deleted = 3,
}
/**
 * An event describing a file change.
 */
export interface FileEvent {
    /**
     * The file's uri.
     */
    uri: string;
    /**
     * The change type.
     */
    type: number;
}
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
export declare namespace PublishDiagnosticsNotification {
    const type: NotificationType<PublishDiagnosticsParams>;
}
/**
 * The publish diagnostic notification's parameters.
 */
export interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: string;
    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[];
}
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 */
export declare namespace CompletionRequest {
    const type: RequestType<TextDocumentPositionParams, CompletionItem[] | CompletionList, void>;
}
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
export declare namespace CompletionResolveRequest {
    const type: RequestType<CompletionItem, CompletionItem, void>;
}
export declare type MarkedString = string | {
    language: string;
    value: string;
};
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
export declare namespace HoverRequest {
    const type: RequestType<TextDocumentPositionParams, Hover, void>;
}
export declare namespace SignatureHelpRequest {
    const type: RequestType<TextDocumentPositionParams, SignatureHelp, void>;
}
/**
 * A request to resolve the defintion location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
export declare namespace DefinitionRequest {
    const type: RequestType<TextDocumentPositionParams, Definition, void>;
}
/**
 * Parameters for a [ReferencesRequest](#ReferencesRequest).
 */
export interface ReferenceParams extends TextDocumentPositionParams {
    context: ReferenceContext;
}
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
export declare namespace ReferencesRequest {
    const type: RequestType<ReferenceParams, Location[], void>;
}
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request reponse is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
export declare namespace DocumentHighlightRequest {
    const type: RequestType<TextDocumentPositionParams, DocumentHighlight[], void>;
}
/**
 * Parameters for a [DocumentSymbolRequest](#DocumentSymbolRequest).
 */
export interface DocumentSymbolParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
export declare namespace DocumentSymbolRequest {
    const type: RequestType<DocumentSymbolParams, SymbolInformation[], void>;
}
/**
 * The parameters of a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).
 */
export interface WorkspaceSymbolParams {
    /**
     * A non-empty query string
     */
    query: string;
}
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
export declare namespace WorkspaceSymbolRequest {
    const type: RequestType<WorkspaceSymbolParams, SymbolInformation[], void>;
}
/**
 * Params for the CodeActionRequest
 */
export interface CodeActionParams {
    /**
     * The document in which the command was invoked.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range for which the command was invoked.
     */
    range: Range;
    /**
     * Context carrying additional information.
     */
    context: CodeActionContext;
}
/**
 * A request to provide commands for the given text document and range.
 */
export declare namespace CodeActionRequest {
    const type: RequestType<CodeActionParams, Command[], void>;
}
/**
 * Params for the Code Lens request.
 */
export interface CodeLensParams {
    /**
     * The document to request code lens for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * A request to provide code lens for the given text document.
 */
export declare namespace CodeLensRequest {
    const type: RequestType<CodeLensParams, CodeLens[], void>;
}
/**
 * A request to resolve a command for a given code lens.
 */
export declare namespace CodeLensResolveRequest {
    const type: RequestType<CodeLens, CodeLens, void>;
}
export interface DocumentFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The format options
     */
    options: FormattingOptions;
}
/**
 * A request to to format a whole document.
 */
export declare namespace DocumentFormattingRequest {
    const type: RequestType<DocumentFormattingParams, TextEdit[], void>;
}
export interface DocumentRangeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range to format
     */
    range: Range;
    /**
     * The format options
     */
    options: FormattingOptions;
}
/**
 * A request to to format a range in a document.
 */
export declare namespace DocumentRangeFormattingRequest {
    const type: RequestType<DocumentRangeFormattingParams, TextEdit[], void>;
}
export interface DocumentOnTypeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position at which this request was send.
     */
    position: Position;
    /**
     * The character that has been typed.
     */
    ch: string;
    /**
     * The format options.
     */
    options: FormattingOptions;
}
/**
 * A request to format a document on type.
 */
export declare namespace DocumentOnTypeFormattingRequest {
    const type: RequestType<DocumentOnTypeFormattingParams, TextEdit[], void>;
}
export interface RenameParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position at which this request was send.
     */
    position: Position;
    /**
     * The new name of the symbol. If the given name is not valid the
     * request must return a [ResponseError](#ResponseError) with an
     * appropriate message set.
     */
    newName: string;
}
/**
 * A request to rename a symbol.
 */
export declare namespace RenameRequest {
    const type: RequestType<RenameParams, WorkspaceEdit, void>;
}
export interface DocumentLinkParams {
    /**
     * The document to provide document links for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * A request to provide document links
 */
export declare namespace DocumentLinkRequest {
    const type: RequestType<DocumentLinkParams, DocumentLink[], void>;
}
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
export declare namespace DocumentLinkResolveRequest {
    const type: RequestType<DocumentLink, DocumentLink, void>;
}
/**
 * Notification sent when the an IntelliSense cache invalidation is requested
 */
export declare namespace RebuildIntelliSenseNotification {
    const type: NotificationType<RebuildIntelliSenseParams>;
}
/**
 * Rebuild IntelliSense notification parameters
 */
export declare class RebuildIntelliSenseParams {
    /**
     * URI identifying the text document
     */
    ownerUri: string;
}
/**
 * Connection request message format
 */
export interface ConnectParams {
    /**
     * URI identifying the owner of the connection
     */
    ownerUri: string;
    /**
     * Details for creating the connection
     */
    connection: ConnectionDetails;
}
export declare namespace ConnectionRequest {
    const type: RequestType<ConnectParams, boolean, void>;
}
export declare namespace ConnectionCompleteNotification {
    const type: NotificationType<ConnectionCompleteParams>;
}
/**
 * Parameters for the ConnectionChanged notification.
 */
export declare class ConnectionChangedParams {
    /**
     * Owner URI of the connection that changed.
     */
    ownerUri: string;
    /**
     * Summary of details containing any connection changes.
     */
    connection: ConnectionSummary;
}
/**
 * Connection changed event callback declaration.
 */
export declare namespace ConnectionChangedNotification {
    const type: NotificationType<ConnectionChangedParams>;
}
export declare class DisconnectParams {
    ownerUri: string;
}
export declare type DisconnectResult = boolean;
export declare namespace DisconnectRequest {
    const type: RequestType<DisconnectParams, DisconnectResult, void>;
}
export declare class CancelConnectParams {
    /**
     * URI identifying the owner of the connection
     */
    ownerUri: string;
}
export declare type CancelConnectResult = boolean;
export declare namespace CancelConnectRequest {
    const type: RequestType<CancelConnectParams, CancelConnectResult, void>;
}
export declare class ChangeDatabaseParams {
    ownerUri: string;
    newDatabase: string;
}
export declare namespace ChangeDatabaseRequest {
    const type: RequestType<ChangeDatabaseParams, boolean, void>;
}
export declare class ListDatabasesParams {
    ownerUri: string;
}
export declare class ListDatabasesResult {
    databaseNames: Array<string>;
}
export declare namespace ListDatabasesRequest {
    const type: RequestType<ListDatabasesParams, ListDatabasesResult, void>;
}
/**
 * Parameters to provide when sending a language flavor changed notification
 */
export interface DidChangeLanguageFlavorParams {
    uri: string;
    language: string;
    flavor: string;
}
export declare namespace LanguageFlavorChangedNotification {
    const type: NotificationType<DidChangeLanguageFlavorParams>;
}
export declare class TableMetadataParams {
    ownerUri: string;
    schema: string;
    objectName: string;
}
export declare class TableMetadataResult {
    columns: ColumnMetadata[];
}
export declare namespace TableMetadataRequest {
    const type: RequestType<TableMetadataParams, TableMetadataResult, void>;
}
export declare namespace ViewMetadataRequest {
    const type: RequestType<TableMetadataParams, TableMetadataResult, void>;
}
/**
 * Event sent when the language service is finished updating after a connection
 */
export declare namespace IntelliSenseReadyNotification {
    const type: NotificationType<IntelliSenseReadyParams>;
}
export declare class CapabiltiesDiscoveryParams {
    hostName: string;
    hostVersion: string;
}
export declare namespace CapabiltiesDiscoveryRequest {
    const type: RequestType<CapabiltiesDiscoveryParams, CapabiltiesDiscoveryResult, void>;
}
export declare namespace QueryCancelRequest {
    const type: RequestType<QueryCancelParams, QueryCancelResult, void>;
}
export interface QueryCancelParams {
    ownerUri: string;
}
export interface QueryCancelResult {
    messages: string;
}
export declare namespace QueryDisposeRequest {
    const type: RequestType<QueryDisposeParams, QueryDisposeResult, void>;
}
/**
 * Parameters to provide when disposing of a query
 */
export interface QueryDisposeParams {
    ownerUri: string;
}
/**
 * Result received upon successful disposal of a query
 */
export interface QueryDisposeResult {
}
export declare namespace QueryExecuteCompleteNotification {
    const type: NotificationType<QueryExecuteCompleteNotificationResult>;
}
/**
 * Result received upon successful execution of a query
 */
export interface QueryExecuteCompleteNotificationResult {
    ownerUri: string;
    batchSummaries: BatchSummary[];
}
export declare namespace QueryExecuteBatchStartNotification {
    const type: NotificationType<QueryExecuteBatchNotificationParams>;
}
export declare namespace QueryExecuteBatchCompleteNotification {
    const type: NotificationType<QueryExecuteBatchNotificationParams>;
}
export declare namespace QueryExecuteResultSetCompleteNotification {
    const type: NotificationType<QueryExecuteResultSetCompleteNotificationParams>;
}
export interface QueryExecuteResultSetCompleteNotificationParams {
    resultSetSummary: ResultSetSummary;
    ownerUri: string;
}
export declare namespace QueryExecuteMessageNotification {
    const type: NotificationType<QueryExecuteMessageParams>;
}
export declare class QueryExecuteMessageParams {
    message: IResultMessage;
    ownerUri: string;
}
export declare namespace QueryExecuteRequest {
    const type: RequestType<QueryExecuteParams, QueryExecuteResult, void>;
}
export interface ExecutionPlanOptions {
    includeEstimatedExecutionPlanXml?: boolean;
    includeActualExecutionPlanXml?: boolean;
}
export interface QueryExecuteParams {
    ownerUri: string;
    querySelection: ISelectionData;
    executionPlanOptions?: ExecutionPlanOptions;
}
export interface QueryExecuteResult {
}
export declare namespace QueryExecuteSubsetRequest {
    const type: RequestType<QueryExecuteSubsetParams, QueryExecuteSubsetResult, void>;
}
export interface QueryExecuteSubsetParams {
    ownerUri: string;
    batchIndex: number;
    resultSetIndex: number;
    rowsStartIndex: number;
    rowsCount: number;
}
export interface ResultSetSubset {
    rowCount: number;
    rows: DbCellValue[][];
}
export interface QueryExecuteSubsetResult {
    message: string;
    resultSubset: ResultSetSubset;
}
export interface QueryExecuteStatementParams {
    ownerUri: string;
    line: number;
    column: number;
}
export declare namespace QueryExecuteStatementRequest {
    const type: RequestType<QueryExecuteStatementParams, QueryExecuteResult, void>;
}
export interface SaveResultsRequestParams {
    ownerUri: string;
    filePath: string;
    batchIndex: number;
    resultSetIndex: number;
    rowStartIndex: number;
    rowEndIndex: number;
    columnStartIndex: number;
    columnEndIndex: number;
    includeHeaders?: boolean;
}
export declare class SaveResultRequestResult {
    messages: string;
}
export declare namespace SaveResultsAsCsvRequest {
    const type: RequestType<SaveResultsRequestParams, SaveResultRequestResult, void>;
}
export declare namespace SaveResultsAsJsonRequest {
    const type: RequestType<SaveResultsRequestParams, SaveResultRequestResult, void>;
}
export declare namespace SaveResultsAsExcelRequest {
    const type: RequestType<SaveResultsRequestParams, SaveResultRequestResult, void>;
}
export interface SimpleExecuteParams {
    queryString: string;
    ownerUri: string;
}
export interface SimpleExecuteResult {
    rowCount: number;
    columnInfo: IDbColumn[];
    rows: DbCellValue[][];
}
export declare namespace SimpleExecuteRequest {
    const type: RequestType<SimpleExecuteParams, SimpleExecuteResult, void>;
}
export interface QueryExecuteStringParams {
    query: string;
    ownerUri: string;
}
export declare namespace QueryExecuteStringRequest {
    const type: RequestType<QueryExecuteStringParams, QueryExecuteResult, void>;
}
export declare namespace MetadataQueryRequest {
    const type: RequestType<MetadataQueryParams, MetadataQueryResult, void>;
}
export declare namespace ScriptingRequest {
    const type: RequestType<ScriptingParams, ScriptingResult, void>;
}
export declare namespace ScriptingCompleteNotification {
    const type: NotificationType<ScriptingCompleteParams>;
}
export interface EditSessionOperationParams {
    ownerUri: string;
}
export interface EditRowOperationParams extends EditSessionOperationParams {
    rowId: number;
}
export interface EditCellResult {
    cell: EditCell;
    isRowDirty: boolean;
}
export declare namespace EditCommitRequest {
    const type: RequestType<EditCommitParams, EditCommitResult, void>;
}
export interface EditCommitParams extends EditSessionOperationParams {
}
export interface EditCommitResult {
}
export declare namespace EditCreateRowRequest {
    const type: RequestType<EditCreateRowParams, EditCreateRowResult, void>;
}
export interface EditCreateRowParams extends EditSessionOperationParams {
}
export interface EditCreateRowResult {
    defaultValues: string[];
    newRowId: number;
}
export declare namespace EditDeleteRowRequest {
    const type: RequestType<EditDeleteRowParams, EditDeleteRowResult, void>;
}
export interface EditDeleteRowParams extends EditRowOperationParams {
}
export interface EditDeleteRowResult {
}
export declare namespace EditDisposeRequest {
    const type: RequestType<EditDisposeParams, EditDisposeResult, void>;
}
export interface EditDisposeParams extends EditSessionOperationParams {
}
export interface EditDisposeResult {
}
export declare namespace EditInitializeRequest {
    const type: RequestType<EditInitializeParams, EditInitializeResult, void>;
}
export interface EditInitializeFiltering {
    LimitResults?: number;
}
export interface EditInitializeParams extends EditSessionOperationParams {
    filters: EditInitializeFiltering;
    objectName: string;
    schemaName: string;
    objectType: string;
}
export interface EditInitializeResult {
}
export declare namespace EditRevertCellRequest {
    const type: RequestType<EditRevertCellParams, EditRevertCellResult, void>;
}
export interface EditRevertCellParams extends EditRowOperationParams {
    columnId: number;
}
export interface EditRevertCellResult extends EditCellResult {
}
export declare namespace EditRevertRowRequest {
    const type: RequestType<EditRevertRowParams, EditRevertRowResult, void>;
}
export interface EditRevertRowParams extends EditRowOperationParams {
}
export interface EditRevertRowResult {
}
export declare namespace EditSessionReadyNotification {
    const type: NotificationType<EditSessionReadyParams>;
}
export interface EditSessionReadyParams {
    ownerUri: string;
    success: boolean;
    message: string;
}
export declare namespace EditUpdateCellRequest {
    const type: RequestType<EditUpdateCellParams, EditUpdateCellResult, void>;
}
export interface EditUpdateCellParams extends EditRowOperationParams {
    columnId: number;
    newValue: string;
}
export interface EditUpdateCellResult extends EditCellResult {
}
export declare namespace EditSubsetRequest {
    const type: RequestType<EditSubsetParams, EditSubsetResult, void>;
}
export interface EditSubsetParams extends EditSessionOperationParams {
    rowStartIndex: number;
    rowCount: number;
}
export interface EditSubsetResult {
    rowCount: number;
    subset: EditRow[];
}
export declare namespace ObjectExplorerCreateSessionRequest {
    const type: RequestType<ConnectionDetails, CreateSessionResponse, void>;
}
export declare namespace ObjectExplorerExpandRequest {
    const type: RequestType<ExpandParams, boolean, void>;
}
export declare namespace ObjectExplorerRefreshRequest {
    const type: RequestType<ExpandParams, boolean, void>;
}
export declare namespace ObjectExplorerCloseSessionRequest {
    const type: RequestType<CloseSessionParams, CloseSessionResponse, void>;
}
export declare namespace ObjectExplorerCreateSessionCompleteNotification {
    const type: NotificationType<SessionCreatedParameters>;
}
export declare namespace ObjectExplorerExpandCompleteNotification {
    const type: NotificationType<ExpandResponse>;
}
export declare namespace ListTasksRequest {
    const type: RequestType<ListTasksParams, ListTasksResponse, void>;
}
export declare namespace CancelTaskRequest {
    const type: RequestType<CancelTaskParams, boolean, void>;
}
export declare namespace TaskStatusChangedNotification {
    const type: NotificationType<TaskProgressInfo>;
}
export declare namespace TaskCreatedNotification {
    const type: NotificationType<TaskInfo>;
}
export declare namespace CreateDatabaseRequest {
    const type: RequestType<CreateDatabaseParams, CreateDatabaseResponse, void>;
}
export declare namespace DefaultDatabaseInfoRequest {
    const type: RequestType<DefaultDatabaseInfoParams, DefaultDatabaseInfoResponse, void>;
}
export declare namespace CreateLoginRequest {
    const type: RequestType<CreateLoginParams, CreateLoginResponse, void>;
}
export declare namespace GetDatabaseInfoRequest {
    const type: RequestType<GetDatabaseInfoParams, GetDatabaseInfoResponse, void>;
}
export declare namespace BackupRequest {
    const type: RequestType<BackupParams, BackupResponse, void>;
}
export declare namespace BackupConfigInfoRequest {
    const type: RequestType<DefaultDatabaseInfoParams, BackupConfigInfoResponse, void>;
}
export declare namespace RestoreRequest {
    const type: RequestType<RestoreParams, RestoreResponse, void>;
}
export declare namespace RestorePlanRequest {
    const type: RequestType<RestoreParams, RestorePlanResponse, void>;
}
export declare namespace CancelRestorePlanRequest {
    const type: RequestType<RestoreParams, boolean, void>;
}
export declare namespace RestoreConfigInfoRequest {
    const type: RequestType<RestoreConfigInfoRequestParams, RestoreConfigInfoResponse, void>;
}
export declare namespace FileBrowserOpenRequest {
    const type: RequestType<FileBrowserOpenParams, boolean, void>;
}
export declare namespace FileBrowserOpenedNotification {
    const type: NotificationType<FileBrowserOpenedParams>;
}
export declare namespace FileBrowserExpandRequest {
    const type: RequestType<FileBrowserExpandParams, boolean, void>;
}
export declare namespace FileBrowserExpandedNotification {
    const type: NotificationType<FileBrowserExpandedParams>;
}
export declare namespace FileBrowserValidateRequest {
    const type: RequestType<FileBrowserValidateParams, boolean, void>;
}
export declare namespace FileBrowserValidatedNotification {
    const type: NotificationType<FileBrowserValidatedParams>;
}
export declare namespace FileBrowserCloseRequest {
    const type: RequestType<FileBrowserCloseParams, FileBrowserCloseResponse, void>;
}
