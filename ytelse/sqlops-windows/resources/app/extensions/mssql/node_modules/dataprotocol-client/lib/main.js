/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Source EULA. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var cp = require('child_process');
var vscode_1 = require('vscode');
var data_1 = require('data');
var dataprotocol_jsonrpc_1 = require('dataprotocol-jsonrpc');
exports.ErrorCodes = dataprotocol_jsonrpc_1.ErrorCodes;
exports.ResponseError = dataprotocol_jsonrpc_1.ResponseError;
var dataprotocol_languageserver_types_1 = require('dataprotocol-languageserver-types');
exports.Range = dataprotocol_languageserver_types_1.Range;
exports.Position = dataprotocol_languageserver_types_1.Position;
exports.Location = dataprotocol_languageserver_types_1.Location;
exports.TextEdit = dataprotocol_languageserver_types_1.TextEdit;
exports.WorkspaceChange = dataprotocol_languageserver_types_1.WorkspaceChange;
exports.TextDocumentIdentifier = dataprotocol_languageserver_types_1.TextDocumentIdentifier;
var protocol_1 = require('./protocol');
var c2p = require('./codeConverter');
exports.Code2Protocol = c2p;
var p2c = require('./protocolConverter');
exports.Protocol2Code = p2c;
var is = require('./utils/is');
var electron = require('./utils/electron');
var processes_1 = require('./utils/processes');
var async_1 = require('./utils/async');
var ConsoleLogger = (function () {
    function ConsoleLogger() {
    }
    ConsoleLogger.prototype.error = function (message) {
        console.error(message);
    };
    ConsoleLogger.prototype.warn = function (message) {
        console.warn(message);
    };
    ConsoleLogger.prototype.info = function (message) {
        console.info(message);
    };
    ConsoleLogger.prototype.log = function (message) {
        console.log(message);
    };
    return ConsoleLogger;
}());
function createConnection(input, output, errorHandler, closeHandler) {
    var logger = new ConsoleLogger();
    var connection = dataprotocol_jsonrpc_1.createClientMessageConnection(input, output, logger);
    connection.onError(function (data) { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    var result = {
        listen: function () { return connection.listen(); },
        sendRequest: function (type, params, token) { return connection.sendRequest(type, params, token); },
        sendNotification: function (type, params) { return connection.sendNotification(type, params); },
        onNotification: function (type, handler) { return connection.onNotification(type, handler); },
        onRequest: function (type, handler) { return connection.onRequest(type, handler); },
        trace: function (value, tracer, sendNotification) {
            if (sendNotification === void 0) { sendNotification = false; }
            return connection.trace(value, tracer, sendNotification);
        },
        initialize: function (params) { return connection.sendRequest(protocol_1.InitializeRequest.type, params); },
        shutdown: function () { return connection.sendRequest(protocol_1.ShutdownRequest.type, undefined); },
        exit: function () { return connection.sendNotification(protocol_1.ExitNotification.type); },
        onLogMessage: function (handler) { return connection.onNotification(protocol_1.LogMessageNotification.type, handler); },
        onShowMessage: function (handler) { return connection.onNotification(protocol_1.ShowMessageNotification.type, handler); },
        onTelemetry: function (handler) { return connection.onNotification(protocol_1.TelemetryEventNotification.type, handler); },
        didChangeConfiguration: function (params) { return connection.sendNotification(protocol_1.DidChangeConfigurationNotification.type, params); },
        didChangeWatchedFiles: function (params) { return connection.sendNotification(protocol_1.DidChangeWatchedFilesNotification.type, params); },
        didOpenTextDocument: function (params) { return connection.sendNotification(protocol_1.DidOpenTextDocumentNotification.type, params); },
        didChangeTextDocument: function (params) { return connection.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, params); },
        didCloseTextDocument: function (params) { return connection.sendNotification(protocol_1.DidCloseTextDocumentNotification.type, params); },
        didSaveTextDocument: function (params) { return connection.sendNotification(protocol_1.DidSaveTextDocumentNotification.type, params); },
        onDiagnostics: function (handler) { return connection.onNotification(protocol_1.PublishDiagnosticsNotification.type, handler); },
        dispose: function () { return connection.dispose(); }
    };
    return result;
}
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
})(exports.TransportKind || (exports.TransportKind = {}));
var TransportKind = exports.TransportKind;
/**
 * An action to be performed when the connection is producing errors.
 */
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(exports.ErrorAction || (exports.ErrorAction = {}));
var ErrorAction = exports.ErrorAction;
/**
 * An action to be performed when the connection to a server got closed.
 */
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(exports.CloseAction || (exports.CloseAction = {}));
var CloseAction = exports.CloseAction;
var DefaultErrorHandler = (function () {
    function DefaultErrorHandler(name) {
        this.name = name;
        this.restarts = [];
    }
    DefaultErrorHandler.prototype.error = function (error, message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    };
    DefaultErrorHandler.prototype.closed = function () {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            var diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                vscode_1.window.showErrorMessage("The " + this.name + " server crashed 5 times in the last 3 minutes. The server will not be restarted.");
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    };
    return DefaultErrorHandler;
}());
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var RevealOutputChannelOn = exports.RevealOutputChannelOn;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Running"] = 2] = "Running";
})(exports.State || (exports.State = {}));
var State = exports.State;
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
var FalseSyncExpression = (function () {
    function FalseSyncExpression() {
    }
    FalseSyncExpression.prototype.evaluate = function (textDocument) {
        return false;
    };
    return FalseSyncExpression;
}());
var LanguageIdExpression = (function () {
    function LanguageIdExpression(_id) {
        this._id = _id;
    }
    LanguageIdExpression.prototype.evaluate = function (textDocument) {
        return this._id === textDocument.languageId;
    };
    return LanguageIdExpression;
}());
var FunctionSyncExpression = (function () {
    function FunctionSyncExpression(_func) {
        this._func = _func;
    }
    FunctionSyncExpression.prototype.evaluate = function (textDocument) {
        return this._func(textDocument);
    };
    return FunctionSyncExpression;
}());
var CompositeSyncExpression = (function () {
    function CompositeSyncExpression(values, func) {
        this._expression = values.map(function (value) { return new LanguageIdExpression(value); });
        if (func) {
            this._expression.push(new FunctionSyncExpression(func));
        }
    }
    CompositeSyncExpression.prototype.evaluate = function (textDocument) {
        return this._expression.some(function (exp) { return exp.evaluate(textDocument); });
    };
    return CompositeSyncExpression;
}());
var LanguageClient = (function () {
    function LanguageClient(arg1, arg2, arg3, arg4, arg5) {
        var _this = this;
        var clientOptions;
        var forceDebug;
        if (is.string(arg2)) {
            this._id = arg1;
            this._name = arg2;
            this._serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = arg5;
        }
        else {
            this._id = arg1.toLowerCase();
            this._name = arg1;
            this._serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        this._clientOptions = clientOptions || { providerId: '' };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._clientOptions.errorHandler = this._clientOptions.errorHandler || new DefaultErrorHandler(this._name);
        this._clientOptions.revealOutputChannelOn == this._clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error;
        this._syncExpression = this.computeSyncExpression();
        this._forceDebug = forceDebug;
        this.state = ClientState.Initial;
        this._connection = null;
        this._childProcess = null;
        this._outputChannel = null;
        this._listeners = null;
        this._providers = null;
        this._diagnostics = null;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise(function (resolve, reject) {
            _this._onReadyCallbacks = { resolve: resolve, reject: reject };
        });
        this._telemetryEmitter = new dataprotocol_jsonrpc_1.Emitter();
        this._stateChangeEmitter = new dataprotocol_jsonrpc_1.Emitter();
        this._tracer = {
            log: function (message, data) {
                _this.logTrace(message, data);
            }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);
    }
    Object.defineProperty(LanguageClient.prototype, "state", {
        get: function () {
            return this._state;
        },
        set: function (value) {
            var oldState = this.getPublicState();
            this._state = value;
            var newState = this.getPublicState();
            if (newState !== oldState) {
                this._stateChangeEmitter.fire({ oldState: oldState, newState: newState });
            }
        },
        enumerable: true,
        configurable: true
    });
    LanguageClient.prototype.getPublicState = function () {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else {
            return State.Stopped;
        }
    };
    LanguageClient.prototype.computeSyncExpression = function () {
        var documentSelector = this._clientOptions.documentSelector;
        var textDocumentFilter = this._clientOptions.synchronize.textDocumentFilter;
        if (!documentSelector && !textDocumentFilter) {
            return new FalseSyncExpression();
        }
        if (textDocumentFilter && !documentSelector) {
            return new FunctionSyncExpression(textDocumentFilter);
        }
        if (!textDocumentFilter && documentSelector) {
            if (is.string(documentSelector)) {
                return new LanguageIdExpression(documentSelector);
            }
            else {
                return new CompositeSyncExpression(documentSelector);
            }
        }
        if (textDocumentFilter && documentSelector) {
            return new CompositeSyncExpression(is.string(documentSelector) ? [documentSelector] : documentSelector, textDocumentFilter);
        }
    };
    LanguageClient.prototype.sendRequest = function (type, params, token) {
        var _this = this;
        return this.onReady().then(function () {
            return _this.resolveConnection().then(function (connection) {
                return _this.doSendRequest(connection, type, params, token);
            });
        });
    };
    LanguageClient.prototype.doSendRequest = function (connection, type, params, token) {
        if (this.isConnectionActive()) {
            this.forceDocumentSync();
            try {
                return connection.sendRequest(type, params, token);
            }
            catch (error) {
                this.error("Sending request " + type.method + " failed.", error);
            }
        }
        else {
            return Promise.reject(new dataprotocol_jsonrpc_1.ResponseError(dataprotocol_jsonrpc_1.ErrorCodes.InternalError, 'Connection is closed.'));
        }
    };
    LanguageClient.prototype.sendNotification = function (type, params) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                if (_this.isConnectionActive()) {
                    _this.forceDocumentSync();
                    try {
                        connection.sendNotification(type, params);
                    }
                    catch (error) {
                        _this.error("Sending notification " + type.method + " failed.", error);
                    }
                }
            });
        }, function (error) {
            _this.error("Sending notification " + type.method + " failed.", error);
        });
    };
    LanguageClient.prototype.onNotification = function (type, handler) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                try {
                    connection.onNotification(type, handler);
                }
                catch (error) {
                    _this.error("Registering notification handler " + type.method + " failed.", error);
                }
            });
        }, function (error) {
        });
    };
    LanguageClient.prototype.onRequest = function (type, handler) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                try {
                    connection.onRequest(type, handler);
                }
                catch (error) {
                    _this.error("Registering request handler " + type.method + " failed.", error);
                }
            });
        }, function (error) {
        });
    };
    Object.defineProperty(LanguageClient.prototype, "onTelemetry", {
        get: function () {
            return this._telemetryEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LanguageClient.prototype, "onDidChangeState", {
        get: function () {
            return this._stateChangeEmitter.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LanguageClient.prototype, "outputChannel", {
        get: function () {
            if (!this._outputChannel) {
                this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
            }
            return this._outputChannel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LanguageClient.prototype, "diagnostics", {
        get: function () {
            return this._diagnostics;
        },
        enumerable: true,
        configurable: true
    });
    LanguageClient.prototype.createDefaultErrorHandler = function () {
        return new DefaultErrorHandler(this._name);
    };
    Object.defineProperty(LanguageClient.prototype, "trace", {
        set: function (value) {
            var _this = this;
            this._trace = value;
            this.onReady().then(function () {
                _this.resolveConnection().then(function (connection) {
                    connection.trace(value, _this._tracer);
                });
            }, function (error) {
            });
        },
        enumerable: true,
        configurable: true
    });
    LanguageClient.prototype.data2String = function (data) {
        if (data instanceof dataprotocol_jsonrpc_1.ResponseError) {
            var responseError = data;
            return "  Message: " + responseError.message + "\n  Code: " + responseError.code + " " + (responseError.data ? '\n' + responseError.data.toString() : '');
        }
        if (data instanceof Error) {
            if (is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (is.string(data)) {
            return data;
        }
        return data.toString();
    };
    LanguageClient.prototype.info = function (message, data) {
        this.outputChannel.appendLine("[Info  - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.outputChannel.show(true);
        }
    };
    LanguageClient.prototype.warn = function (message, data) {
        this.outputChannel.appendLine("[Warn  - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.outputChannel.show(true);
        }
    };
    LanguageClient.prototype.error = function (message, data) {
        this.outputChannel.appendLine("[Error - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.outputChannel.show(true);
        }
    };
    LanguageClient.prototype.logTrace = function (message, data) {
        this.outputChannel.appendLine("[Trace - " + (new Date().toLocaleTimeString()) + "] " + message);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        this.outputChannel.show(true);
    };
    LanguageClient.prototype.needsStart = function () {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    };
    LanguageClient.prototype.needsStop = function () {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    };
    LanguageClient.prototype.onReady = function () {
        return this._onReady;
    };
    LanguageClient.prototype.isConnectionActive = function () {
        return this.state === ClientState.Running;
    };
    LanguageClient.prototype.start = function () {
        var _this = this;
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        if (this._clientOptions.providerId && this._clientOptions.providerId !== '') {
            // hook-up SQL data protocol provider
            this.hookDataProtocolProvider(this._clientOptions.providerId);
        }
        this.resolveConnection().then(function (connection) {
            connection.onLogMessage(function (message) {
                switch (message.type) {
                    case protocol_1.MessageType.Error:
                        _this.error(message.message);
                        break;
                    case protocol_1.MessageType.Warning:
                        _this.warn(message.message);
                        break;
                    case protocol_1.MessageType.Info:
                        _this.info(message.message);
                        break;
                    default:
                        _this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage(function (message) {
                switch (message.type) {
                    case protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(protocol_1.ShowMessageRequest.type, function (params) {
                var messageFunc = null;
                switch (params.type) {
                    case protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                return messageFunc.apply(void 0, [params.message].concat(params.actions));
            });
            connection.onTelemetry(function (data) {
                _this._telemetryEmitter.fire(data);
            });
            connection.listen();
            // Error is handled in the intialize call.
            _this.initialize(connection).then(null, function (error) { });
        }, function (error) {
            _this.state = ClientState.StartFailed;
            _this._onReadyCallbacks.reject(error);
            _this.error('Starting client failed', error);
        });
        return new vscode_1.Disposable(function () {
            if (_this.needsStop()) {
                _this.stop();
            }
        });
    };
    LanguageClient.prototype.resolveConnection = function () {
        if (!this._connection) {
            this._connection = this.createConnection();
        }
        return this._connection;
    };
    LanguageClient.prototype.initialize = function (connection) {
        var _this = this;
        this.refreshTrace(connection, false);
        var initOption = this._clientOptions.initializationOptions;
        var initParams = {
            processId: process.pid,
            rootPath: vscode_1.workspace.rootPath,
            capabilities: {},
            initializationOptions: is.func(initOption) ? initOption() : initOption,
            trace: dataprotocol_jsonrpc_1.Trace.toString(this._trace)
        };
        return connection.initialize(initParams).then(function (result) {
            _this.state = ClientState.Running;
            _this._capabilites = result.capabilities;
            connection.onDiagnostics(function (params) { return _this.handleDiagnostics(params); });
            if (_this._capabilites.textDocumentSync !== protocol_1.TextDocumentSyncKind.None) {
                vscode_1.workspace.onDidOpenTextDocument(function (t) { return _this.onDidOpenTextDoument(connection, t); }, null, _this._listeners);
                vscode_1.workspace.onDidChangeTextDocument(function (t) { return _this.onDidChangeTextDocument(connection, t); }, null, _this._listeners);
                vscode_1.workspace.onDidCloseTextDocument(function (t) { return _this.onDidCloseTextDoument(connection, t); }, null, _this._listeners);
                vscode_1.workspace.onDidSaveTextDocument(function (t) { return _this.onDidSaveTextDocument(connection, t); }, null, _this._listeners);
                if (_this._capabilites.textDocumentSync === protocol_1.TextDocumentSyncKind.Full) {
                    _this._documentSyncDelayer = new async_1.Delayer(100);
                }
            }
            _this.hookFileEvents(connection);
            _this.hookConfigurationChanged(connection);
            _this.hookCapabilities(connection);
            _this._onReadyCallbacks.resolve();
            vscode_1.workspace.textDocuments.forEach(function (t) { return _this.onDidOpenTextDoument(connection, t); });
            return result;
        }, function (error) {
            if (_this._clientOptions.initializationFailedHandler) {
                if (_this._clientOptions.initializationFailedHandler(error)) {
                    _this.initialize(connection);
                }
                else {
                    _this.stop();
                    _this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof dataprotocol_jsonrpc_1.ResponseError && error.data && error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: "retry" }).then(function (item) {
                    if (is.defined(item) && item.id === 'retry') {
                        _this.initialize(connection);
                    }
                    else {
                        _this.stop();
                        _this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    vscode_1.window.showErrorMessage(error.message);
                }
                _this.error('Server initialization failed.', error);
                _this.stop();
                _this._onReadyCallbacks.reject(error);
            }
        });
    };
    LanguageClient.prototype.stop = function () {
        var _this = this;
        if (!this._connection) {
            this.state = ClientState.Stopped;
            return;
        }
        this.state = ClientState.Stopping;
        this.cleanUp();
        // unkook listeners
        return this.resolveConnection().then(function (connection) {
            connection.shutdown().then(function () {
                connection.exit();
                connection.dispose();
                _this.state = ClientState.Stopped;
                _this._connection = null;
                var toCheck = _this._childProcess;
                _this._childProcess = null;
                // Remove all markers
                _this.checkProcessDied(toCheck);
            });
        });
    };
    LanguageClient.prototype.cleanUp = function (diagnostics) {
        if (diagnostics === void 0) { diagnostics = true; }
        if (this._listeners) {
            this._listeners.forEach(function (listener) { return listener.dispose(); });
            this._listeners = null;
        }
        if (this._providers) {
            this._providers.forEach(function (provider) { return provider.dispose(); });
            this._providers = null;
        }
        if (diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = null;
        }
    };
    LanguageClient.prototype.notifyConfigurationChanged = function (settings) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                if (_this.isConnectionActive()) {
                    connection.didChangeConfiguration({ settings: settings });
                }
            }, function (error) {
                _this.error("Syncing settings failed.", JSON.stringify(error, null, 4));
            });
        }, function (error) {
            _this.error("Syncing settings failed.", JSON.stringify(error, null, 4));
        });
    };
    LanguageClient.prototype.notifyFileEvent = function (event) {
        var _this = this;
        this._fileEvents.push(event);
        this._fileEventDelayer.trigger(function () {
            _this.onReady().then(function () {
                _this.resolveConnection().then(function (connection) {
                    if (_this.isConnectionActive()) {
                        connection.didChangeWatchedFiles({ changes: _this._fileEvents });
                    }
                    _this._fileEvents = [];
                });
            }, function (error) {
                _this.error("Notify file events failed.", error);
            });
        });
    };
    LanguageClient.prototype.onDidOpenTextDoument = function (connection, textDocument) {
        if (!this._syncExpression.evaluate(textDocument)) {
            return;
        }
        connection.didOpenTextDocument(this._c2p.asOpenTextDocumentParams(textDocument));
    };
    LanguageClient.prototype.onDidChangeTextDocument = function (connection, event) {
        var _this = this;
        if (!this._syncExpression.evaluate(event.document)) {
            return;
        }
        var uri = event.document.uri.toString();
        if (this._capabilites.textDocumentSync === protocol_1.TextDocumentSyncKind.Incremental) {
            connection.didChangeTextDocument(this._c2p.asChangeTextDocumentParams(event));
        }
        else {
            if (this._documentSyncDelayer) {
                this._documentSyncDelayer.trigger(function () {
                    connection.didChangeTextDocument(_this._c2p.asChangeTextDocumentParams(event.document));
                }, -1);
            }
        }
    };
    LanguageClient.prototype.onDidCloseTextDoument = function (connection, textDocument) {
        if (!this._syncExpression.evaluate(textDocument)) {
            return;
        }
        connection.didCloseTextDocument(this._c2p.asCloseTextDocumentParams(textDocument));
    };
    LanguageClient.prototype.onDidSaveTextDocument = function (conneciton, textDocument) {
        if (!this._syncExpression.evaluate(textDocument)) {
            return;
        }
        conneciton.didSaveTextDocument(this._c2p.asSaveTextDocumentParams(textDocument));
    };
    LanguageClient.prototype.forceDocumentSync = function () {
        if (this._documentSyncDelayer) {
            this._documentSyncDelayer.forceDelivery();
        }
    };
    LanguageClient.prototype.handleDiagnostics = function (params) {
        var uri = vscode_1.Uri.parse(params.uri);
        var diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        this._diagnostics.set(uri, diagnostics);
    };
    LanguageClient.prototype.createConnection = function () {
        var _this = this;
        function getEnvironment(env) {
            if (!env) {
                return process.env;
            }
            var result = Object.create(null);
            Object.keys(process.env).forEach(function (key) { return result[key] = process.env[key]; });
            Object.keys(env).forEach(function (key) { return result[key] = env[key]; });
        }
        function startedInDebugMode() {
            var args = process.execArgv;
            if (args) {
                return args.some(function (arg) { return /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg); });
            }
            ;
            return false;
        }
        var encoding = this._clientOptions.stdioEncoding || 'utf8';
        var errorHandler = function (error, message, count) {
            _this.handleConnectionError(error, message, count);
        };
        var closeHandler = function () {
            _this.handleConnectionClosed();
        };
        var server = this._serverOptions;
        // We got a function.
        if (is.func(server)) {
            return server().then(function (result) {
                var info = result;
                if (info.writer && info.reader) {
                    return createConnection(info.reader, info.writer, errorHandler, closeHandler);
                }
                else {
                    var cp_1 = result;
                    return createConnection(cp_1.stdout, cp_1.stdin, errorHandler, closeHandler);
                }
            });
        }
        var json = null;
        var runDebug = server;
        if (is.defined(runDebug.run) || is.defined(runDebug.debug)) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        if (is.defined(json.module)) {
            var node_1 = json;
            if (node_1.runtime) {
                var args_1 = [];
                var options = node_1.options || Object.create(null);
                if (options.execArgv) {
                    options.execArgv.forEach(function (element) { return args_1.push(element); });
                }
                args_1.push(node_1.module);
                if (node_1.args) {
                    node_1.args.forEach(function (element) { return args_1.push(element); });
                }
                var execOptions = Object.create(null);
                execOptions.cwd = options.cwd || vscode_1.workspace.rootPath;
                execOptions.env = getEnvironment(options.env);
                if (node_1.transport === TransportKind.ipc) {
                    execOptions.stdio = [null, null, null, 'ipc'];
                    args_1.push('--node-ipc');
                }
                else if (node_1.transport === TransportKind.stdio) {
                    args_1.push('--stdio');
                }
                var process_1 = cp.spawn(node_1.runtime, args_1, execOptions);
                if (!process_1 || !process_1.pid) {
                    return Promise.reject("Launching server using runtime " + node_1.runtime + " failed.");
                }
                this._childProcess = process_1;
                process_1.stderr.on('data', function (data) { return _this.outputChannel.append(data.toString()); });
                if (node_1.transport === TransportKind.ipc) {
                    process_1.stdout.on('data', function (data) { return _this.outputChannel.append(data.toString()); });
                    return Promise.resolve(createConnection(new dataprotocol_jsonrpc_1.IPCMessageReader(process_1), new dataprotocol_jsonrpc_1.IPCMessageWriter(process_1), errorHandler, closeHandler));
                }
                else {
                    return Promise.resolve(createConnection(process_1.stdout, process_1.stdin, errorHandler, closeHandler));
                }
            }
            else {
                return new Promise(function (resolve, reject) {
                    var args = node_1.args && node_1.args.slice() || [];
                    if (node_1.transport === TransportKind.ipc) {
                        args.push('--node-ipc');
                    }
                    else if (node_1.transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    var options = node_1.options || Object.create(null);
                    options.execArgv = options.execArgv || [];
                    options.cwd = options.cwd || vscode_1.workspace.rootPath;
                    electron.fork(node_1.module, args || [], options, function (error, cp) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            _this._childProcess = cp;
                            cp.stderr.on('data', function (data) { return _this.outputChannel.append(data.toString()); });
                            if (node_1.transport === TransportKind.ipc) {
                                cp.stdout.on('data', function (data) { return _this.outputChannel.append(data.toString()); });
                                resolve(createConnection(new dataprotocol_jsonrpc_1.IPCMessageReader(_this._childProcess), new dataprotocol_jsonrpc_1.IPCMessageWriter(_this._childProcess), errorHandler, closeHandler));
                            }
                            else {
                                resolve(createConnection(cp.stdout, cp.stdin, errorHandler, closeHandler));
                            }
                        }
                    });
                });
            }
        }
        else if (is.defined(json.command)) {
            var command = json;
            var options = command.options || {};
            options.cwd = options.cwd || vscode_1.workspace.rootPath;
            var process_2 = cp.spawn(command.command, command.args, command.options);
            if (!process_2 || !process_2.pid) {
                return Promise.reject("Launching server using command " + command.command + " failed.");
            }
            process_2.stderr.on('data', function (data) { return _this.outputChannel.append(data.toString()); });
            this._childProcess = process_2;
            return Promise.resolve(createConnection(process_2.stdout, process_2.stdin, errorHandler, closeHandler));
        }
        return Promise.reject(new Error("Unsupported server configuartion " + JSON.stringify(server, null, 4)));
    };
    LanguageClient.prototype.handleConnectionClosed = function () {
        var self = this;
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        self._connection = null;
        self._childProcess = null;
        var action = this._clientOptions.errorHandler.closed();
        if (action === CloseAction.DoNotRestart) {
            self.error('Connection to server got closed. Server will not be restarted.');
            self.state = ClientState.Stopped;
            self.cleanUp();
        }
        else if (action === CloseAction.Restart && self.state !== ClientState.Stopping) {
            self.info('Connection to server got closed. Server will restart.');
            self.cleanUp(false);
            self.state = ClientState.Initial;
            self.start();
        }
    };
    LanguageClient.prototype.handleConnectionError = function (error, message, count) {
        var action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    };
    LanguageClient.prototype.checkProcessDied = function (childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(function () {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
            }
        }, 2000);
    };
    LanguageClient.prototype.hookConfigurationChanged = function (connection) {
        var _this = this;
        if (!this._clientOptions.synchronize.configurationSection) {
            return;
        }
        vscode_1.workspace.onDidChangeConfiguration(function (e) { return _this.onDidChangeConfiguration(connection); }, this, this._listeners);
        this.onDidChangeConfiguration(connection);
    };
    LanguageClient.prototype.refreshTrace = function (connection, sendNotification) {
        if (sendNotification === void 0) { sendNotification = false; }
        var config = vscode_1.workspace.getConfiguration(this._id);
        var trace = dataprotocol_jsonrpc_1.Trace.Off;
        if (config) {
            trace = dataprotocol_jsonrpc_1.Trace.fromString(config.get('trace.server', 'off'));
        }
        this._trace = trace;
        connection.trace(this._trace, this._tracer, sendNotification);
    };
    LanguageClient.prototype.onDidChangeConfiguration = function (connection) {
        this.refreshTrace(connection, true);
        var keys = null;
        var configurationSection = this._clientOptions.synchronize.configurationSection;
        if (is.string(configurationSection)) {
            keys = [configurationSection];
        }
        else if (is.stringArray(configurationSection)) {
            keys = configurationSection;
        }
        if (keys) {
            if (this.isConnectionActive()) {
                connection.didChangeConfiguration({ settings: this.extractSettingsInformation(keys) });
            }
        }
    };
    LanguageClient.prototype.extractSettingsInformation = function (keys) {
        function ensurePath(config, path) {
            var current = config;
            for (var i = 0; i < path.length - 1; i++) {
                var obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        var result = Object.create(null);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var index = key.indexOf('.');
            var config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(key);
            }
            if (config) {
                var path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    };
    LanguageClient.prototype.hookFileEvents = function (connection) {
        var _this = this;
        var fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        var watchers = null;
        if (is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        watchers.forEach(function (watcher) {
            watcher.onDidCreate(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Created
            }); }, null, _this._listeners);
            watcher.onDidChange(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Changed
            }); }, null, _this._listeners);
            watcher.onDidDelete(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Deleted
            }); }, null, _this._listeners);
        });
    };
    LanguageClient.prototype.hookCapabilities = function (connection) {
        var documentSelector = this._clientOptions.documentSelector;
        if (!documentSelector) {
            return;
        }
        this.hookCompletionProvider(documentSelector, connection);
        this.hookHoverProvider(documentSelector, connection);
        this.hookSignatureHelpProvider(documentSelector, connection);
        this.hookDefinitionProvider(documentSelector, connection);
        this.hookReferencesProvider(documentSelector, connection);
        this.hookDocumentHighlightProvider(documentSelector, connection);
        this.hookDocumentSymbolProvider(documentSelector, connection);
        this.hookWorkspaceSymbolProvider(connection);
        this.hookCodeActionsProvider(documentSelector, connection);
        this.hookCodeLensProvider(documentSelector, connection);
        this.hookDocumentFormattingProvider(documentSelector, connection);
        this.hookDocumentRangeFormattingProvider(documentSelector, connection);
        this.hookDocumentOnTypeFormattingProvider(documentSelector, connection);
        this.hookRenameProvider(documentSelector, connection);
        this.hookDocumentLinkProvider(documentSelector, connection);
    };
    LanguageClient.prototype.logFailedRequest = function (type, error) {
        this.error("Request " + type.method + " failed.", error);
    };
    /**
     * SQL-Carbon Edit
     * The helper method to add connection notifications after waiting for connections to be ready.
     * This is needed for early DMP registration, which can be done without waiting for connection setup to finish.
     *
     * @param type
     * @param handler
     */
    LanguageClient.prototype.onConnectionReadyNotification = function (type, handler) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                connection.onNotification(type, handler);
            });
        });
    };
    LanguageClient.prototype.hookDataProtocolProvider = function (providerId) {
        var self = this;
        var capabilitiesProvider = {
            getServerCapabilities: function (client) {
                var capabilitiesPromise = self._clientOptions.serverConnectionMetadata === undefined ?
                    self.sendRequest(protocol_1.CapabiltiesDiscoveryRequest.type, self._c2p.asCapabilitiesParams(client), undefined) :
                    new Promise(function (resolve, reject) { return resolve(self._clientOptions.serverConnectionMetadata); });
                return capabilitiesPromise.then(self._p2c.asServerCapabilities, function (error) {
                    self.logFailedRequest(protocol_1.ConnectionRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        };
        var connectionProvider = {
            handle: -1,
            connect: function (connUri, connInfo) {
                return self.sendRequest(protocol_1.ConnectionRequest.type, self._c2p.asConnectionParams(connUri, connInfo), undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ConnectionRequest.type, error);
                    return Promise.resolve(false);
                });
            },
            disconnect: function (connUri) {
                var params = {
                    ownerUri: connUri
                };
                return self.sendRequest(protocol_1.DisconnectRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.DisconnectRequest.type, error);
                    return Promise.resolve(false);
                });
            },
            cancelConnect: function (connUri) {
                var params = {
                    ownerUri: connUri
                };
                return self.sendRequest(protocol_1.CancelConnectRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.CancelConnectRequest.type, error);
                    return Promise.resolve(false);
                });
            },
            changeDatabase: function (connUri, newDatabase) {
                var params = {
                    ownerUri: connUri,
                    newDatabase: newDatabase
                };
                return self.sendRequest(protocol_1.ChangeDatabaseRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ChangeDatabaseRequest.type, error);
                    return Promise.resolve(false);
                });
            },
            listDatabases: function (connectionUri) {
                var params = {
                    ownerUri: connectionUri
                };
                return self.sendRequest(protocol_1.ListDatabasesRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ListDatabasesRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            rebuildIntelliSenseCache: function (connectionUri) {
                var params = {
                    ownerUri: connectionUri
                };
                self.sendNotification(protocol_1.RebuildIntelliSenseNotification.type, params);
                return Promise.resolve(undefined);
            },
            registerOnConnectionComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.ConnectionCompleteNotification.type, function (params) {
                    handler({
                        ownerUri: params.ownerUri,
                        connectionId: params.connectionId,
                        messages: params.messages,
                        errorMessage: params.errorMessage,
                        errorNumber: params.errorNumber,
                        serverInfo: params.serverInfo,
                        connectionSummary: params.connectionSummary
                    });
                });
            },
            registerOnIntelliSenseCacheComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.IntelliSenseReadyNotification.type, function (params) {
                    handler(params.ownerUri);
                });
            },
            registerOnConnectionChanged: function (handler) {
                self.onConnectionReadyNotification(protocol_1.ConnectionChangedNotification.type, function (params) {
                    handler({
                        connectionUri: params.ownerUri,
                        connection: params.connection
                    });
                });
            }
        };
        var queryProvider = {
            handle: -1,
            queryType: 'MSSQL',
            cancelQuery: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.QueryCancelRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryCancelRequest.type, error);
                    return Promise.reject(error);
                });
            },
            runQuery: function (ownerUri, selection, executionPlanOptions) {
                var params = {
                    ownerUri: ownerUri,
                    querySelection: selection,
                    executionPlanOptions: self._c2p.asExecutionPlanOptions(executionPlanOptions)
                };
                return self.sendRequest(protocol_1.QueryExecuteRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryExecuteRequest.type, error);
                    return Promise.reject(error);
                });
            },
            runQueryStatement: function (ownerUri, line, column) {
                var params = {
                    ownerUri: ownerUri,
                    line: line,
                    column: column
                };
                return self.sendRequest(protocol_1.QueryExecuteStatementRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryExecuteStatementRequest.type, error);
                    return Promise.reject(error);
                });
            },
            runQueryString: function (ownerUri, queryString) {
                var params = { ownerUri: ownerUri, query: queryString };
                return self.sendRequest(protocol_1.QueryExecuteStringRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryExecuteStringRequest.type, error);
                    return Promise.reject(error);
                });
            },
            runQueryAndReturn: function (ownerUri, queryString) {
                var params = { ownerUri: ownerUri, queryString: queryString };
                return self.sendRequest(protocol_1.SimpleExecuteRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.SimpleExecuteRequest.type, error);
                    return Promise.reject(error);
                });
            },
            getQueryRows: function (rowData) {
                return self.sendRequest(protocol_1.QueryExecuteSubsetRequest.type, rowData, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryExecuteSubsetRequest.type, error);
                    return Promise.reject(error);
                });
            },
            disposeQuery: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.QueryDisposeRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.QueryDisposeRequest.type, error);
                    return Promise.reject(error);
                });
            },
            registerOnQueryComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.QueryExecuteCompleteNotification.type, function (params) {
                    handler({
                        ownerUri: params.ownerUri,
                        batchSummaries: params.batchSummaries
                    });
                });
            },
            registerOnBatchStart: function (handler) {
                self.onConnectionReadyNotification(protocol_1.QueryExecuteBatchStartNotification.type, function (params) {
                    handler({
                        batchSummary: params.batchSummary,
                        ownerUri: params.ownerUri
                    });
                });
            },
            registerOnBatchComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.QueryExecuteBatchCompleteNotification.type, function (params) {
                    handler({
                        batchSummary: params.batchSummary,
                        ownerUri: params.ownerUri
                    });
                });
            },
            registerOnResultSetComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.QueryExecuteResultSetCompleteNotification.type, function (params) {
                    handler({
                        ownerUri: params.ownerUri,
                        resultSetSummary: params.resultSetSummary
                    });
                });
            },
            registerOnMessage: function (handler) {
                self.onConnectionReadyNotification(protocol_1.QueryExecuteMessageNotification.type, function (params) {
                    handler({
                        message: params.message,
                        ownerUri: params.ownerUri
                    });
                });
            },
            saveResults: function (requestParams) {
                switch (requestParams.resultFormat) {
                    case 'csv':
                        return self.sendRequest(protocol_1.SaveResultsAsCsvRequest.type, requestParams, undefined).then(function (result) {
                            return result;
                        }, function (error) {
                            self.logFailedRequest(protocol_1.EditCommitRequest.type, error);
                            return Promise.reject(error);
                        });
                    case 'json':
                        return self.sendRequest(protocol_1.SaveResultsAsJsonRequest.type, requestParams, undefined).then(function (result) {
                            return result;
                        }, function (error) {
                            self.logFailedRequest(protocol_1.EditCommitRequest.type, error);
                            return Promise.reject(error);
                        });
                    case 'excel':
                        return self.sendRequest(protocol_1.SaveResultsAsExcelRequest.type, requestParams, undefined).then(function (result) {
                            return result;
                        }, function (error) {
                            self.logFailedRequest(protocol_1.EditCommitRequest.type, error);
                            return Promise.reject(error);
                        });
                    default:
                        return Promise.reject('unsupported format');
                }
            },
            // Edit Data Requests
            commitEdit: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.EditCommitRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditCommitRequest.type, error);
                    return Promise.reject(error);
                });
            },
            createRow: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.EditCreateRowRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditCreateRowRequest.type, error);
                    return Promise.reject(error);
                });
            },
            deleteRow: function (ownerUri, rowId) {
                var params = { ownerUri: ownerUri, rowId: rowId };
                return self.sendRequest(protocol_1.EditDeleteRowRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditDeleteRowRequest.type, error);
                    return Promise.reject(error);
                });
            },
            disposeEdit: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.EditDisposeRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditDisposeRequest.type, error);
                    return Promise.reject(error);
                });
            },
            initializeEdit: function (ownerUri, schemaName, objectName, objectType, rowLimit) {
                var filters = { LimitResults: rowLimit };
                var params = { ownerUri: ownerUri, schemaName: schemaName, objectName: objectName, objectType: objectType, filters: filters };
                return self.sendRequest(protocol_1.EditInitializeRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditInitializeRequest.type, error);
                    return Promise.reject(error);
                });
            },
            revertCell: function (ownerUri, rowId, columnId) {
                var params = { ownerUri: ownerUri, rowId: rowId, columnId: columnId };
                return self.sendRequest(protocol_1.EditRevertCellRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditRevertCellRequest.type, error);
                    return Promise.reject(error);
                });
            },
            revertRow: function (ownerUri, rowId) {
                var params = { ownerUri: ownerUri, rowId: rowId };
                return self.sendRequest(protocol_1.EditRevertRowRequest.type, params, undefined).then(function (result) {
                    return undefined;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditRevertRowRequest.type, error);
                    return Promise.reject(error);
                });
            },
            updateCell: function (ownerUri, rowId, columnId, newValue) {
                var params = { ownerUri: ownerUri, rowId: rowId, columnId: columnId, newValue: newValue };
                return self.sendRequest(protocol_1.EditUpdateCellRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditUpdateCellRequest.type, error);
                    return Promise.reject(error);
                });
            },
            getEditRows: function (rowData) {
                return self.sendRequest(protocol_1.EditSubsetRequest.type, rowData, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.EditSubsetRequest.type, error);
                    return Promise.reject(error);
                });
            },
            // Edit Data Event Handlers
            registerOnEditSessionReady: function (handler) {
                self.onConnectionReadyNotification(protocol_1.EditSessionReadyNotification.type, function (params) {
                    handler(params.ownerUri, params.success, params.message);
                });
            },
        };
        var metadataProvider = {
            getMetadata: function (connectionUri) {
                return self.sendRequest(protocol_1.MetadataQueryRequest.type, self._c2p.asMetadataQueryParams(connectionUri), undefined).then(self._p2c.asProviderMetadata, function (error) {
                    self.logFailedRequest(protocol_1.MetadataQueryRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getDatabases: function (connectionUri) {
                return self.sendRequest(protocol_1.ListDatabasesRequest.type, self._c2p.asListDatabasesParams(connectionUri), undefined).then(function (result) {
                    return result.databaseNames;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ListDatabasesRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getTableInfo: function (connectionUri, metadata) {
                return self.sendRequest(protocol_1.TableMetadataRequest.type, self._c2p.asTableMetadataParams(connectionUri, metadata), undefined).then(function (result) {
                    return result.columns;
                }, function (error) {
                    self.logFailedRequest(protocol_1.TableMetadataRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getViewInfo: function (connectionUri, metadata) {
                return self.sendRequest(protocol_1.ViewMetadataRequest.type, self._c2p.asTableMetadataParams(connectionUri, metadata), undefined).then(function (result) {
                    return result.columns;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ViewMetadataRequest.type, error);
                    return Promise.resolve(undefined);
                });
            }
        };
        var adminServicesProvider = {
            createDatabase: function (connectionUri, database) {
                var params = { ownerUri: connectionUri, databaseInfo: database };
                return self.sendRequest(protocol_1.CreateDatabaseRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.CreateDatabaseRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getDefaultDatabaseInfo: function (connectionUri) {
                var params = { ownerUri: connectionUri };
                return self.sendRequest(protocol_1.DefaultDatabaseInfoRequest.type, params, undefined).then(function (result) {
                    return result.defaultDatabaseInfo;
                }, function (error) {
                    self.logFailedRequest(protocol_1.DefaultDatabaseInfoRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getDatabaseInfo: function (connectionUri) {
                var params = { ownerUri: connectionUri };
                return self.sendRequest(protocol_1.GetDatabaseInfoRequest.type, params, undefined).then(function (result) {
                    return result.databaseInfo;
                }, function (error) {
                    self.logFailedRequest(protocol_1.GetDatabaseInfoRequest.type, error);
                    return Promise.reject(error);
                });
            },
            createLogin: function (connectionUri, login) {
                var params = { ownerUri: connectionUri, loginInfo: login };
                return self.sendRequest(protocol_1.CreateLoginRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.CreateLoginRequest.type, error);
                    return Promise.resolve(undefined);
                });
            }
        };
        var disasterRecoveryProvider = {
            backup: function (connectionUri, backupInfo, taskExecutionMode) {
                var params = { ownerUri: connectionUri, backupInfo: backupInfo, taskExecutionMode: taskExecutionMode };
                return self.sendRequest(protocol_1.BackupRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.BackupRequest.type, error);
                    return Promise.resolve([]);
                });
            },
            getBackupConfigInfo: function (connectionUri) {
                var params = { ownerUri: connectionUri };
                return self.sendRequest(protocol_1.BackupConfigInfoRequest.type, params, undefined).then(function (result) {
                    return result.backupConfigInfo;
                }, function (error) {
                    self.logFailedRequest(protocol_1.BackupConfigInfoRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getRestorePlan: function (ownerUri, restoreInfo) {
                return self.sendRequest(protocol_1.RestorePlanRequest.type, self._c2p.asRestoreParams(ownerUri, restoreInfo), undefined).then(self._p2c.asRestorePlanResponse, function (error) {
                    self.logFailedRequest(protocol_1.RestorePlanRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            restore: function (ownerUri, restoreInfo) {
                return self.sendRequest(protocol_1.RestoreRequest.type, self._c2p.asRestoreParams(ownerUri, restoreInfo), undefined).then(self._p2c.asRestoreResponse, function (error) {
                    self.logFailedRequest(protocol_1.RestoreRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            getRestoreConfigInfo: function (ownerUri) {
                return self.sendRequest(protocol_1.RestoreConfigInfoRequest.type, self._c2p.asRestoreConfigInfoParams(ownerUri), undefined).then(self._p2c.asRestoreConfigInfo, function (error) {
                    self.logFailedRequest(protocol_1.RestorePlanRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            cancelRestorePlan: function (ownerUri, restoreInfo) {
                return self.sendRequest(protocol_1.CancelRestorePlanRequest.type, self._c2p.asRestoreParams(ownerUri, restoreInfo), undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.CancelRestorePlanRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
        };
        var objectExplorer = {
            createNewSession: function (connInfo) {
                return self.sendRequest(protocol_1.ObjectExplorerCreateSessionRequest.type, self._c2p.asConnectionDetail(connInfo), undefined).then(self._p2c.asObjectExplorerCreateSessionResponse, function (error) {
                    self.logFailedRequest(protocol_1.ObjectExplorerCreateSessionRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            expandNode: function (nodeInfo) {
                return self.sendRequest(protocol_1.ObjectExplorerExpandRequest.type, self._c2p.asExpandInfo(nodeInfo), undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ObjectExplorerExpandRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            refreshNode: function (nodeInfo) {
                return self.sendRequest(protocol_1.ObjectExplorerRefreshRequest.type, self._c2p.asExpandInfo(nodeInfo), undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.ObjectExplorerRefreshRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            closeSession: function (closeSessionInfo) {
                return self.sendRequest(protocol_1.ObjectExplorerCloseSessionRequest.type, self._c2p.asCloseSessionInfo(closeSessionInfo), undefined).then(self._p2c.asObjectExplorerCloseSessionResponse, function (error) {
                    self.logFailedRequest(protocol_1.ObjectExplorerCloseSessionRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnSessionCreated: function (handler) {
                self.onConnectionReadyNotification(protocol_1.ObjectExplorerCreateSessionCompleteNotification.type, function (params) {
                    handler({
                        sessionId: params.sessionId,
                        success: params.success,
                        rootNode: params.rootNode,
                        errorMessage: params.errorMessage
                    });
                });
            },
            registerOnExpandCompleted: function (handler) {
                self.onConnectionReadyNotification(protocol_1.ObjectExplorerExpandCompleteNotification.type, function (params) {
                    handler({
                        sessionId: params.sessionId,
                        nodes: params.nodes,
                        errorMessage: params.errorMessage,
                        nodePath: params.nodePath
                    });
                });
            },
        };
        var scriptingProvider = {
            scriptAsSelect: function (connectionUri, metadata, paramDetails) {
                return self.sendRequest(protocol_1.ScriptingRequest.type, self._c2p.asScriptingParams(connectionUri, dataprotocol_languageserver_types_1.ScriptOperation.Select, metadata, paramDetails), undefined).then(self._p2c.asScriptingResult, function (error) {
                    self.logFailedRequest(protocol_1.ScriptingRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            scriptAsCreate: function (connectionUri, metadata, paramDetails) {
                return self.sendRequest(protocol_1.ScriptingRequest.type, self._c2p.asScriptingParams(connectionUri, dataprotocol_languageserver_types_1.ScriptOperation.Create, metadata, paramDetails), undefined).then(self._p2c.asScriptingResult, function (error) {
                    self.logFailedRequest(protocol_1.ScriptingRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            scriptAsInsert: function (connectionUri, metadata, paramDetails) {
                return self.sendRequest(protocol_1.ScriptingRequest.type, self._c2p.asScriptingParams(connectionUri, dataprotocol_languageserver_types_1.ScriptOperation.Insert, metadata, paramDetails), undefined).then(self._p2c.asScriptingResult, function (error) {
                    self.logFailedRequest(protocol_1.ScriptingRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            scriptAsUpdate: function (connectionUri, metadata, paramDetails) {
                return self.sendRequest(protocol_1.ScriptingRequest.type, self._c2p.asScriptingParams(connectionUri, dataprotocol_languageserver_types_1.ScriptOperation.Update, metadata, paramDetails), undefined).then(self._p2c.asScriptingResult, function (error) {
                    self.logFailedRequest(protocol_1.ScriptingRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            scriptAsDelete: function (connectionUri, metadata, paramDetails) {
                return self.sendRequest(protocol_1.ScriptingRequest.type, self._c2p.asScriptingParams(connectionUri, dataprotocol_languageserver_types_1.ScriptOperation.Delete, metadata, paramDetails), undefined).then(self._p2c.asScriptingResult, function (error) {
                    self.logFailedRequest(protocol_1.ScriptingRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnScriptingComplete: function (handler) {
                self.onConnectionReadyNotification(protocol_1.ScriptingCompleteNotification.type, function (params) {
                    handler({
                        canceled: params.canceled,
                        errorDetails: params.errorDetails,
                        errorMessage: params.errorMessage,
                        hasError: params.hasError,
                        success: params.success,
                        operationId: params.operationId
                    });
                });
            },
        };
        var taskServicesProvider = {
            getAllTasks: function (listTasksParams) {
                return self.sendRequest(protocol_1.ListTasksRequest.type, self._c2p.asListTasksParams(listTasksParams), undefined).then(self._p2c.asListTasksResponse, function (error) {
                    self.logFailedRequest(protocol_1.ListTasksRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            cancelTask: function (cancelTaskParams) {
                return self.sendRequest(protocol_1.CancelTaskRequest.type, self._c2p.asCancelTaskParams(cancelTaskParams), undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.CancelTaskRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnTaskCreated: function (handler) {
                self.onConnectionReadyNotification(protocol_1.TaskCreatedNotification.type, function (params) {
                    handler(self._p2c.asTaskInfo(params));
                });
            },
            registerOnTaskStatusChanged: function (handler) {
                self.onConnectionReadyNotification(protocol_1.TaskStatusChangedNotification.type, function (params) {
                    handler({
                        taskId: params.taskId,
                        status: params.status,
                        message: params.message,
                        script: params.script,
                        duration: params.duration
                    });
                });
            }
        };
        var fileBrowserProvider = {
            openFileBrowser: function (ownerUri, expandPath, fileFilters, changeFilter) {
                var params = { ownerUri: ownerUri, expandPath: expandPath, fileFilters: fileFilters, changeFilter: changeFilter };
                return self.sendRequest(protocol_1.FileBrowserOpenRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.FileBrowserOpenRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnFileBrowserOpened: function (handler) {
                self.onConnectionReadyNotification(protocol_1.FileBrowserOpenedNotification.type, function (params) {
                    handler(params);
                });
            },
            expandFolderNode: function (ownerUri, expandPath) {
                var params = { ownerUri: ownerUri, expandPath: expandPath };
                return self.sendRequest(protocol_1.FileBrowserExpandRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.FileBrowserExpandRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnFolderNodeExpanded: function (handler) {
                self.onConnectionReadyNotification(protocol_1.FileBrowserExpandedNotification.type, function (params) {
                    handler(params);
                });
            },
            validateFilePaths: function (ownerUri, serviceType, selectedFiles) {
                var params = { ownerUri: ownerUri, serviceType: serviceType, selectedFiles: selectedFiles };
                return self.sendRequest(protocol_1.FileBrowserValidateRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.FileBrowserValidateRequest.type, error);
                    return Promise.resolve(undefined);
                });
            },
            registerOnFilePathsValidated: function (handler) {
                self.onConnectionReadyNotification(protocol_1.FileBrowserValidatedNotification.type, function (params) {
                    handler(params);
                });
            },
            closeFileBrowser: function (ownerUri) {
                var params = { ownerUri: ownerUri };
                return self.sendRequest(protocol_1.FileBrowserCloseRequest.type, params, undefined).then(function (result) {
                    return result;
                }, function (error) {
                    self.logFailedRequest(protocol_1.FileBrowserCloseRequest.type, error);
                    return Promise.resolve(undefined);
                });
            }
        };
        var serializationProvider = {
            handle: 0,
            saveAs: function (saveFormat, savePath, results, appendToFile) {
                throw new Error('NotImplemented');
            }
        };
        this._providers.push(data_1.dataprotocol.registerProvider({
            handle: -1,
            providerId: providerId,
            capabilitiesProvider: capabilitiesProvider,
            connectionProvider: connectionProvider,
            queryProvider: queryProvider,
            metadataProvider: metadataProvider,
            scriptingProvider: scriptingProvider,
            objectExplorerProvider: objectExplorer,
            adminServicesProvider: adminServicesProvider,
            disasterRecoveryProvider: disasterRecoveryProvider,
            taskServicesProvider: taskServicesProvider,
            fileBrowserProvider: fileBrowserProvider
        }));
        // Hook to the workspace-wide notifications that aren't routed to a specific provider
        data_1.dataprotocol.onDidChangeLanguageFlavor(function (e) {
            self.sendNotification(protocol_1.LanguageFlavorChangedNotification.type, e);
        }, this, this._listeners);
    };
    LanguageClient.prototype.hookCompletionProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.completionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCompletionItemProvider.apply(vscode_1.languages, [documentSelector, {
            provideCompletionItems: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.CompletionRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asCompletionResult, function (error) {
                    _this.logFailedRequest(protocol_1.CompletionRequest.type, error);
                    return Promise.resolve([]);
                });
            },
            resolveCompletionItem: this._capabilites.completionProvider.resolveProvider
                ? function (item, token) {
                    return _this.doSendRequest(connection, protocol_1.CompletionResolveRequest.type, _this._c2p.asCompletionItem(item), token).then(_this._p2c.asCompletionItem, function (error) {
                        _this.logFailedRequest(protocol_1.CompletionResolveRequest.type, error);
                        return Promise.resolve(item);
                    });
                }
                : undefined
        }].concat(this._capabilites.completionProvider.triggerCharacters)));
    };
    LanguageClient.prototype.hookHoverProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.hoverProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerHoverProvider(documentSelector, {
            provideHover: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.HoverRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asHover, function (error) {
                    _this.logFailedRequest(protocol_1.HoverRequest.type, error);
                    return Promise.resolve(null);
                });
            }
        }));
    };
    LanguageClient.prototype.hookSignatureHelpProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.signatureHelpProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerSignatureHelpProvider.apply(vscode_1.languages, [documentSelector, {
            provideSignatureHelp: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.SignatureHelpRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asSignatureHelp, function (error) {
                    _this.logFailedRequest(protocol_1.SignatureHelpRequest.type, error);
                    return Promise.resolve(null);
                });
            }
        }].concat(this._capabilites.signatureHelpProvider.triggerCharacters)));
    };
    LanguageClient.prototype.hookDefinitionProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.definitionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDefinitionProvider(documentSelector, {
            provideDefinition: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.DefinitionRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asDefinitionResult, function (error) {
                    _this.logFailedRequest(protocol_1.DefinitionRequest.type, error);
                    return Promise.resolve(null);
                });
            }
        }));
    };
    LanguageClient.prototype.hookReferencesProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.referencesProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerReferenceProvider(documentSelector, {
            provideReferences: function (document, position, options, token) {
                return _this.doSendRequest(connection, protocol_1.ReferencesRequest.type, _this._c2p.asReferenceParams(document, position, options), token).then(_this._p2c.asReferences, function (error) {
                    _this.logFailedRequest(protocol_1.ReferencesRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentHighlightProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentHighlightProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentHighlightProvider(documentSelector, {
            provideDocumentHighlights: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.DocumentHighlightRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asDocumentHighlights, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentHighlightRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentSymbolProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentSymbolProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentSymbolProvider(documentSelector, {
            provideDocumentSymbols: function (document, token) {
                return _this.doSendRequest(connection, protocol_1.DocumentSymbolRequest.type, _this._c2p.asDocumentSymbolParams(document), token).then(_this._p2c.asSymbolInformations, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentSymbolRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookWorkspaceSymbolProvider = function (connection) {
        var _this = this;
        if (!this._capabilites.workspaceSymbolProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols: function (query, token) {
                return _this.doSendRequest(connection, protocol_1.WorkspaceSymbolRequest.type, { query: query }, token).then(_this._p2c.asSymbolInformations, function (error) {
                    _this.logFailedRequest(protocol_1.WorkspaceSymbolRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookCodeActionsProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.codeActionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCodeActionsProvider(documentSelector, {
            provideCodeActions: function (document, range, context, token) {
                var params = {
                    textDocument: _this._c2p.asTextDocumentIdentifier(document),
                    range: _this._c2p.asRange(range),
                    context: _this._c2p.asCodeActionContext(context)
                };
                return _this.doSendRequest(connection, protocol_1.CodeActionRequest.type, params, token).then(_this._p2c.asCommands, function (error) {
                    _this.logFailedRequest(protocol_1.CodeActionRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookCodeLensProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.codeLensProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCodeLensProvider(documentSelector, {
            provideCodeLenses: function (document, token) {
                return _this.doSendRequest(connection, protocol_1.CodeLensRequest.type, _this._c2p.asCodeLensParams(document), token).then(_this._p2c.asCodeLenses, function (error) {
                    _this.logFailedRequest(protocol_1.CodeLensRequest.type, error);
                    return Promise.resolve([]);
                });
            },
            resolveCodeLens: (this._capabilites.codeLensProvider.resolveProvider)
                ? function (codeLens, token) {
                    return _this.doSendRequest(connection, protocol_1.CodeLensResolveRequest.type, _this._c2p.asCodeLens(codeLens), token).then(_this._p2c.asCodeLens, function (error) {
                        _this.logFailedRequest(protocol_1.CodeLensResolveRequest.type, error);
                        return codeLens;
                    });
                }
                : undefined
        }));
    };
    LanguageClient.prototype.hookDocumentFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentFormattingProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentFormattingEditProvider(documentSelector, {
            provideDocumentFormattingEdits: function (document, options, token) {
                var params = {
                    textDocument: _this._c2p.asTextDocumentIdentifier(document),
                    options: _this._c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentFormattingRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentRangeFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentRangeFormattingProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentRangeFormattingEditProvider(documentSelector, {
            provideDocumentRangeFormattingEdits: function (document, range, options, token) {
                var params = {
                    textDocument: _this._c2p.asTextDocumentIdentifier(document),
                    range: _this._c2p.asRange(range),
                    options: _this._c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentRangeFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentRangeFormattingRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentOnTypeFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentOnTypeFormattingProvider) {
            return;
        }
        var formatCapabilities = this._capabilites.documentOnTypeFormattingProvider;
        this._providers.push(vscode_1.languages.registerOnTypeFormattingEditProvider.apply(vscode_1.languages, [documentSelector, {
            provideOnTypeFormattingEdits: function (document, position, ch, options, token) {
                var params = {
                    textDocument: _this._c2p.asTextDocumentIdentifier(document),
                    position: _this._c2p.asPosition(position),
                    ch: ch,
                    options: _this._c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentOnTypeFormattingRequest.type, error);
                    return Promise.resolve([]);
                });
            }
        }, formatCapabilities.firstTriggerCharacter].concat(formatCapabilities.moreTriggerCharacter)));
    };
    LanguageClient.prototype.hookRenameProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.renameProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerRenameProvider(documentSelector, {
            provideRenameEdits: function (document, position, newName, token) {
                var params = {
                    textDocument: _this._c2p.asTextDocumentIdentifier(document),
                    position: _this._c2p.asPosition(position),
                    newName: newName
                };
                return _this.doSendRequest(connection, protocol_1.RenameRequest.type, params, token).then(_this._p2c.asWorkspaceEdit, function (error) {
                    _this.logFailedRequest(protocol_1.RenameRequest.type, error);
                    Promise.resolve(new Error(error.message));
                });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentLinkProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentLinkProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentLinkProvider(documentSelector, {
            provideDocumentLinks: function (document, token) {
                return _this.doSendRequest(connection, protocol_1.DocumentLinkRequest.type, _this._c2p.asDocumentLinkParams(document), token).then(_this._p2c.asDocumentLinks, function (error) {
                    _this.logFailedRequest(protocol_1.DocumentLinkRequest.type, error);
                    Promise.resolve(new Error(error.message));
                });
            },
            resolveDocumentLink: this._capabilites.documentLinkProvider.resolveProvider
                ? function (link, token) {
                    return _this.doSendRequest(connection, protocol_1.DocumentLinkResolveRequest.type, _this._c2p.asDocumentLink(link), token).then(_this._p2c.asDocumentLink, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentLinkResolveRequest.type, error);
                        Promise.resolve(new Error(error.message));
                    });
                }
                : undefined
        }));
    };
    return LanguageClient;
}());
exports.LanguageClient = LanguageClient;
var SettingMonitor = (function () {
    function SettingMonitor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    SettingMonitor.prototype.start = function () {
        var _this = this;
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(function () {
            if (_this._client.needsStop()) {
                _this._client.stop();
            }
        });
    };
    SettingMonitor.prototype.onDidChangeConfiguration = function () {
        var index = this._setting.indexOf('.');
        var primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        var rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        var enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    };
    return SettingMonitor;
}());
exports.SettingMonitor = SettingMonitor;
